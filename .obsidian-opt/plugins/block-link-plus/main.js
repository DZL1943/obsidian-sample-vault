/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject2(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined2(input) {
        return input === void 0;
      }
      function isNumber2(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate2(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map2(arr, fn) {
        var res = [], i, arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function extend3(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t = Object(this), len = t.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend3(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined2(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined2(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined2(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined2(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined2(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined2(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined2(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined2(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined2(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined2(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i = 0; i < momentPropertiesLen; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined2(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend3(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key, argLen = arguments.length;
            for (i = 0; i < argLen; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn(
              msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set2(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend3({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject2(parentConfig[prop]) && isObject2(childConfig[prop])) {
              res[prop] = {};
              extend3(res[prop], parentConfig[prop]);
              extend3(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject2(parentConfig[prop])) {
            res[prop] = extend3({}, res[prop]);
          }
        }
        return res;
      }
      function Locale2(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now3) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now3) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
          }
          return output;
        };
      }
      function formatMoment(m, format2) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m);
      }
      function expandFormat(format2, locale2) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format2;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff3, output) {
        var format2 = this._relativeTime[diff3 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      function isLeapYear2(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      function get(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear2(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
              value,
              mom.month(),
              daysInMonth2(value, mom.month())
            );
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
          for (i = 0; i < prioritizedLen; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s2) {
        return regexEscape(
          s2.replace("\\", "").replace(
            /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
            function(matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
            }
          )
        );
      }
      function regexEscape(s2) {
        return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber2(callback)) {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i = 0; i < tokenLen; i++) {
          tokens[token2[i]] = func;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n2, x) {
        return (n2 % x + x) % x;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth2(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear2(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format2) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format2) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format2, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format2, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber2(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth2(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth2(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear2(year) {
        return isLeapYear2(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear2(this.year());
      }
      function createDate(y, m, d, h, M, s2, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M, s2, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s2, ms);
        }
        return date;
      }
      function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset2(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset2(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear2(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear2(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear2(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset2(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset2(year, dow, doy), weekOffsetNext = firstWeekOffset2(year + 1, dow, doy);
        return (daysInYear2(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(
        ["w", "ww", "W", "WW"],
        function(input, week, config, token2) {
          week[token2.substr(0, 1)] = toInt(input);
        }
      );
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n2) {
        return ws.slice(n2, 7).concat(ws.slice(0, n2));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format2) {
        var weekdays2 = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays2, this._week.dow) : m ? weekdays2[m.day()] : weekdays2;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i = 0, j, next, locale2, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name) {
        return name.match("^[^/\\\\]*$") != null;
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined2(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale2(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale2(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth2(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc28222 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets2 = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i, l2, string = config._i, match5 = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match5) {
          getParsingFlags(config).iso = true;
          for (i = 0, l2 = isoDatesLen; i < l2; i++) {
            if (isoDates[i][1].exec(match5[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match5[3]) {
            for (i = 0, l2 = isoTimesLen; i < l2; i++) {
              if (isoTimes[i][1].exec(match5[3])) {
                timeFormat = (match5[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match5[4]) {
            if (tzRegex.exec(match5[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear2(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear2(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC28222(s2) {
        return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets2[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match5 = rfc28222.exec(preprocessRFC28222(config._i)), parsedArray;
        if (match5) {
          parsedArray = extractFromRFC2822Strings(
            match5[4],
            match5[3],
            match5[2],
            match5[5],
            match5[6],
            match5[7]
          );
          if (!checkWeekday(match5[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match5[8], match5[9], match5[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear2(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(
            w.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
          week = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i = 0; i < tokenLen; i++) {
          token2 = tokens2[i];
          parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(
              string.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i = 0; i < configfLen; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend3(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map2(
          [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate2(input)) {
          config._d = input;
        } else if (isArray(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined2(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate2(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map2(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject2(input)) {
          configFromObject(config);
        } else if (isNumber2(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject2(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, false);
      }
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now2 = function() {
        return Date.now ? Date.now() : +new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i, orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i = 0; i < orderLen; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration2(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months3 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months3 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration2;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset2(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset3 = this.utcOffset(), sign2 = "+";
          if (offset3 < 0) {
            offset3 = -offset3;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset3 / 60), 2) + separator + zeroFill(~~offset3 % 60, 2);
        });
      }
      offset2("Z", ":");
      offset2("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff3;
        if (model._isUTC) {
          res = model.clone();
          diff3 = (isMoment(input) || isDate2(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff3);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset3 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset3 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset3, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset3 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined2(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match5 = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber2(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match5 = aspNetRegex.exec(input)) {
          sign2 = match5[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match5[DATE]) * sign2,
            h: toInt(match5[HOUR]) * sign2,
            m: toInt(match5[MINUTE]) * sign2,
            s: toInt(match5[SECOND]) * sign2,
            ms: toInt(absRound(match5[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match5 = isoRegex.exec(input)) {
          sign2 = match5[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match5[2], sign2),
            M: parseIso(match5[3], sign2),
            w: parseIso(match5[4], sign2),
            d: parseIso(match5[5], sign2),
            h: parseIso(match5[6], sign2),
            m: parseIso(match5[7], sign2),
            s: parseIso(match5[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration2(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration2.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months3 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months3) {
          setMonth(mom, get(mom, "Month") + months3 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months3);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString2(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate2(input) || isString2(input) || isNumber2(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property, propertyLen = properties.length;
        for (i = 0; i < propertyLen; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber2(item) && isString2(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject2(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now3) {
        var diff3 = myMoment.diff(now3, "days", true);
        return diff3 < -6 ? "sameElse" : diff3 < -1 ? "lastWeek" : diff3 < 0 ? "lastDay" : diff3 < 1 ? "sameDay" : diff3 < 2 ? "nextDay" : diff3 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now3 = time || createLocal(), sod = cloneWithOffset(now3, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now3) : formats[format2]);
        return this.format(
          output || this.localeData().calendar(format2, this, createLocal(now3))
        );
      }
      function clone2() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff2(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString2() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
            m,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(
          m,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray2() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend3({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(
        ["N", "NN", "NNN", "NNNN", "NNNNN"],
        function(input, array, config, token2) {
          var era = config._locale.erasParse(input, token2, config._strict);
          if (era) {
            getParsingFlags(config).era = era;
          } else {
            getParsingFlags(config).invalidEra = input;
          }
        }
      );
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match5;
        if (config._locale._eraYearOrdinalRegex) {
          match5 = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match5);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format2) {
        var i, l2, date, eras2 = this._eras || getLocale("en")._eras;
        for (i = 0, l2 = eras2.length; i < l2; ++i) {
          switch (typeof eras2[i].since) {
            case "string":
              date = hooks(eras2[i].since).startOf("day");
              eras2[i].since = date.valueOf();
              break;
          }
          switch (typeof eras2[i].until) {
            case "undefined":
              eras2[i].until = Infinity;
              break;
            case "string":
              date = hooks(eras2[i].until).startOf("day").valueOf();
              eras2[i].until = date.valueOf();
              break;
          }
        }
        return eras2;
      }
      function localeErasParse(eraName, format2, strict) {
        var i, l2, eras2 = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l2 = eras2.length; i < l2; ++i) {
          name = eras2[i].name.toUpperCase();
          abbr = eras2[i].abbr.toUpperCase();
          narrow = eras2[i].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras2[i];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras2[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras2[i];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras2[i];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i, l2, val, eras2 = this.localeData().eras();
        for (i = 0, l2 = eras2.length; i < l2; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras2[i].since <= val && val <= eras2[i].until) {
            return eras2[i].name;
          }
          if (eras2[i].until <= val && val <= eras2[i].since) {
            return eras2[i].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i, l2, val, eras2 = this.localeData().eras();
        for (i = 0, l2 = eras2.length; i < l2; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras2[i].since <= val && val <= eras2[i].until) {
            return eras2[i].narrow;
          }
          if (eras2[i].until <= val && val <= eras2[i].since) {
            return eras2[i].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i, l2, val, eras2 = this.localeData().eras();
        for (i = 0, l2 = eras2.length; i < l2; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras2[i].since <= val && val <= eras2[i].until) {
            return eras2[i].abbr;
          }
          if (eras2[i].until <= val && val <= eras2[i].since) {
            return eras2[i].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i, l2, dir, val, eras2 = this.localeData().eras();
        for (i = 0, l2 = eras2.length; i < l2; ++i) {
          dir = eras2[i].since <= eras2[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras2[i].since <= val && val <= eras2[i].until || eras2[i].until <= val && val <= eras2[i].since) {
            return (this.year() - hooks(eras2[i].since).year()) * dir + eras2[i].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l2, eras2 = this.eras();
        for (i = 0, l2 = eras2.length; i < l2; ++i) {
          namePieces.push(regexEscape(eras2[i].name));
          abbrPieces.push(regexEscape(eras2[i].abbr));
          narrowPieces.push(regexEscape(eras2[i].narrow));
          mixedPieces.push(regexEscape(eras2[i].name));
          mixedPieces.push(regexEscape(eras2[i].abbr));
          mixedPieces.push(regexEscape(eras2[i].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(
        ["gggg", "ggggg", "GGGG", "GGGGG"],
        function(input, week, config, token2) {
          week[token2.substr(0, 2)] = toInt(input);
        }
      );
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday(),
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone2;
      proto.diff = diff2;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray2;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString2;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string) {
        return string;
      }
      var proto$1 = Locale2.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set2;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format2);
      }
      function listMonthsImpl(format2, index, field) {
        if (isNumber2(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format2, i, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber2(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber2(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format2, (i + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months3 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months3 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months3 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months3) + days2) * 864e5;
          days2 = 0;
          months3 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months3 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months3 / 12);
        months3 %= 12;
        data.days = days2;
        data.months = months3;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months3) {
        return months3 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months3, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months3 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months3;
            case "quarter":
              return months3 / 3;
            case "year":
              return months3 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$12() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months2 = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months3 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months3 <= 1 && ["M"] || months3 < thresholds2.M && ["MM", months3] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months3 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months3 / 12);
        months3 %= 12;
        s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months3 ? ymSign + months3 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
      }
      var proto$2 = Duration2.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$12;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months2;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.4";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now2;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate2;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    });
  }
});

// node_modules/obsidian-dataview/lib/index.js
var require_lib = __commonJS({
  "node_modules/obsidian-dataview/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require("obsidian");
    var LuxonError2 = class extends Error {
    };
    var InvalidDateTimeError2 = class extends LuxonError2 {
      constructor(reason) {
        super(`Invalid DateTime: ${reason.toMessage()}`);
      }
    };
    var InvalidIntervalError2 = class extends LuxonError2 {
      constructor(reason) {
        super(`Invalid Interval: ${reason.toMessage()}`);
      }
    };
    var InvalidDurationError2 = class extends LuxonError2 {
      constructor(reason) {
        super(`Invalid Duration: ${reason.toMessage()}`);
      }
    };
    var ConflictingSpecificationError2 = class extends LuxonError2 {
    };
    var InvalidUnitError2 = class extends LuxonError2 {
      constructor(unit) {
        super(`Invalid unit ${unit}`);
      }
    };
    var InvalidArgumentError2 = class extends LuxonError2 {
    };
    var ZoneIsAbstractError2 = class extends LuxonError2 {
      constructor() {
        super("Zone is an abstract class");
      }
    };
    var n2 = "numeric";
    var s2 = "short";
    var l2 = "long";
    var DATE_SHORT2 = {
      year: n2,
      month: n2,
      day: n2
    };
    var DATE_MED2 = {
      year: n2,
      month: s2,
      day: n2
    };
    var DATE_MED_WITH_WEEKDAY2 = {
      year: n2,
      month: s2,
      day: n2,
      weekday: s2
    };
    var DATE_FULL2 = {
      year: n2,
      month: l2,
      day: n2
    };
    var DATE_HUGE2 = {
      year: n2,
      month: l2,
      day: n2,
      weekday: l2
    };
    var TIME_SIMPLE2 = {
      hour: n2,
      minute: n2
    };
    var TIME_WITH_SECONDS2 = {
      hour: n2,
      minute: n2,
      second: n2
    };
    var TIME_WITH_SHORT_OFFSET2 = {
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: s2
    };
    var TIME_WITH_LONG_OFFSET2 = {
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: l2
    };
    var TIME_24_SIMPLE2 = {
      hour: n2,
      minute: n2,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SECONDS2 = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SHORT_OFFSET2 = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23",
      timeZoneName: s2
    };
    var TIME_24_WITH_LONG_OFFSET2 = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23",
      timeZoneName: l2
    };
    var DATETIME_SHORT2 = {
      year: n2,
      month: n2,
      day: n2,
      hour: n2,
      minute: n2
    };
    var DATETIME_SHORT_WITH_SECONDS2 = {
      year: n2,
      month: n2,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2
    };
    var DATETIME_MED2 = {
      year: n2,
      month: s2,
      day: n2,
      hour: n2,
      minute: n2
    };
    var DATETIME_MED_WITH_SECONDS2 = {
      year: n2,
      month: s2,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2
    };
    var DATETIME_MED_WITH_WEEKDAY2 = {
      year: n2,
      month: s2,
      day: n2,
      weekday: s2,
      hour: n2,
      minute: n2
    };
    var DATETIME_FULL2 = {
      year: n2,
      month: l2,
      day: n2,
      hour: n2,
      minute: n2,
      timeZoneName: s2
    };
    var DATETIME_FULL_WITH_SECONDS2 = {
      year: n2,
      month: l2,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: s2
    };
    var DATETIME_HUGE2 = {
      year: n2,
      month: l2,
      day: n2,
      weekday: l2,
      hour: n2,
      minute: n2,
      timeZoneName: l2
    };
    var DATETIME_HUGE_WITH_SECONDS2 = {
      year: n2,
      month: l2,
      day: n2,
      weekday: l2,
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: l2
    };
    var Zone2 = class {
      /**
       * The type of zone
       * @abstract
       * @type {string}
       */
      get type() {
        throw new ZoneIsAbstractError2();
      }
      /**
       * The name of this zone.
       * @abstract
       * @type {string}
       */
      get name() {
        throw new ZoneIsAbstractError2();
      }
      get ianaName() {
        return this.name;
      }
      /**
       * Returns whether the offset is known to be fixed for the whole year.
       * @abstract
       * @type {boolean}
       */
      get isUniversal() {
        throw new ZoneIsAbstractError2();
      }
      /**
       * Returns the offset's common name (such as EST) at the specified timestamp
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the name
       * @param {Object} opts - Options to affect the format
       * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
       * @param {string} opts.locale - What locale to return the offset name in.
       * @return {string}
       */
      offsetName(ts, opts) {
        throw new ZoneIsAbstractError2();
      }
      /**
       * Returns the offset's value as a string
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the offset
       * @param {string} format - What style of offset to return.
       *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
       * @return {string}
       */
      formatOffset(ts, format) {
        throw new ZoneIsAbstractError2();
      }
      /**
       * Return the offset in minutes for this zone at the specified timestamp.
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to compute the offset
       * @return {number}
       */
      offset(ts) {
        throw new ZoneIsAbstractError2();
      }
      /**
       * Return whether this Zone is equal to another zone
       * @abstract
       * @param {Zone} otherZone - the zone to compare
       * @return {boolean}
       */
      equals(otherZone) {
        throw new ZoneIsAbstractError2();
      }
      /**
       * Return whether this Zone is valid.
       * @abstract
       * @type {boolean}
       */
      get isValid() {
        throw new ZoneIsAbstractError2();
      }
    };
    var singleton$12 = null;
    var SystemZone2 = class extends Zone2 {
      /**
       * Get a singleton instance of the local zone
       * @return {SystemZone}
       */
      static get instance() {
        if (singleton$12 === null) {
          singleton$12 = new SystemZone2();
        }
        return singleton$12;
      }
      /** @override **/
      get type() {
        return "system";
      }
      /** @override **/
      get name() {
        return new Intl.DateTimeFormat().resolvedOptions().timeZone;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format, locale }) {
        return parseZoneInfo2(ts, format, locale);
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset2(this.offset(ts), format);
      }
      /** @override **/
      offset(ts) {
        return -new Date(ts).getTimezoneOffset();
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "system";
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var dtfCache2 = {};
    function makeDTF2(zone) {
      if (!dtfCache2[zone]) {
        dtfCache2[zone] = new Intl.DateTimeFormat("en-US", {
          hour12: false,
          timeZone: zone,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          era: "short"
        });
      }
      return dtfCache2[zone];
    }
    var typeToPos2 = {
      year: 0,
      month: 1,
      day: 2,
      era: 3,
      hour: 4,
      minute: 5,
      second: 6
    };
    function hackyOffset2(dtf, date) {
      const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
      return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
    }
    function partsOffset2(dtf, date) {
      const formatted = dtf.formatToParts(date);
      const filled = [];
      for (let i = 0; i < formatted.length; i++) {
        const { type: type2, value } = formatted[i];
        const pos = typeToPos2[type2];
        if (type2 === "era") {
          filled[pos] = value;
        } else if (!isUndefined2(pos)) {
          filled[pos] = parseInt(value, 10);
        }
      }
      return filled;
    }
    var ianaZoneCache2 = {};
    var IANAZone2 = class extends Zone2 {
      /**
       * @param {string} name - Zone name
       * @return {IANAZone}
       */
      static create(name) {
        if (!ianaZoneCache2[name]) {
          ianaZoneCache2[name] = new IANAZone2(name);
        }
        return ianaZoneCache2[name];
      }
      /**
       * Reset local caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCache() {
        ianaZoneCache2 = {};
        dtfCache2 = {};
      }
      /**
       * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
       * @param {string} s - The string to check validity on
       * @example IANAZone.isValidSpecifier("America/New_York") //=> true
       * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
       * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
       * @return {boolean}
       */
      static isValidSpecifier(s3) {
        return this.isValidZone(s3);
      }
      /**
       * Returns whether the provided string identifies a real zone
       * @param {string} zone - The string to check
       * @example IANAZone.isValidZone("America/New_York") //=> true
       * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
       * @example IANAZone.isValidZone("Sport~~blorp") //=> false
       * @return {boolean}
       */
      static isValidZone(zone) {
        if (!zone) {
          return false;
        }
        try {
          new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
          return true;
        } catch (e) {
          return false;
        }
      }
      constructor(name) {
        super();
        this.zoneName = name;
        this.valid = IANAZone2.isValidZone(name);
      }
      /** @override **/
      get type() {
        return "iana";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format, locale }) {
        return parseZoneInfo2(ts, format, locale, this.name);
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset2(this.offset(ts), format);
      }
      /** @override **/
      offset(ts) {
        const date = new Date(ts);
        if (isNaN(date))
          return NaN;
        const dtf = makeDTF2(this.name);
        let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset2(dtf, date) : hackyOffset2(dtf, date);
        if (adOrBc === "BC") {
          year = -Math.abs(year) + 1;
        }
        const adjustedHour = hour === 24 ? 0 : hour;
        const asUTC = objToLocalTS2({
          year,
          month,
          day,
          hour: adjustedHour,
          minute,
          second,
          millisecond: 0
        });
        let asTS = +date;
        const over = asTS % 1e3;
        asTS -= over >= 0 ? over : 1e3 + over;
        return (asUTC - asTS) / (60 * 1e3);
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "iana" && otherZone.name === this.name;
      }
      /** @override **/
      get isValid() {
        return this.valid;
      }
    };
    var intlLFCache2 = {};
    function getCachedLF2(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlLFCache2[key];
      if (!dtf) {
        dtf = new Intl.ListFormat(locString, opts);
        intlLFCache2[key] = dtf;
      }
      return dtf;
    }
    var intlDTCache2 = {};
    function getCachedDTF2(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlDTCache2[key];
      if (!dtf) {
        dtf = new Intl.DateTimeFormat(locString, opts);
        intlDTCache2[key] = dtf;
      }
      return dtf;
    }
    var intlNumCache2 = {};
    function getCachedINF2(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let inf = intlNumCache2[key];
      if (!inf) {
        inf = new Intl.NumberFormat(locString, opts);
        intlNumCache2[key] = inf;
      }
      return inf;
    }
    var intlRelCache2 = {};
    function getCachedRTF2(locString, opts = {}) {
      const { base, ...cacheKeyOpts } = opts;
      const key = JSON.stringify([locString, cacheKeyOpts]);
      let inf = intlRelCache2[key];
      if (!inf) {
        inf = new Intl.RelativeTimeFormat(locString, opts);
        intlRelCache2[key] = inf;
      }
      return inf;
    }
    var sysLocaleCache2 = null;
    function systemLocale2() {
      if (sysLocaleCache2) {
        return sysLocaleCache2;
      } else {
        sysLocaleCache2 = new Intl.DateTimeFormat().resolvedOptions().locale;
        return sysLocaleCache2;
      }
    }
    function parseLocaleString2(localeStr) {
      const xIndex = localeStr.indexOf("-x-");
      if (xIndex !== -1) {
        localeStr = localeStr.substring(0, xIndex);
      }
      const uIndex = localeStr.indexOf("-u-");
      if (uIndex === -1) {
        return [localeStr];
      } else {
        let options;
        let selectedStr;
        try {
          options = getCachedDTF2(localeStr).resolvedOptions();
          selectedStr = localeStr;
        } catch (e) {
          const smaller = localeStr.substring(0, uIndex);
          options = getCachedDTF2(smaller).resolvedOptions();
          selectedStr = smaller;
        }
        const { numberingSystem, calendar } = options;
        return [selectedStr, numberingSystem, calendar];
      }
    }
    function intlConfigString2(localeStr, numberingSystem, outputCalendar) {
      if (outputCalendar || numberingSystem) {
        if (!localeStr.includes("-u-")) {
          localeStr += "-u";
        }
        if (outputCalendar) {
          localeStr += `-ca-${outputCalendar}`;
        }
        if (numberingSystem) {
          localeStr += `-nu-${numberingSystem}`;
        }
        return localeStr;
      } else {
        return localeStr;
      }
    }
    function mapMonths2(f2) {
      const ms = [];
      for (let i = 1; i <= 12; i++) {
        const dt = DateTime2.utc(2009, i, 1);
        ms.push(f2(dt));
      }
      return ms;
    }
    function mapWeekdays2(f2) {
      const ms = [];
      for (let i = 1; i <= 7; i++) {
        const dt = DateTime2.utc(2016, 11, 13 + i);
        ms.push(f2(dt));
      }
      return ms;
    }
    function listStuff2(loc, length, englishFn, intlFn) {
      const mode = loc.listingMode();
      if (mode === "error") {
        return null;
      } else if (mode === "en") {
        return englishFn(length);
      } else {
        return intlFn(length);
      }
    }
    function supportsFastNumbers2(loc) {
      if (loc.numberingSystem && loc.numberingSystem !== "latn") {
        return false;
      } else {
        return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
      }
    }
    var PolyNumberFormatter2 = class {
      constructor(intl, forceSimple, opts) {
        this.padTo = opts.padTo || 0;
        this.floor = opts.floor || false;
        const { padTo, floor, ...otherOpts } = opts;
        if (!forceSimple || Object.keys(otherOpts).length > 0) {
          const intlOpts = { useGrouping: false, ...opts };
          if (opts.padTo > 0)
            intlOpts.minimumIntegerDigits = opts.padTo;
          this.inf = getCachedINF2(intl, intlOpts);
        }
      }
      format(i) {
        if (this.inf) {
          const fixed = this.floor ? Math.floor(i) : i;
          return this.inf.format(fixed);
        } else {
          const fixed = this.floor ? Math.floor(i) : roundTo2(i, 3);
          return padStart3(fixed, this.padTo);
        }
      }
    };
    var PolyDateFormatter2 = class {
      constructor(dt, intl, opts) {
        this.opts = opts;
        this.originalZone = void 0;
        let z = void 0;
        if (this.opts.timeZone) {
          this.dt = dt;
        } else if (dt.zone.type === "fixed") {
          const gmtOffset = -1 * (dt.offset / 60);
          const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
          if (dt.offset !== 0 && IANAZone2.create(offsetZ).valid) {
            z = offsetZ;
            this.dt = dt;
          } else {
            z = "UTC";
            this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
            this.originalZone = dt.zone;
          }
        } else if (dt.zone.type === "system") {
          this.dt = dt;
        } else if (dt.zone.type === "iana") {
          this.dt = dt;
          z = dt.zone.name;
        } else {
          z = "UTC";
          this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
          this.originalZone = dt.zone;
        }
        const intlOpts = { ...this.opts };
        intlOpts.timeZone = intlOpts.timeZone || z;
        this.dtf = getCachedDTF2(intl, intlOpts);
      }
      format() {
        if (this.originalZone) {
          return this.formatToParts().map(({ value }) => value).join("");
        }
        return this.dtf.format(this.dt.toJSDate());
      }
      formatToParts() {
        const parts = this.dtf.formatToParts(this.dt.toJSDate());
        if (this.originalZone) {
          return parts.map((part) => {
            if (part.type === "timeZoneName") {
              const offsetName = this.originalZone.offsetName(this.dt.ts, {
                locale: this.dt.locale,
                format: this.opts.timeZoneName
              });
              return {
                ...part,
                value: offsetName
              };
            } else {
              return part;
            }
          });
        }
        return parts;
      }
      resolvedOptions() {
        return this.dtf.resolvedOptions();
      }
    };
    var PolyRelFormatter2 = class {
      constructor(intl, isEnglish, opts) {
        this.opts = { style: "long", ...opts };
        if (!isEnglish && hasRelative2()) {
          this.rtf = getCachedRTF2(intl, opts);
        }
      }
      format(count, unit) {
        if (this.rtf) {
          return this.rtf.format(count, unit);
        } else {
          return formatRelativeTime2(unit, count, this.opts.numeric, this.opts.style !== "long");
        }
      }
      formatToParts(count, unit) {
        if (this.rtf) {
          return this.rtf.formatToParts(count, unit);
        } else {
          return [];
        }
      }
    };
    var Locale2 = class {
      static fromOpts(opts) {
        return Locale2.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
      }
      static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
        const specifiedLocale = locale || Settings2.defaultLocale;
        const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale2());
        const numberingSystemR = numberingSystem || Settings2.defaultNumberingSystem;
        const outputCalendarR = outputCalendar || Settings2.defaultOutputCalendar;
        return new Locale2(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
      }
      static resetCache() {
        sysLocaleCache2 = null;
        intlDTCache2 = {};
        intlNumCache2 = {};
        intlRelCache2 = {};
      }
      static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
        return Locale2.create(locale, numberingSystem, outputCalendar);
      }
      constructor(locale, numbering, outputCalendar, specifiedLocale) {
        const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString2(locale);
        this.locale = parsedLocale;
        this.numberingSystem = numbering || parsedNumberingSystem || null;
        this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
        this.intl = intlConfigString2(this.locale, this.numberingSystem, this.outputCalendar);
        this.weekdaysCache = { format: {}, standalone: {} };
        this.monthsCache = { format: {}, standalone: {} };
        this.meridiemCache = null;
        this.eraCache = {};
        this.specifiedLocale = specifiedLocale;
        this.fastNumbersCached = null;
      }
      get fastNumbers() {
        if (this.fastNumbersCached == null) {
          this.fastNumbersCached = supportsFastNumbers2(this);
        }
        return this.fastNumbersCached;
      }
      listingMode() {
        const isActuallyEn = this.isEnglish();
        const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
        return isActuallyEn && hasNoWeirdness ? "en" : "intl";
      }
      clone(alts) {
        if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
          return this;
        } else {
          return Locale2.create(
            alts.locale || this.specifiedLocale,
            alts.numberingSystem || this.numberingSystem,
            alts.outputCalendar || this.outputCalendar,
            alts.defaultToEN || false
          );
        }
      }
      redefaultToEN(alts = {}) {
        return this.clone({ ...alts, defaultToEN: true });
      }
      redefaultToSystem(alts = {}) {
        return this.clone({ ...alts, defaultToEN: false });
      }
      months(length, format = false) {
        return listStuff2(this, length, months2, () => {
          const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
          if (!this.monthsCache[formatStr][length]) {
            this.monthsCache[formatStr][length] = mapMonths2((dt) => this.extract(dt, intl, "month"));
          }
          return this.monthsCache[formatStr][length];
        });
      }
      weekdays(length, format = false) {
        return listStuff2(this, length, weekdays2, () => {
          const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
          if (!this.weekdaysCache[formatStr][length]) {
            this.weekdaysCache[formatStr][length] = mapWeekdays2(
              (dt) => this.extract(dt, intl, "weekday")
            );
          }
          return this.weekdaysCache[formatStr][length];
        });
      }
      meridiems() {
        return listStuff2(
          this,
          void 0,
          () => meridiems2,
          () => {
            if (!this.meridiemCache) {
              const intl = { hour: "numeric", hourCycle: "h12" };
              this.meridiemCache = [DateTime2.utc(2016, 11, 13, 9), DateTime2.utc(2016, 11, 13, 19)].map(
                (dt) => this.extract(dt, intl, "dayperiod")
              );
            }
            return this.meridiemCache;
          }
        );
      }
      eras(length) {
        return listStuff2(this, length, eras2, () => {
          const intl = { era: length };
          if (!this.eraCache[length]) {
            this.eraCache[length] = [DateTime2.utc(-40, 1, 1), DateTime2.utc(2017, 1, 1)].map(
              (dt) => this.extract(dt, intl, "era")
            );
          }
          return this.eraCache[length];
        });
      }
      extract(dt, intlOpts, field) {
        const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
        return matching ? matching.value : null;
      }
      numberFormatter(opts = {}) {
        return new PolyNumberFormatter2(this.intl, opts.forceSimple || this.fastNumbers, opts);
      }
      dtFormatter(dt, intlOpts = {}) {
        return new PolyDateFormatter2(dt, this.intl, intlOpts);
      }
      relFormatter(opts = {}) {
        return new PolyRelFormatter2(this.intl, this.isEnglish(), opts);
      }
      listFormatter(opts = {}) {
        return getCachedLF2(this.intl, opts);
      }
      isEnglish() {
        return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
      }
      equals(other) {
        return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
      }
    };
    var singleton2 = null;
    var FixedOffsetZone2 = class extends Zone2 {
      /**
       * Get a singleton instance of UTC
       * @return {FixedOffsetZone}
       */
      static get utcInstance() {
        if (singleton2 === null) {
          singleton2 = new FixedOffsetZone2(0);
        }
        return singleton2;
      }
      /**
       * Get an instance with a specified offset
       * @param {number} offset - The offset in minutes
       * @return {FixedOffsetZone}
       */
      static instance(offset3) {
        return offset3 === 0 ? FixedOffsetZone2.utcInstance : new FixedOffsetZone2(offset3);
      }
      /**
       * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
       * @param {string} s - The offset string to parse
       * @example FixedOffsetZone.parseSpecifier("UTC+6")
       * @example FixedOffsetZone.parseSpecifier("UTC+06")
       * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
       * @return {FixedOffsetZone}
       */
      static parseSpecifier(s3) {
        if (s3) {
          const r = s3.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
          if (r) {
            return new FixedOffsetZone2(signedOffset2(r[1], r[2]));
          }
        }
        return null;
      }
      constructor(offset3) {
        super();
        this.fixed = offset3;
      }
      /** @override **/
      get type() {
        return "fixed";
      }
      /** @override **/
      get name() {
        return this.fixed === 0 ? "UTC" : `UTC${formatOffset2(this.fixed, "narrow")}`;
      }
      get ianaName() {
        if (this.fixed === 0) {
          return "Etc/UTC";
        } else {
          return `Etc/GMT${formatOffset2(-this.fixed, "narrow")}`;
        }
      }
      /** @override **/
      offsetName() {
        return this.name;
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset2(this.fixed, format);
      }
      /** @override **/
      get isUniversal() {
        return true;
      }
      /** @override **/
      offset() {
        return this.fixed;
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var InvalidZone2 = class extends Zone2 {
      constructor(zoneName) {
        super();
        this.zoneName = zoneName;
      }
      /** @override **/
      get type() {
        return "invalid";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName() {
        return null;
      }
      /** @override **/
      formatOffset() {
        return "";
      }
      /** @override **/
      offset() {
        return NaN;
      }
      /** @override **/
      equals() {
        return false;
      }
      /** @override **/
      get isValid() {
        return false;
      }
    };
    function normalizeZone2(input, defaultZone3) {
      if (isUndefined2(input) || input === null) {
        return defaultZone3;
      } else if (input instanceof Zone2) {
        return input;
      } else if (isString2(input)) {
        const lowered = input.toLowerCase();
        if (lowered === "default")
          return defaultZone3;
        else if (lowered === "local" || lowered === "system")
          return SystemZone2.instance;
        else if (lowered === "utc" || lowered === "gmt")
          return FixedOffsetZone2.utcInstance;
        else
          return FixedOffsetZone2.parseSpecifier(lowered) || IANAZone2.create(input);
      } else if (isNumber2(input)) {
        return FixedOffsetZone2.instance(input);
      } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
        return input;
      } else {
        return new InvalidZone2(input);
      }
    }
    var now2 = () => Date.now();
    var defaultZone2 = "system";
    var defaultLocale2 = null;
    var defaultNumberingSystem2 = null;
    var defaultOutputCalendar2 = null;
    var twoDigitCutoffYear2 = 60;
    var throwOnInvalid2;
    var Settings2 = class {
      /**
       * Get the callback for returning the current timestamp.
       * @type {function}
       */
      static get now() {
        return now2;
      }
      /**
       * Set the callback for returning the current timestamp.
       * The function should return a number, which will be interpreted as an Epoch millisecond count
       * @type {function}
       * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
       * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
       */
      static set now(n3) {
        now2 = n3;
      }
      /**
       * Set the default time zone to create DateTimes in. Does not affect existing instances.
       * Use the value "system" to reset this value to the system's time zone.
       * @type {string}
       */
      static set defaultZone(zone) {
        defaultZone2 = zone;
      }
      /**
       * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
       * The default value is the system's time zone (the one set on the machine that runs this code).
       * @type {Zone}
       */
      static get defaultZone() {
        return normalizeZone2(defaultZone2, SystemZone2.instance);
      }
      /**
       * Get the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultLocale() {
        return defaultLocale2;
      }
      /**
       * Set the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultLocale(locale) {
        defaultLocale2 = locale;
      }
      /**
       * Get the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultNumberingSystem() {
        return defaultNumberingSystem2;
      }
      /**
       * Set the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultNumberingSystem(numberingSystem) {
        defaultNumberingSystem2 = numberingSystem;
      }
      /**
       * Get the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultOutputCalendar() {
        return defaultOutputCalendar2;
      }
      /**
       * Set the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultOutputCalendar(outputCalendar) {
        defaultOutputCalendar2 = outputCalendar;
      }
      /**
       * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       */
      static get twoDigitCutoffYear() {
        return twoDigitCutoffYear2;
      }
      /**
       * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
       * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
       * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
       * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
       */
      static set twoDigitCutoffYear(cutoffYear) {
        twoDigitCutoffYear2 = cutoffYear % 100;
      }
      /**
       * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static get throwOnInvalid() {
        return throwOnInvalid2;
      }
      /**
       * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static set throwOnInvalid(t) {
        throwOnInvalid2 = t;
      }
      /**
       * Reset Luxon's global caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCaches() {
        Locale2.resetCache();
        IANAZone2.resetCache();
      }
    };
    function isUndefined2(o) {
      return typeof o === "undefined";
    }
    function isNumber2(o) {
      return typeof o === "number";
    }
    function isInteger3(o) {
      return typeof o === "number" && o % 1 === 0;
    }
    function isString2(o) {
      return typeof o === "string";
    }
    function isDate2(o) {
      return Object.prototype.toString.call(o) === "[object Date]";
    }
    function hasRelative2() {
      try {
        return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
      } catch (e) {
        return false;
      }
    }
    function maybeArray2(thing) {
      return Array.isArray(thing) ? thing : [thing];
    }
    function bestBy2(arr, by, compare) {
      if (arr.length === 0) {
        return void 0;
      }
      return arr.reduce((best, next) => {
        const pair = [by(next), next];
        if (!best) {
          return pair;
        } else if (compare(best[0], pair[0]) === best[0]) {
          return best;
        } else {
          return pair;
        }
      }, null)[1];
    }
    function pick2(obj, keys) {
      return keys.reduce((a, k) => {
        a[k] = obj[k];
        return a;
      }, {});
    }
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    function integerBetween2(thing, bottom, top) {
      return isInteger3(thing) && thing >= bottom && thing <= top;
    }
    function floorMod2(x, n3) {
      return x - n3 * Math.floor(x / n3);
    }
    function padStart3(input, n3 = 2) {
      const isNeg = input < 0;
      let padded;
      if (isNeg) {
        padded = "-" + ("" + -input).padStart(n3, "0");
      } else {
        padded = ("" + input).padStart(n3, "0");
      }
      return padded;
    }
    function parseInteger2(string) {
      if (isUndefined2(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseInt(string, 10);
      }
    }
    function parseFloating2(string) {
      if (isUndefined2(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseFloat(string);
      }
    }
    function parseMillis2(fraction) {
      if (isUndefined2(fraction) || fraction === null || fraction === "") {
        return void 0;
      } else {
        const f2 = parseFloat("0." + fraction) * 1e3;
        return Math.floor(f2);
      }
    }
    function roundTo2(number, digits, towardZero = false) {
      const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
      return rounder(number * factor) / factor;
    }
    function isLeapYear2(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function daysInYear2(year) {
      return isLeapYear2(year) ? 366 : 365;
    }
    function daysInMonth2(year, month) {
      const modMonth = floorMod2(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
      if (modMonth === 2) {
        return isLeapYear2(modYear) ? 29 : 28;
      } else {
        return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
      }
    }
    function objToLocalTS2(obj) {
      let d = Date.UTC(
        obj.year,
        obj.month - 1,
        obj.day,
        obj.hour,
        obj.minute,
        obj.second,
        obj.millisecond
      );
      if (obj.year < 100 && obj.year >= 0) {
        d = new Date(d);
        d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
      }
      return +d;
    }
    function weeksInWeekYear2(weekYear) {
      const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
      return p1 === 4 || p2 === 3 ? 53 : 52;
    }
    function untruncateYear2(year) {
      if (year > 99) {
        return year;
      } else
        return year > Settings2.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
    }
    function parseZoneInfo2(ts, offsetFormat, locale, timeZone = null) {
      const date = new Date(ts), intlOpts = {
        hourCycle: "h23",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      };
      if (timeZone) {
        intlOpts.timeZone = timeZone;
      }
      const modified = { timeZoneName: offsetFormat, ...intlOpts };
      const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
      return parsed ? parsed.value : null;
    }
    function signedOffset2(offHourStr, offMinuteStr) {
      let offHour = parseInt(offHourStr, 10);
      if (Number.isNaN(offHour)) {
        offHour = 0;
      }
      const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
      return offHour * 60 + offMinSigned;
    }
    function asNumber2(value) {
      const numericValue = Number(value);
      if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
        throw new InvalidArgumentError2(`Invalid unit value ${value}`);
      return numericValue;
    }
    function normalizeObject2(obj, normalizer) {
      const normalized = {};
      for (const u in obj) {
        if (hasOwnProperty2(obj, u)) {
          const v = obj[u];
          if (v === void 0 || v === null)
            continue;
          normalized[normalizer(u)] = asNumber2(v);
        }
      }
      return normalized;
    }
    function formatOffset2(offset3, format) {
      const hours = Math.trunc(Math.abs(offset3 / 60)), minutes = Math.trunc(Math.abs(offset3 % 60)), sign = offset3 >= 0 ? "+" : "-";
      switch (format) {
        case "short":
          return `${sign}${padStart3(hours, 2)}:${padStart3(minutes, 2)}`;
        case "narrow":
          return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
        case "techie":
          return `${sign}${padStart3(hours, 2)}${padStart3(minutes, 2)}`;
        default:
          throw new RangeError(`Value format ${format} is out of range for property format`);
      }
    }
    function timeObject2(obj) {
      return pick2(obj, ["hour", "minute", "second", "millisecond"]);
    }
    var monthsLong2 = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    var monthsShort2 = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var monthsNarrow2 = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
    function months2(length) {
      switch (length) {
        case "narrow":
          return [...monthsNarrow2];
        case "short":
          return [...monthsShort2];
        case "long":
          return [...monthsLong2];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
        case "2-digit":
          return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
        default:
          return null;
      }
    }
    var weekdaysLong2 = [
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
      "Sunday"
    ];
    var weekdaysShort2 = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    var weekdaysNarrow2 = ["M", "T", "W", "T", "F", "S", "S"];
    function weekdays2(length) {
      switch (length) {
        case "narrow":
          return [...weekdaysNarrow2];
        case "short":
          return [...weekdaysShort2];
        case "long":
          return [...weekdaysLong2];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7"];
        default:
          return null;
      }
    }
    var meridiems2 = ["AM", "PM"];
    var erasLong2 = ["Before Christ", "Anno Domini"];
    var erasShort2 = ["BC", "AD"];
    var erasNarrow2 = ["B", "A"];
    function eras2(length) {
      switch (length) {
        case "narrow":
          return [...erasNarrow2];
        case "short":
          return [...erasShort2];
        case "long":
          return [...erasLong2];
        default:
          return null;
      }
    }
    function meridiemForDateTime2(dt) {
      return meridiems2[dt.hour < 12 ? 0 : 1];
    }
    function weekdayForDateTime2(dt, length) {
      return weekdays2(length)[dt.weekday - 1];
    }
    function monthForDateTime2(dt, length) {
      return months2(length)[dt.month - 1];
    }
    function eraForDateTime2(dt, length) {
      return eras2(length)[dt.year < 0 ? 0 : 1];
    }
    function formatRelativeTime2(unit, count, numeric = "always", narrow = false) {
      const units = {
        years: ["year", "yr."],
        quarters: ["quarter", "qtr."],
        months: ["month", "mo."],
        weeks: ["week", "wk."],
        days: ["day", "day", "days"],
        hours: ["hour", "hr."],
        minutes: ["minute", "min."],
        seconds: ["second", "sec."]
      };
      const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
      if (numeric === "auto" && lastable) {
        const isDay = unit === "days";
        switch (count) {
          case 1:
            return isDay ? "tomorrow" : `next ${units[unit][0]}`;
          case -1:
            return isDay ? "yesterday" : `last ${units[unit][0]}`;
          case 0:
            return isDay ? "today" : `this ${units[unit][0]}`;
        }
      }
      const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
      return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
    }
    function stringifyTokens2(splits, tokenToString) {
      let s3 = "";
      for (const token of splits) {
        if (token.literal) {
          s3 += token.val;
        } else {
          s3 += tokenToString(token.val);
        }
      }
      return s3;
    }
    var macroTokenToFormatOpts2 = {
      D: DATE_SHORT2,
      DD: DATE_MED2,
      DDD: DATE_FULL2,
      DDDD: DATE_HUGE2,
      t: TIME_SIMPLE2,
      tt: TIME_WITH_SECONDS2,
      ttt: TIME_WITH_SHORT_OFFSET2,
      tttt: TIME_WITH_LONG_OFFSET2,
      T: TIME_24_SIMPLE2,
      TT: TIME_24_WITH_SECONDS2,
      TTT: TIME_24_WITH_SHORT_OFFSET2,
      TTTT: TIME_24_WITH_LONG_OFFSET2,
      f: DATETIME_SHORT2,
      ff: DATETIME_MED2,
      fff: DATETIME_FULL2,
      ffff: DATETIME_HUGE2,
      F: DATETIME_SHORT_WITH_SECONDS2,
      FF: DATETIME_MED_WITH_SECONDS2,
      FFF: DATETIME_FULL_WITH_SECONDS2,
      FFFF: DATETIME_HUGE_WITH_SECONDS2
    };
    var Formatter2 = class {
      static create(locale, opts = {}) {
        return new Formatter2(locale, opts);
      }
      static parseFormat(fmt) {
        let current = null, currentFull = "", bracketed = false;
        const splits = [];
        for (let i = 0; i < fmt.length; i++) {
          const c = fmt.charAt(i);
          if (c === "'") {
            if (currentFull.length > 0) {
              splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
            }
            current = null;
            currentFull = "";
            bracketed = !bracketed;
          } else if (bracketed) {
            currentFull += c;
          } else if (c === current) {
            currentFull += c;
          } else {
            if (currentFull.length > 0) {
              splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
            }
            currentFull = c;
            current = c;
          }
        }
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        return splits;
      }
      static macroTokenToFormatOpts(token) {
        return macroTokenToFormatOpts2[token];
      }
      constructor(locale, formatOpts) {
        this.opts = formatOpts;
        this.loc = locale;
        this.systemLoc = null;
      }
      formatWithSystemDefault(dt, opts) {
        if (this.systemLoc === null) {
          this.systemLoc = this.loc.redefaultToSystem();
        }
        const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
        return df.format();
      }
      dtFormatter(dt, opts = {}) {
        return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
      }
      formatDateTime(dt, opts) {
        return this.dtFormatter(dt, opts).format();
      }
      formatDateTimeParts(dt, opts) {
        return this.dtFormatter(dt, opts).formatToParts();
      }
      formatInterval(interval, opts) {
        const df = this.dtFormatter(interval.start, opts);
        return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
      }
      resolvedOptions(dt, opts) {
        return this.dtFormatter(dt, opts).resolvedOptions();
      }
      num(n3, p = 0) {
        if (this.opts.forceSimple) {
          return padStart3(n3, p);
        }
        const opts = { ...this.opts };
        if (p > 0) {
          opts.padTo = p;
        }
        return this.loc.numberFormatter(opts).format(n3);
      }
      formatDateTimeFromString(dt, fmt) {
        const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset3 = (opts) => {
          if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
            return "Z";
          }
          return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
        }, meridiem = () => knownEnglish ? meridiemForDateTime2(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime2(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime2(dt, length) : string(
          standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
          "weekday"
        ), maybeMacro = (token) => {
          const formatOpts = Formatter2.macroTokenToFormatOpts(token);
          if (formatOpts) {
            return this.formatWithSystemDefault(dt, formatOpts);
          } else {
            return token;
          }
        }, era = (length) => knownEnglish ? eraForDateTime2(dt, length) : string({ era: length }, "era"), tokenToString = (token) => {
          switch (token) {
            case "S":
              return this.num(dt.millisecond);
            case "u":
            case "SSS":
              return this.num(dt.millisecond, 3);
            case "s":
              return this.num(dt.second);
            case "ss":
              return this.num(dt.second, 2);
            case "uu":
              return this.num(Math.floor(dt.millisecond / 10), 2);
            case "uuu":
              return this.num(Math.floor(dt.millisecond / 100));
            case "m":
              return this.num(dt.minute);
            case "mm":
              return this.num(dt.minute, 2);
            case "h":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
            case "hh":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
            case "H":
              return this.num(dt.hour);
            case "HH":
              return this.num(dt.hour, 2);
            case "Z":
              return formatOffset3({ format: "narrow", allowZ: this.opts.allowZ });
            case "ZZ":
              return formatOffset3({ format: "short", allowZ: this.opts.allowZ });
            case "ZZZ":
              return formatOffset3({ format: "techie", allowZ: this.opts.allowZ });
            case "ZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
            case "ZZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
            case "z":
              return dt.zoneName;
            case "a":
              return meridiem();
            case "d":
              return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
            case "dd":
              return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
            case "c":
              return this.num(dt.weekday);
            case "ccc":
              return weekday("short", true);
            case "cccc":
              return weekday("long", true);
            case "ccccc":
              return weekday("narrow", true);
            case "E":
              return this.num(dt.weekday);
            case "EEE":
              return weekday("short", false);
            case "EEEE":
              return weekday("long", false);
            case "EEEEE":
              return weekday("narrow", false);
            case "L":
              return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
            case "LL":
              return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
            case "LLL":
              return month("short", true);
            case "LLLL":
              return month("long", true);
            case "LLLLL":
              return month("narrow", true);
            case "M":
              return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
            case "MM":
              return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
            case "MMM":
              return month("short", false);
            case "MMMM":
              return month("long", false);
            case "MMMMM":
              return month("narrow", false);
            case "y":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
            case "yy":
              return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
            case "yyyy":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
            case "yyyyyy":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
            case "G":
              return era("short");
            case "GG":
              return era("long");
            case "GGGGG":
              return era("narrow");
            case "kk":
              return this.num(dt.weekYear.toString().slice(-2), 2);
            case "kkkk":
              return this.num(dt.weekYear, 4);
            case "W":
              return this.num(dt.weekNumber);
            case "WW":
              return this.num(dt.weekNumber, 2);
            case "o":
              return this.num(dt.ordinal);
            case "ooo":
              return this.num(dt.ordinal, 3);
            case "q":
              return this.num(dt.quarter);
            case "qq":
              return this.num(dt.quarter, 2);
            case "X":
              return this.num(Math.floor(dt.ts / 1e3));
            case "x":
              return this.num(dt.ts);
            default:
              return maybeMacro(token);
          }
        };
        return stringifyTokens2(Formatter2.parseFormat(fmt), tokenToString);
      }
      formatDurationFromString(dur, fmt) {
        const tokenToField = (token) => {
          switch (token[0]) {
            case "S":
              return "millisecond";
            case "s":
              return "second";
            case "m":
              return "minute";
            case "h":
              return "hour";
            case "d":
              return "day";
            case "w":
              return "week";
            case "M":
              return "month";
            case "y":
              return "year";
            default:
              return null;
          }
        }, tokenToString = (lildur) => (token) => {
          const mapped = tokenToField(token);
          if (mapped) {
            return this.num(lildur.get(mapped), token.length);
          } else {
            return token;
          }
        }, tokens = Formatter2.parseFormat(fmt), realTokens = tokens.reduce(
          (found, { literal, val }) => literal ? found : found.concat(val),
          []
        ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
        return stringifyTokens2(tokens, tokenToString(collapsed));
      }
    };
    var Invalid2 = class {
      constructor(reason, explanation) {
        this.reason = reason;
        this.explanation = explanation;
      }
      toMessage() {
        if (this.explanation) {
          return `${this.reason}: ${this.explanation}`;
        } else {
          return this.reason;
        }
      }
    };
    var ianaRegex2 = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
    function combineRegexes2(...regexes) {
      const full = regexes.reduce((f2, r) => f2 + r.source, "");
      return RegExp(`^${full}$`);
    }
    function combineExtractors2(...extractors) {
      return (m) => extractors.reduce(
        ([mergedVals, mergedZone, cursor], ex) => {
          const [val, zone, next] = ex(m, cursor);
          return [{ ...mergedVals, ...val }, zone || mergedZone, next];
        },
        [{}, null, 1]
      ).slice(0, 2);
    }
    function parse2(s3, ...patterns) {
      if (s3 == null) {
        return [null, null];
      }
      for (const [regex, extractor] of patterns) {
        const m = regex.exec(s3);
        if (m) {
          return extractor(m);
        }
      }
      return [null, null];
    }
    function simpleParse2(...keys) {
      return (match3, cursor) => {
        const ret = {};
        let i;
        for (i = 0; i < keys.length; i++) {
          ret[keys[i]] = parseInteger2(match3[cursor + i]);
        }
        return [ret, null, cursor + i];
      };
    }
    var offsetRegex2 = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
    var isoExtendedZone2 = `(?:${offsetRegex2.source}?(?:\\[(${ianaRegex2.source})\\])?)?`;
    var isoTimeBaseRegex2 = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
    var isoTimeRegex2 = RegExp(`${isoTimeBaseRegex2.source}${isoExtendedZone2}`);
    var isoTimeExtensionRegex2 = RegExp(`(?:T${isoTimeRegex2.source})?`);
    var isoYmdRegex2 = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
    var isoWeekRegex2 = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
    var isoOrdinalRegex2 = /(\d{4})-?(\d{3})/;
    var extractISOWeekData2 = simpleParse2("weekYear", "weekNumber", "weekDay");
    var extractISOOrdinalData2 = simpleParse2("year", "ordinal");
    var sqlYmdRegex2 = /(\d{4})-(\d\d)-(\d\d)/;
    var sqlTimeRegex2 = RegExp(
      `${isoTimeBaseRegex2.source} ?(?:${offsetRegex2.source}|(${ianaRegex2.source}))?`
    );
    var sqlTimeExtensionRegex2 = RegExp(`(?: ${sqlTimeRegex2.source})?`);
    function int3(match3, pos, fallback) {
      const m = match3[pos];
      return isUndefined2(m) ? fallback : parseInteger2(m);
    }
    function extractISOYmd2(match3, cursor) {
      const item = {
        year: int3(match3, cursor),
        month: int3(match3, cursor + 1, 1),
        day: int3(match3, cursor + 2, 1)
      };
      return [item, null, cursor + 3];
    }
    function extractISOTime2(match3, cursor) {
      const item = {
        hours: int3(match3, cursor, 0),
        minutes: int3(match3, cursor + 1, 0),
        seconds: int3(match3, cursor + 2, 0),
        milliseconds: parseMillis2(match3[cursor + 3])
      };
      return [item, null, cursor + 4];
    }
    function extractISOOffset2(match3, cursor) {
      const local = !match3[cursor] && !match3[cursor + 1], fullOffset = signedOffset2(match3[cursor + 1], match3[cursor + 2]), zone = local ? null : FixedOffsetZone2.instance(fullOffset);
      return [{}, zone, cursor + 3];
    }
    function extractIANAZone2(match3, cursor) {
      const zone = match3[cursor] ? IANAZone2.create(match3[cursor]) : null;
      return [{}, zone, cursor + 1];
    }
    var isoTimeOnly2 = RegExp(`^T?${isoTimeBaseRegex2.source}$`);
    var isoDuration2 = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
    function extractISODuration2(match3) {
      const [s3, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match3;
      const hasNegativePrefix = s3[0] === "-";
      const negativeSeconds = secondStr && secondStr[0] === "-";
      const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
      return [
        {
          years: maybeNegate(parseFloating2(yearStr)),
          months: maybeNegate(parseFloating2(monthStr)),
          weeks: maybeNegate(parseFloating2(weekStr)),
          days: maybeNegate(parseFloating2(dayStr)),
          hours: maybeNegate(parseFloating2(hourStr)),
          minutes: maybeNegate(parseFloating2(minuteStr)),
          seconds: maybeNegate(parseFloating2(secondStr), secondStr === "-0"),
          milliseconds: maybeNegate(parseMillis2(millisecondsStr), negativeSeconds)
        }
      ];
    }
    var obsOffsets2 = {
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function fromStrings2(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      const result = {
        year: yearStr.length === 2 ? untruncateYear2(parseInteger2(yearStr)) : parseInteger2(yearStr),
        month: monthsShort2.indexOf(monthStr) + 1,
        day: parseInteger2(dayStr),
        hour: parseInteger2(hourStr),
        minute: parseInteger2(minuteStr)
      };
      if (secondStr)
        result.second = parseInteger2(secondStr);
      if (weekdayStr) {
        result.weekday = weekdayStr.length > 3 ? weekdaysLong2.indexOf(weekdayStr) + 1 : weekdaysShort2.indexOf(weekdayStr) + 1;
      }
      return result;
    }
    var rfc28222 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
    function extractRFC28222(match3) {
      const [
        ,
        weekdayStr,
        dayStr,
        monthStr,
        yearStr,
        hourStr,
        minuteStr,
        secondStr,
        obsOffset,
        milOffset,
        offHourStr,
        offMinuteStr
      ] = match3, result = fromStrings2(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      let offset3;
      if (obsOffset) {
        offset3 = obsOffsets2[obsOffset];
      } else if (milOffset) {
        offset3 = 0;
      } else {
        offset3 = signedOffset2(offHourStr, offMinuteStr);
      }
      return [result, new FixedOffsetZone2(offset3)];
    }
    function preprocessRFC28222(s3) {
      return s3.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
    }
    var rfc11232 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
    var rfc8502 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
    var ascii2 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
    function extractRFC1123Or8502(match3) {
      const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match3, result = fromStrings2(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone2.utcInstance];
    }
    function extractASCII2(match3) {
      const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match3, result = fromStrings2(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone2.utcInstance];
    }
    var isoYmdWithTimeExtensionRegex2 = combineRegexes2(isoYmdRegex2, isoTimeExtensionRegex2);
    var isoWeekWithTimeExtensionRegex2 = combineRegexes2(isoWeekRegex2, isoTimeExtensionRegex2);
    var isoOrdinalWithTimeExtensionRegex2 = combineRegexes2(isoOrdinalRegex2, isoTimeExtensionRegex2);
    var isoTimeCombinedRegex2 = combineRegexes2(isoTimeRegex2);
    var extractISOYmdTimeAndOffset2 = combineExtractors2(
      extractISOYmd2,
      extractISOTime2,
      extractISOOffset2,
      extractIANAZone2
    );
    var extractISOWeekTimeAndOffset2 = combineExtractors2(
      extractISOWeekData2,
      extractISOTime2,
      extractISOOffset2,
      extractIANAZone2
    );
    var extractISOOrdinalDateAndTime2 = combineExtractors2(
      extractISOOrdinalData2,
      extractISOTime2,
      extractISOOffset2,
      extractIANAZone2
    );
    var extractISOTimeAndOffset2 = combineExtractors2(
      extractISOTime2,
      extractISOOffset2,
      extractIANAZone2
    );
    function parseISODate2(s3) {
      return parse2(
        s3,
        [isoYmdWithTimeExtensionRegex2, extractISOYmdTimeAndOffset2],
        [isoWeekWithTimeExtensionRegex2, extractISOWeekTimeAndOffset2],
        [isoOrdinalWithTimeExtensionRegex2, extractISOOrdinalDateAndTime2],
        [isoTimeCombinedRegex2, extractISOTimeAndOffset2]
      );
    }
    function parseRFC2822Date2(s3) {
      return parse2(preprocessRFC28222(s3), [rfc28222, extractRFC28222]);
    }
    function parseHTTPDate2(s3) {
      return parse2(
        s3,
        [rfc11232, extractRFC1123Or8502],
        [rfc8502, extractRFC1123Or8502],
        [ascii2, extractASCII2]
      );
    }
    function parseISODuration2(s3) {
      return parse2(s3, [isoDuration2, extractISODuration2]);
    }
    var extractISOTimeOnly2 = combineExtractors2(extractISOTime2);
    function parseISOTimeOnly2(s3) {
      return parse2(s3, [isoTimeOnly2, extractISOTimeOnly2]);
    }
    var sqlYmdWithTimeExtensionRegex2 = combineRegexes2(sqlYmdRegex2, sqlTimeExtensionRegex2);
    var sqlTimeCombinedRegex2 = combineRegexes2(sqlTimeRegex2);
    var extractISOTimeOffsetAndIANAZone2 = combineExtractors2(
      extractISOTime2,
      extractISOOffset2,
      extractIANAZone2
    );
    function parseSQL2(s3) {
      return parse2(
        s3,
        [sqlYmdWithTimeExtensionRegex2, extractISOYmdTimeAndOffset2],
        [sqlTimeCombinedRegex2, extractISOTimeOffsetAndIANAZone2]
      );
    }
    var INVALID$22 = "Invalid Duration";
    var lowOrderMatrix2 = {
      weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1e3
      },
      days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1e3
      },
      hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
      minutes: { seconds: 60, milliseconds: 60 * 1e3 },
      seconds: { milliseconds: 1e3 }
    };
    var casualMatrix2 = {
      years: {
        quarters: 4,
        months: 12,
        weeks: 52,
        days: 365,
        hours: 365 * 24,
        minutes: 365 * 24 * 60,
        seconds: 365 * 24 * 60 * 60,
        milliseconds: 365 * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: 13,
        days: 91,
        hours: 91 * 24,
        minutes: 91 * 24 * 60,
        seconds: 91 * 24 * 60 * 60,
        milliseconds: 91 * 24 * 60 * 60 * 1e3
      },
      months: {
        weeks: 4,
        days: 30,
        hours: 30 * 24,
        minutes: 30 * 24 * 60,
        seconds: 30 * 24 * 60 * 60,
        milliseconds: 30 * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix2
    };
    var daysInYearAccurate2 = 146097 / 400;
    var daysInMonthAccurate2 = 146097 / 4800;
    var accurateMatrix2 = {
      years: {
        quarters: 4,
        months: 12,
        weeks: daysInYearAccurate2 / 7,
        days: daysInYearAccurate2,
        hours: daysInYearAccurate2 * 24,
        minutes: daysInYearAccurate2 * 24 * 60,
        seconds: daysInYearAccurate2 * 24 * 60 * 60,
        milliseconds: daysInYearAccurate2 * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: daysInYearAccurate2 / 28,
        days: daysInYearAccurate2 / 4,
        hours: daysInYearAccurate2 * 24 / 4,
        minutes: daysInYearAccurate2 * 24 * 60 / 4,
        seconds: daysInYearAccurate2 * 24 * 60 * 60 / 4,
        milliseconds: daysInYearAccurate2 * 24 * 60 * 60 * 1e3 / 4
      },
      months: {
        weeks: daysInMonthAccurate2 / 7,
        days: daysInMonthAccurate2,
        hours: daysInMonthAccurate2 * 24,
        minutes: daysInMonthAccurate2 * 24 * 60,
        seconds: daysInMonthAccurate2 * 24 * 60 * 60,
        milliseconds: daysInMonthAccurate2 * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix2
    };
    var orderedUnits$12 = [
      "years",
      "quarters",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ];
    var reverseUnits2 = orderedUnits$12.slice(0).reverse();
    function clone$12(dur, alts, clear = false) {
      const conf = {
        values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
        loc: dur.loc.clone(alts.loc),
        conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
        matrix: alts.matrix || dur.matrix
      };
      return new Duration2(conf);
    }
    function durationToMillis2(matrix, vals) {
      var _a2;
      let sum = (_a2 = vals.milliseconds) != null ? _a2 : 0;
      for (const unit of reverseUnits2.slice(1)) {
        if (vals[unit]) {
          sum += vals[unit] * matrix[unit]["milliseconds"];
        }
      }
      return sum;
    }
    function normalizeValues2(matrix, vals) {
      const factor = durationToMillis2(matrix, vals) < 0 ? -1 : 1;
      orderedUnits$12.reduceRight((previous, current) => {
        if (!isUndefined2(vals[current])) {
          if (previous) {
            const previousVal = vals[previous] * factor;
            const conv = matrix[current][previous];
            const rollUp = Math.floor(previousVal / conv);
            vals[current] += rollUp * factor;
            vals[previous] -= rollUp * conv * factor;
          }
          return current;
        } else {
          return previous;
        }
      }, null);
      orderedUnits$12.reduce((previous, current) => {
        if (!isUndefined2(vals[current])) {
          if (previous) {
            const fraction = vals[previous] % 1;
            vals[previous] -= fraction;
            vals[current] += fraction * matrix[previous][current];
          }
          return current;
        } else {
          return previous;
        }
      }, null);
    }
    function removeZeroes2(vals) {
      const newVals = {};
      for (const [key, value] of Object.entries(vals)) {
        if (value !== 0) {
          newVals[key] = value;
        }
      }
      return newVals;
    }
    var Duration2 = class {
      /**
       * @private
       */
      constructor(config) {
        const accurate = config.conversionAccuracy === "longterm" || false;
        let matrix = accurate ? accurateMatrix2 : casualMatrix2;
        if (config.matrix) {
          matrix = config.matrix;
        }
        this.values = config.values;
        this.loc = config.loc || Locale2.create();
        this.conversionAccuracy = accurate ? "longterm" : "casual";
        this.invalid = config.invalid || null;
        this.matrix = matrix;
        this.isLuxonDuration = true;
      }
      /**
       * Create Duration from a number of milliseconds.
       * @param {number} count of milliseconds
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      static fromMillis(count, opts) {
        return Duration2.fromObject({ milliseconds: count }, opts);
      }
      /**
       * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
       * If this object is empty then a zero milliseconds duration is returned.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.years
       * @param {number} obj.quarters
       * @param {number} obj.months
       * @param {number} obj.weeks
       * @param {number} obj.days
       * @param {number} obj.hours
       * @param {number} obj.minutes
       * @param {number} obj.seconds
       * @param {number} obj.milliseconds
       * @param {Object} [opts=[]] - options for creating this Duration
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the custom conversion system to use
       * @return {Duration}
       */
      static fromObject(obj, opts = {}) {
        if (obj == null || typeof obj !== "object") {
          throw new InvalidArgumentError2(
            `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
          );
        }
        return new Duration2({
          values: normalizeObject2(obj, Duration2.normalizeUnit),
          loc: Locale2.fromObject(opts),
          conversionAccuracy: opts.conversionAccuracy,
          matrix: opts.matrix
        });
      }
      /**
       * Create a Duration from DurationLike.
       *
       * @param {Object | number | Duration} durationLike
       * One of:
       * - object with keys like 'years' and 'hours'.
       * - number representing milliseconds
       * - Duration instance
       * @return {Duration}
       */
      static fromDurationLike(durationLike) {
        if (isNumber2(durationLike)) {
          return Duration2.fromMillis(durationLike);
        } else if (Duration2.isDuration(durationLike)) {
          return durationLike;
        } else if (typeof durationLike === "object") {
          return Duration2.fromObject(durationLike);
        } else {
          throw new InvalidArgumentError2(
            `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
          );
        }
      }
      /**
       * Create a Duration from an ISO 8601 duration string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the preset conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
       * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
       * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
       * @return {Duration}
       */
      static fromISO(text, opts) {
        const [parsed] = parseISODuration2(text);
        if (parsed) {
          return Duration2.fromObject(parsed, opts);
        } else {
          return Duration2.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create a Duration from an ISO 8601 time string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
       * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @return {Duration}
       */
      static fromISOTime(text, opts) {
        const [parsed] = parseISOTimeOnly2(text);
        if (parsed) {
          return Duration2.fromObject(parsed, opts);
        } else {
          return Duration2.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create an invalid Duration.
       * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Duration}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError2("need to specify a reason the Duration is invalid");
        }
        const invalid = reason instanceof Invalid2 ? reason : new Invalid2(reason, explanation);
        if (Settings2.throwOnInvalid) {
          throw new InvalidDurationError2(invalid);
        } else {
          return new Duration2({ invalid });
        }
      }
      /**
       * @private
       */
      static normalizeUnit(unit) {
        const normalized = {
          year: "years",
          years: "years",
          quarter: "quarters",
          quarters: "quarters",
          month: "months",
          months: "months",
          week: "weeks",
          weeks: "weeks",
          day: "days",
          days: "days",
          hour: "hours",
          hours: "hours",
          minute: "minutes",
          minutes: "minutes",
          second: "seconds",
          seconds: "seconds",
          millisecond: "milliseconds",
          milliseconds: "milliseconds"
        }[unit ? unit.toLowerCase() : unit];
        if (!normalized)
          throw new InvalidUnitError2(unit);
        return normalized;
      }
      /**
       * Check if an object is a Duration. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDuration(o) {
        return o && o.isLuxonDuration || false;
      }
      /**
       * Get  the locale of a Duration, such 'en-GB'
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
       * * `S` for milliseconds
       * * `s` for seconds
       * * `m` for minutes
       * * `h` for hours
       * * `d` for days
       * * `w` for weeks
       * * `M` for months
       * * `y` for years
       * Notes:
       * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
       * * Tokens can be escaped by wrapping with single quotes.
       * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
       * @param {string} fmt - the format string
       * @param {Object} opts - options
       * @param {boolean} [opts.floor=true] - floor numerical values
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        const fmtOpts = {
          ...opts,
          floor: opts.round !== false && opts.floor !== false
        };
        return this.isValid ? Formatter2.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$22;
      }
      /**
       * Returns a string representation of a Duration with all units included.
       * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
       * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
       * @example
       * ```js
       * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
       * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
       * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
       * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
       * ```
       */
      toHuman(opts = {}) {
        if (!this.isValid)
          return INVALID$22;
        const l3 = orderedUnits$12.map((unit) => {
          const val = this.values[unit];
          if (isUndefined2(val)) {
            return null;
          }
          return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
        }).filter((n3) => n3);
        return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l3);
      }
      /**
       * Returns a JavaScript object with this Duration's values.
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
       * @return {Object}
       */
      toObject() {
        if (!this.isValid)
          return {};
        return { ...this.values };
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
       * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
       * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
       * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
       * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
       * @return {string}
       */
      toISO() {
        if (!this.isValid)
          return null;
        let s3 = "P";
        if (this.years !== 0)
          s3 += this.years + "Y";
        if (this.months !== 0 || this.quarters !== 0)
          s3 += this.months + this.quarters * 3 + "M";
        if (this.weeks !== 0)
          s3 += this.weeks + "W";
        if (this.days !== 0)
          s3 += this.days + "D";
        if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
          s3 += "T";
        if (this.hours !== 0)
          s3 += this.hours + "H";
        if (this.minutes !== 0)
          s3 += this.minutes + "M";
        if (this.seconds !== 0 || this.milliseconds !== 0)
          s3 += roundTo2(this.seconds + this.milliseconds / 1e3, 3) + "S";
        if (s3 === "P")
          s3 += "T0S";
        return s3;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
       * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
       * @return {string}
       */
      toISOTime(opts = {}) {
        if (!this.isValid)
          return null;
        const millis = this.toMillis();
        if (millis < 0 || millis >= 864e5)
          return null;
        opts = {
          suppressMilliseconds: false,
          suppressSeconds: false,
          includePrefix: false,
          format: "extended",
          ...opts,
          includeOffset: false
        };
        const dateTime = DateTime2.fromMillis(millis, { zone: "UTC" });
        return dateTime.toISOTime(opts);
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
       * @return {string}
       */
      toString() {
        return this.toISO();
      }
      /**
       * Returns an milliseconds value of this Duration.
       * @return {number}
       */
      toMillis() {
        if (!this.isValid)
          return NaN;
        return durationToMillis2(this.matrix, this.values);
      }
      /**
       * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration2.fromDurationLike(duration), result = {};
        for (const k of orderedUnits$12) {
          if (hasOwnProperty2(dur.values, k) || hasOwnProperty2(this.values, k)) {
            result[k] = dur.get(k) + this.get(k);
          }
        }
        return clone$12(this, { values: result }, true);
      }
      /**
       * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration2.fromDurationLike(duration);
        return this.plus(dur.negate());
      }
      /**
       * Scale this Duration by the specified amount. Return a newly-constructed Duration.
       * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
       * @return {Duration}
       */
      mapUnits(fn) {
        if (!this.isValid)
          return this;
        const result = {};
        for (const k of Object.keys(this.values)) {
          result[k] = asNumber2(fn(this.values[k], k));
        }
        return clone$12(this, { values: result }, true);
      }
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
       * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
       * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
       * @return {number}
       */
      get(unit) {
        return this[Duration2.normalizeUnit(unit)];
      }
      /**
       * "Set" the values of specified units. Return a newly-constructed Duration.
       * @param {Object} values - a mapping of units to numbers
       * @example dur.set({ years: 2017 })
       * @example dur.set({ hours: 8, minutes: 30 })
       * @return {Duration}
       */
      set(values) {
        if (!this.isValid)
          return this;
        const mixed = { ...this.values, ...normalizeObject2(values, Duration2.normalizeUnit) };
        return clone$12(this, { values: mixed });
      }
      /**
       * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
       * @example dur.reconfigure({ locale: 'en-GB' })
       * @return {Duration}
       */
      reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem });
        const opts = { loc, matrix, conversionAccuracy };
        return clone$12(this, opts);
      }
      /**
       * Return the length of the duration in the specified unit.
       * @param {string} unit - a unit such as 'minutes' or 'days'
       * @example Duration.fromObject({years: 1}).as('days') //=> 365
       * @example Duration.fromObject({years: 1}).as('months') //=> 12
       * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
       * @return {number}
       */
      as(unit) {
        return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
      }
      /**
       * Reduce this Duration to its canonical representation in its current units.
       * Assuming the overall value of the Duration is positive, this means:
       * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
       * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
       *   the overall value would be negative, see second example)
       * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
       *
       * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
       * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
       * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
       * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
       * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
       * @return {Duration}
       */
      normalize() {
        if (!this.isValid)
          return this;
        const vals = this.toObject();
        normalizeValues2(this.matrix, vals);
        return clone$12(this, { values: vals }, true);
      }
      /**
       * Rescale units to its largest representation
       * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
       * @return {Duration}
       */
      rescale() {
        if (!this.isValid)
          return this;
        const vals = removeZeroes2(this.normalize().shiftToAll().toObject());
        return clone$12(this, { values: vals }, true);
      }
      /**
       * Convert this Duration into its representation in a different set of units.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
       * @return {Duration}
       */
      shiftTo(...units) {
        if (!this.isValid)
          return this;
        if (units.length === 0) {
          return this;
        }
        units = units.map((u) => Duration2.normalizeUnit(u));
        const built = {}, accumulated = {}, vals = this.toObject();
        let lastUnit;
        for (const k of orderedUnits$12) {
          if (units.indexOf(k) >= 0) {
            lastUnit = k;
            let own = 0;
            for (const ak in accumulated) {
              own += this.matrix[ak][k] * accumulated[ak];
              accumulated[ak] = 0;
            }
            if (isNumber2(vals[k])) {
              own += vals[k];
            }
            const i = Math.trunc(own);
            built[k] = i;
            accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
          } else if (isNumber2(vals[k])) {
            accumulated[k] = vals[k];
          }
        }
        for (const key in accumulated) {
          if (accumulated[key] !== 0) {
            built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
          }
        }
        normalizeValues2(this.matrix, built);
        return clone$12(this, { values: built }, true);
      }
      /**
       * Shift this Duration to all available units.
       * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
       * @return {Duration}
       */
      shiftToAll() {
        if (!this.isValid)
          return this;
        return this.shiftTo(
          "years",
          "months",
          "weeks",
          "days",
          "hours",
          "minutes",
          "seconds",
          "milliseconds"
        );
      }
      /**
       * Return the negative of this Duration.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
       * @return {Duration}
       */
      negate() {
        if (!this.isValid)
          return this;
        const negated = {};
        for (const k of Object.keys(this.values)) {
          negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
        }
        return clone$12(this, { values: negated }, true);
      }
      /**
       * Get the years.
       * @type {number}
       */
      get years() {
        return this.isValid ? this.values.years || 0 : NaN;
      }
      /**
       * Get the quarters.
       * @type {number}
       */
      get quarters() {
        return this.isValid ? this.values.quarters || 0 : NaN;
      }
      /**
       * Get the months.
       * @type {number}
       */
      get months() {
        return this.isValid ? this.values.months || 0 : NaN;
      }
      /**
       * Get the weeks
       * @type {number}
       */
      get weeks() {
        return this.isValid ? this.values.weeks || 0 : NaN;
      }
      /**
       * Get the days.
       * @type {number}
       */
      get days() {
        return this.isValid ? this.values.days || 0 : NaN;
      }
      /**
       * Get the hours.
       * @type {number}
       */
      get hours() {
        return this.isValid ? this.values.hours || 0 : NaN;
      }
      /**
       * Get the minutes.
       * @type {number}
       */
      get minutes() {
        return this.isValid ? this.values.minutes || 0 : NaN;
      }
      /**
       * Get the seconds.
       * @return {number}
       */
      get seconds() {
        return this.isValid ? this.values.seconds || 0 : NaN;
      }
      /**
       * Get the milliseconds.
       * @return {number}
       */
      get milliseconds() {
        return this.isValid ? this.values.milliseconds || 0 : NaN;
      }
      /**
       * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
       * on invalid DateTimes or Intervals.
       * @return {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this Duration became invalid, or null if the Duration is valid
       * @return {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Equality check
       * Two Durations are equal iff they have the same units and the same values for each unit.
       * @param {Duration} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        if (!this.loc.equals(other.loc)) {
          return false;
        }
        function eq(v1, v2) {
          if (v1 === void 0 || v1 === 0)
            return v2 === void 0 || v2 === 0;
          return v1 === v2;
        }
        for (const u of orderedUnits$12) {
          if (!eq(this.values[u], other.values[u])) {
            return false;
          }
        }
        return true;
      }
    };
    var INVALID$12 = "Invalid Interval";
    function validateStartEnd2(start, end) {
      if (!start || !start.isValid) {
        return Interval2.invalid("missing or invalid start");
      } else if (!end || !end.isValid) {
        return Interval2.invalid("missing or invalid end");
      } else if (end < start) {
        return Interval2.invalid(
          "end before start",
          `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
        );
      } else {
        return null;
      }
    }
    var Interval2 = class {
      /**
       * @private
       */
      constructor(config) {
        this.s = config.start;
        this.e = config.end;
        this.invalid = config.invalid || null;
        this.isLuxonInterval = true;
      }
      /**
       * Create an invalid Interval.
       * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Interval}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError2("need to specify a reason the Interval is invalid");
        }
        const invalid = reason instanceof Invalid2 ? reason : new Invalid2(reason, explanation);
        if (Settings2.throwOnInvalid) {
          throw new InvalidIntervalError2(invalid);
        } else {
          return new Interval2({ invalid });
        }
      }
      /**
       * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
       * @param {DateTime|Date|Object} start
       * @param {DateTime|Date|Object} end
       * @return {Interval}
       */
      static fromDateTimes(start, end) {
        const builtStart = friendlyDateTime2(start), builtEnd = friendlyDateTime2(end);
        const validateError = validateStartEnd2(builtStart, builtEnd);
        if (validateError == null) {
          return new Interval2({
            start: builtStart,
            end: builtEnd
          });
        } else {
          return validateError;
        }
      }
      /**
       * Create an Interval from a start DateTime and a Duration to extend to.
       * @param {DateTime|Date|Object} start
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static after(start, duration) {
        const dur = Duration2.fromDurationLike(duration), dt = friendlyDateTime2(start);
        return Interval2.fromDateTimes(dt, dt.plus(dur));
      }
      /**
       * Create an Interval from an end DateTime and a Duration to extend backwards to.
       * @param {DateTime|Date|Object} end
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static before(end, duration) {
        const dur = Duration2.fromDurationLike(duration), dt = friendlyDateTime2(end);
        return Interval2.fromDateTimes(dt.minus(dur), dt);
      }
      /**
       * Create an Interval from an ISO 8601 string.
       * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
       * @param {string} text - the ISO string to parse
       * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {Interval}
       */
      static fromISO(text, opts) {
        const [s3, e] = (text || "").split("/", 2);
        if (s3 && e) {
          let start, startIsValid;
          try {
            start = DateTime2.fromISO(s3, opts);
            startIsValid = start.isValid;
          } catch (e2) {
            startIsValid = false;
          }
          let end, endIsValid;
          try {
            end = DateTime2.fromISO(e, opts);
            endIsValid = end.isValid;
          } catch (e2) {
            endIsValid = false;
          }
          if (startIsValid && endIsValid) {
            return Interval2.fromDateTimes(start, end);
          }
          if (startIsValid) {
            const dur = Duration2.fromISO(e, opts);
            if (dur.isValid) {
              return Interval2.after(start, dur);
            }
          } else if (endIsValid) {
            const dur = Duration2.fromISO(s3, opts);
            if (dur.isValid) {
              return Interval2.before(end, dur);
            }
          }
        }
        return Interval2.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
      /**
       * Check if an object is an Interval. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isInterval(o) {
        return o && o.isLuxonInterval || false;
      }
      /**
       * Returns the start of the Interval
       * @type {DateTime}
       */
      get start() {
        return this.isValid ? this.s : null;
      }
      /**
       * Returns the end of the Interval
       * @type {DateTime}
       */
      get end() {
        return this.isValid ? this.e : null;
      }
      /**
       * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
       * @type {boolean}
       */
      get isValid() {
        return this.invalidReason === null;
      }
      /**
       * Returns an error code if this Interval is invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Returns the length of the Interval in the specified unit.
       * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
       * @return {number}
       */
      length(unit = "milliseconds") {
        return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
      }
      /**
       * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
       * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
       * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
       * @param {string} [unit='milliseconds'] - the unit of time to count.
       * @return {number}
       */
      count(unit = "milliseconds") {
        if (!this.isValid)
          return NaN;
        const start = this.start.startOf(unit), end = this.end.startOf(unit);
        return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
      }
      /**
       * Returns whether this Interval's start and end are both in the same unit of time
       * @param {string} unit - the unit of time to check sameness on
       * @return {boolean}
       */
      hasSame(unit) {
        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
      }
      /**
       * Return whether this Interval has the same start and end DateTimes.
       * @return {boolean}
       */
      isEmpty() {
        return this.s.valueOf() === this.e.valueOf();
      }
      /**
       * Return whether this Interval's start is after the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isAfter(dateTime) {
        if (!this.isValid)
          return false;
        return this.s > dateTime;
      }
      /**
       * Return whether this Interval's end is before the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isBefore(dateTime) {
        if (!this.isValid)
          return false;
        return this.e <= dateTime;
      }
      /**
       * Return whether this Interval contains the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      contains(dateTime) {
        if (!this.isValid)
          return false;
        return this.s <= dateTime && this.e > dateTime;
      }
      /**
       * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
       * @param {Object} values - the values to set
       * @param {DateTime} values.start - the starting DateTime
       * @param {DateTime} values.end - the ending DateTime
       * @return {Interval}
       */
      set({ start, end } = {}) {
        if (!this.isValid)
          return this;
        return Interval2.fromDateTimes(start || this.s, end || this.e);
      }
      /**
       * Split this Interval at each of the specified DateTimes
       * @param {...DateTime} dateTimes - the unit of time to count.
       * @return {Array}
       */
      splitAt(...dateTimes) {
        if (!this.isValid)
          return [];
        const sorted = dateTimes.map(friendlyDateTime2).filter((d) => this.contains(d)).sort(), results = [];
        let { s: s3 } = this, i = 0;
        while (s3 < this.e) {
          const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
          results.push(Interval2.fromDateTimes(s3, next));
          s3 = next;
          i += 1;
        }
        return results;
      }
      /**
       * Split this Interval into smaller Intervals, each of the specified length.
       * Left over time is grouped into a smaller interval
       * @param {Duration|Object|number} duration - The length of each resulting interval.
       * @return {Array}
       */
      splitBy(duration) {
        const dur = Duration2.fromDurationLike(duration);
        if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
          return [];
        }
        let { s: s3 } = this, idx = 1, next;
        const results = [];
        while (s3 < this.e) {
          const added = this.start.plus(dur.mapUnits((x) => x * idx));
          next = +added > +this.e ? this.e : added;
          results.push(Interval2.fromDateTimes(s3, next));
          s3 = next;
          idx += 1;
        }
        return results;
      }
      /**
       * Split this Interval into the specified number of smaller intervals.
       * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
       * @return {Array}
       */
      divideEqually(numberOfParts) {
        if (!this.isValid)
          return [];
        return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
      }
      /**
       * Return whether this Interval overlaps with the specified Interval
       * @param {Interval} other
       * @return {boolean}
       */
      overlaps(other) {
        return this.e > other.s && this.s < other.e;
      }
      /**
       * Return whether this Interval's end is adjacent to the specified Interval's start.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsStart(other) {
        if (!this.isValid)
          return false;
        return +this.e === +other.s;
      }
      /**
       * Return whether this Interval's start is adjacent to the specified Interval's end.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsEnd(other) {
        if (!this.isValid)
          return false;
        return +other.e === +this.s;
      }
      /**
       * Return whether this Interval engulfs the start and end of the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      engulfs(other) {
        if (!this.isValid)
          return false;
        return this.s <= other.s && this.e >= other.e;
      }
      /**
       * Return whether this Interval has the same start and end as the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        return this.s.equals(other.s) && this.e.equals(other.e);
      }
      /**
       * Return an Interval representing the intersection of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
       * Returns null if the intersection is empty, meaning, the intervals don't intersect.
       * @param {Interval} other
       * @return {Interval}
       */
      intersection(other) {
        if (!this.isValid)
          return this;
        const s3 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
        if (s3 >= e) {
          return null;
        } else {
          return Interval2.fromDateTimes(s3, e);
        }
      }
      /**
       * Return an Interval representing the union of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
       * @param {Interval} other
       * @return {Interval}
       */
      union(other) {
        if (!this.isValid)
          return this;
        const s3 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
        return Interval2.fromDateTimes(s3, e);
      }
      /**
       * Merge an array of Intervals into a equivalent minimal set of Intervals.
       * Combines overlapping and adjacent Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static merge(intervals) {
        const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(
          ([sofar, current], item) => {
            if (!current) {
              return [sofar, item];
            } else if (current.overlaps(item) || current.abutsStart(item)) {
              return [sofar, current.union(item)];
            } else {
              return [sofar.concat([current]), item];
            }
          },
          [[], null]
        );
        if (final) {
          found.push(final);
        }
        return found;
      }
      /**
       * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static xor(intervals) {
        let start = null, currentCount = 0;
        const results = [], ends = intervals.map((i) => [
          { time: i.s, type: "s" },
          { time: i.e, type: "e" }
        ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
        for (const i of arr) {
          currentCount += i.type === "s" ? 1 : -1;
          if (currentCount === 1) {
            start = i.time;
          } else {
            if (start && +start !== +i.time) {
              results.push(Interval2.fromDateTimes(start, i.time));
            }
            start = null;
          }
        }
        return Interval2.merge(results);
      }
      /**
       * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
       * @param {...Interval} intervals
       * @return {Array}
       */
      difference(...intervals) {
        return Interval2.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
      }
      /**
       * Returns a string representation of this Interval appropriate for debugging.
       * @return {string}
       */
      toString() {
        if (!this.isValid)
          return INVALID$12;
        return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
      }
      /**
       * Returns a localized string representing this Interval. Accepts the same options as the
       * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
       * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
       * is browser-specific, but in general it will return an appropriate representation of the
       * Interval in the assigned locale. Defaults to the system's locale if no locale has been
       * specified.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
       * Intl.DateTimeFormat constructor options.
       * @param {Object} opts - Options to override the configuration of the start DateTime.
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT2, opts = {}) {
        return this.isValid ? Formatter2.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$12;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Interval.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISO(opts) {
        if (!this.isValid)
          return INVALID$12;
        return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of date of this Interval.
       * The time components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {string}
       */
      toISODate() {
        if (!this.isValid)
          return INVALID$12;
        return `${this.s.toISODate()}/${this.e.toISODate()}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of time of this Interval.
       * The date components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISOTime(opts) {
        if (!this.isValid)
          return INVALID$12;
        return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
      }
      /**
       * Returns a string representation of this Interval formatted according to the specified format
       * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
       * formatting tool.
       * @param {string} dateFormat - The format string. This string formats the start and end time.
       * See {@link DateTime#toFormat} for details.
       * @param {Object} opts - Options.
       * @param {string} [opts.separator =  '  '] - A separator to place between the start and end
       * representations.
       * @return {string}
       */
      toFormat(dateFormat, { separator = " \u2013 " } = {}) {
        if (!this.isValid)
          return INVALID$12;
        return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
      }
      /**
       * Return a Duration representing the time spanned by this interval.
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
       * @return {Duration}
       */
      toDuration(unit, opts) {
        if (!this.isValid) {
          return Duration2.invalid(this.invalidReason);
        }
        return this.e.diff(this.s, unit, opts);
      }
      /**
       * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
       * @param {function} mapFn
       * @return {Interval}
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
       */
      mapEndpoints(mapFn) {
        return Interval2.fromDateTimes(mapFn(this.s), mapFn(this.e));
      }
    };
    var Info2 = class {
      /**
       * Return whether the specified zone contains a DST.
       * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
       * @return {boolean}
       */
      static hasDST(zone = Settings2.defaultZone) {
        const proto = DateTime2.now().setZone(zone).set({ month: 12 });
        return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
      }
      /**
       * Return whether the specified zone is a valid IANA specifier.
       * @param {string} zone - Zone to check
       * @return {boolean}
       */
      static isValidIANAZone(zone) {
        return IANAZone2.isValidZone(zone);
      }
      /**
       * Converts the input into a {@link Zone} instance.
       *
       * * If `input` is already a Zone instance, it is returned unchanged.
       * * If `input` is a string containing a valid time zone name, a Zone instance
       *   with that name is returned.
       * * If `input` is a string that doesn't refer to a known time zone, a Zone
       *   instance with {@link Zone#isValid} == false is returned.
       * * If `input is a number, a Zone instance with the specified fixed offset
       *   in minutes is returned.
       * * If `input` is `null` or `undefined`, the default zone is returned.
       * @param {string|Zone|number} [input] - the value to be converted
       * @return {Zone}
       */
      static normalizeZone(input) {
        return normalizeZone2(input, Settings2.defaultZone);
      }
      /**
       * Return an array of standalone month names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @example Info.months()[0] //=> 'January'
       * @example Info.months('short')[0] //=> 'Jan'
       * @example Info.months('numeric')[0] //=> '1'
       * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
       * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
       * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
       * @return {Array}
       */
      static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale2.create(locale, numberingSystem, outputCalendar)).months(length);
      }
      /**
       * Return an array of format month names.
       * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
       * changes the string.
       * See {@link Info#months}
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @return {Array}
       */
      static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale2.create(locale, numberingSystem, outputCalendar)).months(length, true);
      }
      /**
       * Return an array of standalone week names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @example Info.weekdays()[0] //=> 'Monday'
       * @example Info.weekdays('short')[0] //=> 'Mon'
       * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
       * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
       * @return {Array}
       */
      static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale2.create(locale, numberingSystem, null)).weekdays(length);
      }
      /**
       * Return an array of format week names.
       * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
       * changes the string.
       * See {@link Info#weekdays}
       * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale=null] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @return {Array}
       */
      static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale2.create(locale, numberingSystem, null)).weekdays(length, true);
      }
      /**
       * Return an array of meridiems.
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.meridiems() //=> [ 'AM', 'PM' ]
       * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
       * @return {Array}
       */
      static meridiems({ locale = null } = {}) {
        return Locale2.create(locale).meridiems();
      }
      /**
       * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
       * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.eras() //=> [ 'BC', 'AD' ]
       * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
       * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
       * @return {Array}
       */
      static eras(length = "short", { locale = null } = {}) {
        return Locale2.create(locale, null, "gregory").eras(length);
      }
      /**
       * Return the set of available features in this environment.
       * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
       * Keys:
       * * `relative`: whether this environment supports relative time formatting
       * @example Info.features() //=> { relative: false }
       * @return {Object}
       */
      static features() {
        return { relative: hasRelative2() };
      }
    };
    function dayDiff2(earlier, later) {
      const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
      return Math.floor(Duration2.fromMillis(ms).as("days"));
    }
    function highOrderDiffs2(cursor, later, units) {
      const differs = [
        ["years", (a, b) => b.year - a.year],
        ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
        ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
        [
          "weeks",
          (a, b) => {
            const days = dayDiff2(a, b);
            return (days - days % 7) / 7;
          }
        ],
        ["days", dayDiff2]
      ];
      const results = {};
      const earlier = cursor;
      let lowestOrder, highWater;
      for (const [unit, differ] of differs) {
        if (units.indexOf(unit) >= 0) {
          lowestOrder = unit;
          results[unit] = differ(cursor, later);
          highWater = earlier.plus(results);
          if (highWater > later) {
            results[unit]--;
            cursor = earlier.plus(results);
            if (cursor > later) {
              highWater = cursor;
              results[unit]--;
              cursor = earlier.plus(results);
            }
          } else {
            cursor = highWater;
          }
        }
      }
      return [cursor, results, highWater, lowestOrder];
    }
    function diff2(earlier, later, units, opts) {
      let [cursor, results, highWater, lowestOrder] = highOrderDiffs2(earlier, later, units);
      const remainingMillis = later - cursor;
      const lowerOrderUnits = units.filter(
        (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
      );
      if (lowerOrderUnits.length === 0) {
        if (highWater < later) {
          highWater = cursor.plus({ [lowestOrder]: 1 });
        }
        if (highWater !== cursor) {
          results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
        }
      }
      const duration = Duration2.fromObject(results, opts);
      if (lowerOrderUnits.length > 0) {
        return Duration2.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
      } else {
        return duration;
      }
    }
    var numberingSystems2 = {
      arab: "[\u0660-\u0669]",
      arabext: "[\u06F0-\u06F9]",
      bali: "[\u1B50-\u1B59]",
      beng: "[\u09E6-\u09EF]",
      deva: "[\u0966-\u096F]",
      fullwide: "[\uFF10-\uFF19]",
      gujr: "[\u0AE6-\u0AEF]",
      hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
      khmr: "[\u17E0-\u17E9]",
      knda: "[\u0CE6-\u0CEF]",
      laoo: "[\u0ED0-\u0ED9]",
      limb: "[\u1946-\u194F]",
      mlym: "[\u0D66-\u0D6F]",
      mong: "[\u1810-\u1819]",
      mymr: "[\u1040-\u1049]",
      orya: "[\u0B66-\u0B6F]",
      tamldec: "[\u0BE6-\u0BEF]",
      telu: "[\u0C66-\u0C6F]",
      thai: "[\u0E50-\u0E59]",
      tibt: "[\u0F20-\u0F29]",
      latn: "\\d"
    };
    var numberingSystemsUTF162 = {
      arab: [1632, 1641],
      arabext: [1776, 1785],
      bali: [6992, 7001],
      beng: [2534, 2543],
      deva: [2406, 2415],
      fullwide: [65296, 65303],
      gujr: [2790, 2799],
      khmr: [6112, 6121],
      knda: [3302, 3311],
      laoo: [3792, 3801],
      limb: [6470, 6479],
      mlym: [3430, 3439],
      mong: [6160, 6169],
      mymr: [4160, 4169],
      orya: [2918, 2927],
      tamldec: [3046, 3055],
      telu: [3174, 3183],
      thai: [3664, 3673],
      tibt: [3872, 3881]
    };
    var hanidecChars2 = numberingSystems2.hanidec.replace(/[\[|\]]/g, "").split("");
    function parseDigits2(str2) {
      let value = parseInt(str2, 10);
      if (isNaN(value)) {
        value = "";
        for (let i = 0; i < str2.length; i++) {
          const code = str2.charCodeAt(i);
          if (str2[i].search(numberingSystems2.hanidec) !== -1) {
            value += hanidecChars2.indexOf(str2[i]);
          } else {
            for (const key in numberingSystemsUTF162) {
              const [min, max] = numberingSystemsUTF162[key];
              if (code >= min && code <= max) {
                value += code - min;
              }
            }
          }
        }
        return parseInt(value, 10);
      } else {
        return value;
      }
    }
    function digitRegex2({ numberingSystem }, append = "") {
      return new RegExp(`${numberingSystems2[numberingSystem || "latn"]}${append}`);
    }
    var MISSING_FTP2 = "missing Intl.DateTimeFormat.formatToParts support";
    function intUnit2(regex, post = (i) => i) {
      return { regex, deser: ([s3]) => post(parseDigits2(s3)) };
    }
    var NBSP2 = String.fromCharCode(160);
    var spaceOrNBSP2 = `[ ${NBSP2}]`;
    var spaceOrNBSPRegExp2 = new RegExp(spaceOrNBSP2, "g");
    function fixListRegex2(s3) {
      return s3.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp2, spaceOrNBSP2);
    }
    function stripInsensitivities2(s3) {
      return s3.replace(/\./g, "").replace(spaceOrNBSPRegExp2, " ").toLowerCase();
    }
    function oneOf2(strings, startIndex) {
      if (strings === null) {
        return null;
      } else {
        return {
          regex: RegExp(strings.map(fixListRegex2).join("|")),
          deser: ([s3]) => strings.findIndex((i) => stripInsensitivities2(s3) === stripInsensitivities2(i)) + startIndex
        };
      }
    }
    function offset2(regex, groups) {
      return { regex, deser: ([, h, m]) => signedOffset2(h, m), groups };
    }
    function simple2(regex) {
      return { regex, deser: ([s3]) => s3 };
    }
    function escapeToken2(value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function unitForToken2(token, loc) {
      const one = digitRegex2(loc), two = digitRegex2(loc, "{2}"), three = digitRegex2(loc, "{3}"), four = digitRegex2(loc, "{4}"), six = digitRegex2(loc, "{6}"), oneOrTwo = digitRegex2(loc, "{1,2}"), oneToThree = digitRegex2(loc, "{1,3}"), oneToSix = digitRegex2(loc, "{1,6}"), oneToNine = digitRegex2(loc, "{1,9}"), twoToFour = digitRegex2(loc, "{2,4}"), fourToSix = digitRegex2(loc, "{4,6}"), literal = (t) => ({ regex: RegExp(escapeToken2(t.val)), deser: ([s3]) => s3, literal: true }), unitate = (t) => {
        if (token.literal) {
          return literal(t);
        }
        switch (t.val) {
          case "G":
            return oneOf2(loc.eras("short"), 0);
          case "GG":
            return oneOf2(loc.eras("long"), 0);
          case "y":
            return intUnit2(oneToSix);
          case "yy":
            return intUnit2(twoToFour, untruncateYear2);
          case "yyyy":
            return intUnit2(four);
          case "yyyyy":
            return intUnit2(fourToSix);
          case "yyyyyy":
            return intUnit2(six);
          case "M":
            return intUnit2(oneOrTwo);
          case "MM":
            return intUnit2(two);
          case "MMM":
            return oneOf2(loc.months("short", true), 1);
          case "MMMM":
            return oneOf2(loc.months("long", true), 1);
          case "L":
            return intUnit2(oneOrTwo);
          case "LL":
            return intUnit2(two);
          case "LLL":
            return oneOf2(loc.months("short", false), 1);
          case "LLLL":
            return oneOf2(loc.months("long", false), 1);
          case "d":
            return intUnit2(oneOrTwo);
          case "dd":
            return intUnit2(two);
          case "o":
            return intUnit2(oneToThree);
          case "ooo":
            return intUnit2(three);
          case "HH":
            return intUnit2(two);
          case "H":
            return intUnit2(oneOrTwo);
          case "hh":
            return intUnit2(two);
          case "h":
            return intUnit2(oneOrTwo);
          case "mm":
            return intUnit2(two);
          case "m":
            return intUnit2(oneOrTwo);
          case "q":
            return intUnit2(oneOrTwo);
          case "qq":
            return intUnit2(two);
          case "s":
            return intUnit2(oneOrTwo);
          case "ss":
            return intUnit2(two);
          case "S":
            return intUnit2(oneToThree);
          case "SSS":
            return intUnit2(three);
          case "u":
            return simple2(oneToNine);
          case "uu":
            return simple2(oneOrTwo);
          case "uuu":
            return intUnit2(one);
          case "a":
            return oneOf2(loc.meridiems(), 0);
          case "kkkk":
            return intUnit2(four);
          case "kk":
            return intUnit2(twoToFour, untruncateYear2);
          case "W":
            return intUnit2(oneOrTwo);
          case "WW":
            return intUnit2(two);
          case "E":
          case "c":
            return intUnit2(one);
          case "EEE":
            return oneOf2(loc.weekdays("short", false), 1);
          case "EEEE":
            return oneOf2(loc.weekdays("long", false), 1);
          case "ccc":
            return oneOf2(loc.weekdays("short", true), 1);
          case "cccc":
            return oneOf2(loc.weekdays("long", true), 1);
          case "Z":
          case "ZZ":
            return offset2(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
          case "ZZZ":
            return offset2(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
          case "z":
            return simple2(/[a-z_+-/]{1,256}?/i);
          case " ":
            return simple2(/[^\S\n\r]/);
          default:
            return literal(t);
        }
      };
      const unit = unitate(token) || {
        invalidReason: MISSING_FTP2
      };
      unit.token = token;
      return unit;
    }
    var partTypeStyleToTokenVal2 = {
      year: {
        "2-digit": "yy",
        numeric: "yyyyy"
      },
      month: {
        numeric: "M",
        "2-digit": "MM",
        short: "MMM",
        long: "MMMM"
      },
      day: {
        numeric: "d",
        "2-digit": "dd"
      },
      weekday: {
        short: "EEE",
        long: "EEEE"
      },
      dayperiod: "a",
      dayPeriod: "a",
      hour12: {
        numeric: "h",
        "2-digit": "hh"
      },
      hour24: {
        numeric: "H",
        "2-digit": "HH"
      },
      minute: {
        numeric: "m",
        "2-digit": "mm"
      },
      second: {
        numeric: "s",
        "2-digit": "ss"
      },
      timeZoneName: {
        long: "ZZZZZ",
        short: "ZZZ"
      }
    };
    function tokenForPart2(part, formatOpts, resolvedOpts) {
      const { type: type2, value } = part;
      if (type2 === "literal") {
        const isSpace = /^\s+$/.test(value);
        return {
          literal: !isSpace,
          val: isSpace ? " " : value
        };
      }
      const style = formatOpts[type2];
      let actualType = type2;
      if (type2 === "hour") {
        if (formatOpts.hour12 != null) {
          actualType = formatOpts.hour12 ? "hour12" : "hour24";
        } else if (formatOpts.hourCycle != null) {
          if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
            actualType = "hour12";
          } else {
            actualType = "hour24";
          }
        } else {
          actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
        }
      }
      let val = partTypeStyleToTokenVal2[actualType];
      if (typeof val === "object") {
        val = val[style];
      }
      if (val) {
        return {
          literal: false,
          val
        };
      }
      return void 0;
    }
    function buildRegex2(units) {
      const re = units.map((u) => u.regex).reduce((f2, r) => `${f2}(${r.source})`, "");
      return [`^${re}$`, units];
    }
    function match2(input, regex, handlers) {
      const matches = input.match(regex);
      if (matches) {
        const all = {};
        let matchIndex = 1;
        for (const i in handlers) {
          if (hasOwnProperty2(handlers, i)) {
            const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
            if (!h.literal && h.token) {
              all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
            }
            matchIndex += groups;
          }
        }
        return [matches, all];
      } else {
        return [matches, {}];
      }
    }
    function dateTimeFromMatches2(matches) {
      const toField = (token) => {
        switch (token) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
          case "H":
            return "hour";
          case "d":
            return "day";
          case "o":
            return "ordinal";
          case "L":
          case "M":
            return "month";
          case "y":
            return "year";
          case "E":
          case "c":
            return "weekday";
          case "W":
            return "weekNumber";
          case "k":
            return "weekYear";
          case "q":
            return "quarter";
          default:
            return null;
        }
      };
      let zone = null;
      let specificOffset;
      if (!isUndefined2(matches.z)) {
        zone = IANAZone2.create(matches.z);
      }
      if (!isUndefined2(matches.Z)) {
        if (!zone) {
          zone = new FixedOffsetZone2(matches.Z);
        }
        specificOffset = matches.Z;
      }
      if (!isUndefined2(matches.q)) {
        matches.M = (matches.q - 1) * 3 + 1;
      }
      if (!isUndefined2(matches.h)) {
        if (matches.h < 12 && matches.a === 1) {
          matches.h += 12;
        } else if (matches.h === 12 && matches.a === 0) {
          matches.h = 0;
        }
      }
      if (matches.G === 0 && matches.y) {
        matches.y = -matches.y;
      }
      if (!isUndefined2(matches.u)) {
        matches.S = parseMillis2(matches.u);
      }
      const vals = Object.keys(matches).reduce((r, k) => {
        const f2 = toField(k);
        if (f2) {
          r[f2] = matches[k];
        }
        return r;
      }, {});
      return [vals, zone, specificOffset];
    }
    var dummyDateTimeCache2 = null;
    function getDummyDateTime2() {
      if (!dummyDateTimeCache2) {
        dummyDateTimeCache2 = DateTime2.fromMillis(1555555555555);
      }
      return dummyDateTimeCache2;
    }
    function maybeExpandMacroToken2(token, locale) {
      if (token.literal) {
        return token;
      }
      const formatOpts = Formatter2.macroTokenToFormatOpts(token.val);
      const tokens = formatOptsToTokens2(formatOpts, locale);
      if (tokens == null || tokens.includes(void 0)) {
        return token;
      }
      return tokens;
    }
    function expandMacroTokens2(tokens, locale) {
      return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken2(t, locale)));
    }
    function explainFromTokens2(locale, input, format) {
      const tokens = expandMacroTokens2(Formatter2.parseFormat(format), locale), units = tokens.map((t) => unitForToken2(t, locale)), disqualifyingUnit = units.find((t) => t.invalidReason);
      if (disqualifyingUnit) {
        return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
      } else {
        const [regexString, handlers] = buildRegex2(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match2(input, regex, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches2(matches) : [null, null, void 0];
        if (hasOwnProperty2(matches, "a") && hasOwnProperty2(matches, "H")) {
          throw new ConflictingSpecificationError2(
            "Can't include meridiem when specifying 24-hour format"
          );
        }
        return { input, tokens, regex, rawMatches, matches, result, zone, specificOffset };
      }
    }
    function parseFromTokens2(locale, input, format) {
      const { result, zone, specificOffset, invalidReason } = explainFromTokens2(locale, input, format);
      return [result, zone, specificOffset, invalidReason];
    }
    function formatOptsToTokens2(formatOpts, locale) {
      if (!formatOpts) {
        return null;
      }
      const formatter = Formatter2.create(locale, formatOpts);
      const df = formatter.dtFormatter(getDummyDateTime2());
      const parts = df.formatToParts();
      const resolvedOpts = df.resolvedOptions();
      return parts.map((p) => tokenForPart2(p, formatOpts, resolvedOpts));
    }
    var nonLeapLadder2 = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    var leapLadder2 = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    function unitOutOfRange2(unit, value) {
      return new Invalid2(
        "unit out of range",
        `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
      );
    }
    function dayOfWeek2(year, month, day) {
      const d = new Date(Date.UTC(year, month - 1, day));
      if (year < 100 && year >= 0) {
        d.setUTCFullYear(d.getUTCFullYear() - 1900);
      }
      const js = d.getUTCDay();
      return js === 0 ? 7 : js;
    }
    function computeOrdinal2(year, month, day) {
      return day + (isLeapYear2(year) ? leapLadder2 : nonLeapLadder2)[month - 1];
    }
    function uncomputeOrdinal2(year, ordinal) {
      const table = isLeapYear2(year) ? leapLadder2 : nonLeapLadder2, month0 = table.findIndex((i) => i < ordinal), day = ordinal - table[month0];
      return { month: month0 + 1, day };
    }
    function gregorianToWeek2(gregObj) {
      const { year, month, day } = gregObj, ordinal = computeOrdinal2(year, month, day), weekday = dayOfWeek2(year, month, day);
      let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
      if (weekNumber < 1) {
        weekYear = year - 1;
        weekNumber = weeksInWeekYear2(weekYear);
      } else if (weekNumber > weeksInWeekYear2(year)) {
        weekYear = year + 1;
        weekNumber = 1;
      } else {
        weekYear = year;
      }
      return { weekYear, weekNumber, weekday, ...timeObject2(gregObj) };
    }
    function weekToGregorian2(weekData) {
      const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek2(weekYear, 1, 4), yearInDays = daysInYear2(weekYear);
      let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
      if (ordinal < 1) {
        year = weekYear - 1;
        ordinal += daysInYear2(year);
      } else if (ordinal > yearInDays) {
        year = weekYear + 1;
        ordinal -= daysInYear2(weekYear);
      } else {
        year = weekYear;
      }
      const { month, day } = uncomputeOrdinal2(year, ordinal);
      return { year, month, day, ...timeObject2(weekData) };
    }
    function gregorianToOrdinal2(gregData) {
      const { year, month, day } = gregData;
      const ordinal = computeOrdinal2(year, month, day);
      return { year, ordinal, ...timeObject2(gregData) };
    }
    function ordinalToGregorian2(ordinalData) {
      const { year, ordinal } = ordinalData;
      const { month, day } = uncomputeOrdinal2(year, ordinal);
      return { year, month, day, ...timeObject2(ordinalData) };
    }
    function hasInvalidWeekData2(obj) {
      const validYear = isInteger3(obj.weekYear), validWeek = integerBetween2(obj.weekNumber, 1, weeksInWeekYear2(obj.weekYear)), validWeekday = integerBetween2(obj.weekday, 1, 7);
      if (!validYear) {
        return unitOutOfRange2("weekYear", obj.weekYear);
      } else if (!validWeek) {
        return unitOutOfRange2("week", obj.week);
      } else if (!validWeekday) {
        return unitOutOfRange2("weekday", obj.weekday);
      } else
        return false;
    }
    function hasInvalidOrdinalData2(obj) {
      const validYear = isInteger3(obj.year), validOrdinal = integerBetween2(obj.ordinal, 1, daysInYear2(obj.year));
      if (!validYear) {
        return unitOutOfRange2("year", obj.year);
      } else if (!validOrdinal) {
        return unitOutOfRange2("ordinal", obj.ordinal);
      } else
        return false;
    }
    function hasInvalidGregorianData2(obj) {
      const validYear = isInteger3(obj.year), validMonth = integerBetween2(obj.month, 1, 12), validDay = integerBetween2(obj.day, 1, daysInMonth2(obj.year, obj.month));
      if (!validYear) {
        return unitOutOfRange2("year", obj.year);
      } else if (!validMonth) {
        return unitOutOfRange2("month", obj.month);
      } else if (!validDay) {
        return unitOutOfRange2("day", obj.day);
      } else
        return false;
    }
    function hasInvalidTimeData2(obj) {
      const { hour, minute, second, millisecond } = obj;
      const validHour = integerBetween2(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween2(minute, 0, 59), validSecond = integerBetween2(second, 0, 59), validMillisecond = integerBetween2(millisecond, 0, 999);
      if (!validHour) {
        return unitOutOfRange2("hour", hour);
      } else if (!validMinute) {
        return unitOutOfRange2("minute", minute);
      } else if (!validSecond) {
        return unitOutOfRange2("second", second);
      } else if (!validMillisecond) {
        return unitOutOfRange2("millisecond", millisecond);
      } else
        return false;
    }
    var INVALID2 = "Invalid DateTime";
    var MAX_DATE2 = 864e13;
    function unsupportedZone2(zone) {
      return new Invalid2("unsupported zone", `the zone "${zone.name}" is not supported`);
    }
    function possiblyCachedWeekData2(dt) {
      if (dt.weekData === null) {
        dt.weekData = gregorianToWeek2(dt.c);
      }
      return dt.weekData;
    }
    function clone2(inst, alts) {
      const current = {
        ts: inst.ts,
        zone: inst.zone,
        c: inst.c,
        o: inst.o,
        loc: inst.loc,
        invalid: inst.invalid
      };
      return new DateTime2({ ...current, ...alts, old: current });
    }
    function fixOffset2(localTS, o, tz) {
      let utcGuess = localTS - o * 60 * 1e3;
      const o2 = tz.offset(utcGuess);
      if (o === o2) {
        return [utcGuess, o];
      }
      utcGuess -= (o2 - o) * 60 * 1e3;
      const o3 = tz.offset(utcGuess);
      if (o2 === o3) {
        return [utcGuess, o2];
      }
      return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
    }
    function tsToObj2(ts, offset3) {
      ts += offset3 * 60 * 1e3;
      const d = new Date(ts);
      return {
        year: d.getUTCFullYear(),
        month: d.getUTCMonth() + 1,
        day: d.getUTCDate(),
        hour: d.getUTCHours(),
        minute: d.getUTCMinutes(),
        second: d.getUTCSeconds(),
        millisecond: d.getUTCMilliseconds()
      };
    }
    function objToTS2(obj, offset3, zone) {
      return fixOffset2(objToLocalTS2(obj), offset3, zone);
    }
    function adjustTime2(inst, dur) {
      const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
        ...inst.c,
        year,
        month,
        day: Math.min(inst.c.day, daysInMonth2(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
      }, millisToAdd = Duration2.fromObject({
        years: dur.years - Math.trunc(dur.years),
        quarters: dur.quarters - Math.trunc(dur.quarters),
        months: dur.months - Math.trunc(dur.months),
        weeks: dur.weeks - Math.trunc(dur.weeks),
        days: dur.days - Math.trunc(dur.days),
        hours: dur.hours,
        minutes: dur.minutes,
        seconds: dur.seconds,
        milliseconds: dur.milliseconds
      }).as("milliseconds"), localTS = objToLocalTS2(c);
      let [ts, o] = fixOffset2(localTS, oPre, inst.zone);
      if (millisToAdd !== 0) {
        ts += millisToAdd;
        o = inst.zone.offset(ts);
      }
      return { ts, o };
    }
    function parseDataToDateTime2(parsed, parsedZone, opts, format, text, specificOffset) {
      const { setZone, zone } = opts;
      if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
        const interpretationZone = parsedZone || zone, inst = DateTime2.fromObject(parsed, {
          ...opts,
          zone: interpretationZone,
          specificOffset
        });
        return setZone ? inst : inst.setZone(zone);
      } else {
        return DateTime2.invalid(
          new Invalid2("unparsable", `the input "${text}" can't be parsed as ${format}`)
        );
      }
    }
    function toTechFormat2(dt, format, allowZ = true) {
      return dt.isValid ? Formatter2.create(Locale2.create("en-US"), {
        allowZ,
        forceSimple: true
      }).formatDateTimeFromString(dt, format) : null;
    }
    function toISODate2(o, extended) {
      const longFormat = o.c.year > 9999 || o.c.year < 0;
      let c = "";
      if (longFormat && o.c.year >= 0)
        c += "+";
      c += padStart3(o.c.year, longFormat ? 6 : 4);
      if (extended) {
        c += "-";
        c += padStart3(o.c.month);
        c += "-";
        c += padStart3(o.c.day);
      } else {
        c += padStart3(o.c.month);
        c += padStart3(o.c.day);
      }
      return c;
    }
    function toISOTime2(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
      let c = padStart3(o.c.hour);
      if (extended) {
        c += ":";
        c += padStart3(o.c.minute);
        if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
          c += ":";
        }
      } else {
        c += padStart3(o.c.minute);
      }
      if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
        c += padStart3(o.c.second);
        if (o.c.millisecond !== 0 || !suppressMilliseconds) {
          c += ".";
          c += padStart3(o.c.millisecond, 3);
        }
      }
      if (includeOffset) {
        if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
          c += "Z";
        } else if (o.o < 0) {
          c += "-";
          c += padStart3(Math.trunc(-o.o / 60));
          c += ":";
          c += padStart3(Math.trunc(-o.o % 60));
        } else {
          c += "+";
          c += padStart3(Math.trunc(o.o / 60));
          c += ":";
          c += padStart3(Math.trunc(o.o % 60));
        }
      }
      if (extendedZone) {
        c += "[" + o.zone.ianaName + "]";
      }
      return c;
    }
    var defaultUnitValues2 = {
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultWeekUnitValues2 = {
      weekNumber: 1,
      weekday: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultOrdinalUnitValues2 = {
      ordinal: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var orderedUnits2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
    var orderedWeekUnits2 = [
      "weekYear",
      "weekNumber",
      "weekday",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    var orderedOrdinalUnits2 = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
    function normalizeUnit2(unit) {
      const normalized = {
        year: "year",
        years: "year",
        month: "month",
        months: "month",
        day: "day",
        days: "day",
        hour: "hour",
        hours: "hour",
        minute: "minute",
        minutes: "minute",
        quarter: "quarter",
        quarters: "quarter",
        second: "second",
        seconds: "second",
        millisecond: "millisecond",
        milliseconds: "millisecond",
        weekday: "weekday",
        weekdays: "weekday",
        weeknumber: "weekNumber",
        weeksnumber: "weekNumber",
        weeknumbers: "weekNumber",
        weekyear: "weekYear",
        weekyears: "weekYear",
        ordinal: "ordinal"
      }[unit.toLowerCase()];
      if (!normalized)
        throw new InvalidUnitError2(unit);
      return normalized;
    }
    function quickDT2(obj, opts) {
      const zone = normalizeZone2(opts.zone, Settings2.defaultZone), loc = Locale2.fromObject(opts), tsNow = Settings2.now();
      let ts, o;
      if (!isUndefined2(obj.year)) {
        for (const u of orderedUnits2) {
          if (isUndefined2(obj[u])) {
            obj[u] = defaultUnitValues2[u];
          }
        }
        const invalid = hasInvalidGregorianData2(obj) || hasInvalidTimeData2(obj);
        if (invalid) {
          return DateTime2.invalid(invalid);
        }
        const offsetProvis = zone.offset(tsNow);
        [ts, o] = objToTS2(obj, offsetProvis, zone);
      } else {
        ts = tsNow;
      }
      return new DateTime2({ ts, zone, loc, o });
    }
    function diffRelative2(start, end, opts) {
      const round = isUndefined2(opts.round) ? true : opts.round, format = (c, unit) => {
        c = roundTo2(c, round || opts.calendary ? 0 : 2, true);
        const formatter = end.loc.clone(opts).relFormatter(opts);
        return formatter.format(c, unit);
      }, differ = (unit) => {
        if (opts.calendary) {
          if (!end.hasSame(start, unit)) {
            return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
          } else
            return 0;
        } else {
          return end.diff(start, unit).get(unit);
        }
      };
      if (opts.unit) {
        return format(differ(opts.unit), opts.unit);
      }
      for (const unit of opts.units) {
        const count = differ(unit);
        if (Math.abs(count) >= 1) {
          return format(count, unit);
        }
      }
      return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
    }
    function lastOpts2(argList) {
      let opts = {}, args;
      if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
        opts = argList[argList.length - 1];
        args = Array.from(argList).slice(0, argList.length - 1);
      } else {
        args = Array.from(argList);
      }
      return [opts, args];
    }
    var DateTime2 = class {
      /**
       * @access private
       */
      constructor(config) {
        const zone = config.zone || Settings2.defaultZone;
        let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid2("invalid input") : null) || (!zone.isValid ? unsupportedZone2(zone) : null);
        this.ts = isUndefined2(config.ts) ? Settings2.now() : config.ts;
        let c = null, o = null;
        if (!invalid) {
          const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
          if (unchanged) {
            [c, o] = [config.old.c, config.old.o];
          } else {
            const ot = zone.offset(this.ts);
            c = tsToObj2(this.ts, ot);
            invalid = Number.isNaN(c.year) ? new Invalid2("invalid input") : null;
            c = invalid ? null : c;
            o = invalid ? null : ot;
          }
        }
        this._zone = zone;
        this.loc = config.loc || Locale2.create();
        this.invalid = invalid;
        this.weekData = null;
        this.c = c;
        this.o = o;
        this.isLuxonDateTime = true;
      }
      // CONSTRUCT
      /**
       * Create a DateTime for the current instant, in the system's time zone.
       *
       * Use Settings to override these default values if needed.
       * @example DateTime.now().toISO() //~> now in the ISO format
       * @return {DateTime}
       */
      static now() {
        return new DateTime2({});
      }
      /**
       * Create a local DateTime
       * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month, 1-indexed
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @example DateTime.local()                                  //~> now
       * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
       * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
       * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
       * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
       * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
       * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
       * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
       * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
       * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
       * @return {DateTime}
       */
      static local() {
        const [opts, args] = lastOpts2(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        return quickDT2({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime in UTC
       * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @param {Object} options - configuration options for the DateTime
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.utc()                                              //~> now
       * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
       * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
       * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
       * @return {DateTime}
       */
      static utc() {
        const [opts, args] = lastOpts2(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        opts.zone = FixedOffsetZone2.utcInstance;
        return quickDT2({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime from a JavaScript Date object. Uses the default zone.
       * @param {Date} date - a JavaScript Date object
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @return {DateTime}
       */
      static fromJSDate(date, options = {}) {
        const ts = isDate2(date) ? date.valueOf() : NaN;
        if (Number.isNaN(ts)) {
          return DateTime2.invalid("invalid input");
        }
        const zoneToUse = normalizeZone2(options.zone, Settings2.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime2.invalid(unsupportedZone2(zoneToUse));
        }
        return new DateTime2({
          ts,
          zone: zoneToUse,
          loc: Locale2.fromObject(options)
        });
      }
      /**
       * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} milliseconds - a number of milliseconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromMillis(milliseconds, options = {}) {
        if (!isNumber2(milliseconds)) {
          throw new InvalidArgumentError2(
            `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
          );
        } else if (milliseconds < -MAX_DATE2 || milliseconds > MAX_DATE2) {
          return DateTime2.invalid("Timestamp out of range");
        } else {
          return new DateTime2({
            ts: milliseconds,
            zone: normalizeZone2(options.zone, Settings2.defaultZone),
            loc: Locale2.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} seconds - a number of seconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromSeconds(seconds, options = {}) {
        if (!isNumber2(seconds)) {
          throw new InvalidArgumentError2("fromSeconds requires a numerical input");
        } else {
          return new DateTime2({
            ts: seconds * 1e3,
            zone: normalizeZone2(options.zone, Settings2.defaultZone),
            loc: Locale2.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.year - a year, such as 1987
       * @param {number} obj.month - a month, 1-12
       * @param {number} obj.day - a day of the month, 1-31, depending on the month
       * @param {number} obj.ordinal - day of the year, 1-365 or 366
       * @param {number} obj.weekYear - an ISO week year
       * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
       * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
       * @param {number} obj.hour - hour of the day, 0-23
       * @param {number} obj.minute - minute of the hour, 0-59
       * @param {number} obj.second - second of the minute, 0-59
       * @param {number} obj.millisecond - millisecond of the second, 0-999
       * @param {Object} opts - options for creating this DateTime
       * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
       * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
       * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
       * @return {DateTime}
       */
      static fromObject(obj, opts = {}) {
        obj = obj || {};
        const zoneToUse = normalizeZone2(opts.zone, Settings2.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime2.invalid(unsupportedZone2(zoneToUse));
        }
        const tsNow = Settings2.now(), offsetProvis = !isUndefined2(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject2(obj, normalizeUnit2), containsOrdinal = !isUndefined2(normalized.ordinal), containsGregorYear = !isUndefined2(normalized.year), containsGregorMD = !isUndefined2(normalized.month) || !isUndefined2(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale2.fromObject(opts);
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError2(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError2("Can't mix ordinal dates with month/day");
        }
        const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
        let units, defaultValues, objNow = tsToObj2(tsNow, offsetProvis);
        if (useWeekData) {
          units = orderedWeekUnits2;
          defaultValues = defaultWeekUnitValues2;
          objNow = gregorianToWeek2(objNow);
        } else if (containsOrdinal) {
          units = orderedOrdinalUnits2;
          defaultValues = defaultOrdinalUnitValues2;
          objNow = gregorianToOrdinal2(objNow);
        } else {
          units = orderedUnits2;
          defaultValues = defaultUnitValues2;
        }
        let foundFirst = false;
        for (const u of units) {
          const v = normalized[u];
          if (!isUndefined2(v)) {
            foundFirst = true;
          } else if (foundFirst) {
            normalized[u] = defaultValues[u];
          } else {
            normalized[u] = objNow[u];
          }
        }
        const higherOrderInvalid = useWeekData ? hasInvalidWeekData2(normalized) : containsOrdinal ? hasInvalidOrdinalData2(normalized) : hasInvalidGregorianData2(normalized), invalid = higherOrderInvalid || hasInvalidTimeData2(normalized);
        if (invalid) {
          return DateTime2.invalid(invalid);
        }
        const gregorian = useWeekData ? weekToGregorian2(normalized) : containsOrdinal ? ordinalToGregorian2(normalized) : normalized, [tsFinal, offsetFinal] = objToTS2(gregorian, offsetProvis, zoneToUse), inst = new DateTime2({
          ts: tsFinal,
          zone: zoneToUse,
          o: offsetFinal,
          loc
        });
        if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
          return DateTime2.invalid(
            "mismatched weekday",
            `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
          );
        }
        return inst;
      }
      /**
       * Create a DateTime from an ISO 8601 string
       * @param {string} text - the ISO string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromISO('2016-05-25T09:08:34.123')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
       * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
       * @example DateTime.fromISO('2016-W05-4')
       * @return {DateTime}
       */
      static fromISO(text, opts = {}) {
        const [vals, parsedZone] = parseISODate2(text);
        return parseDataToDateTime2(vals, parsedZone, opts, "ISO 8601", text);
      }
      /**
       * Create a DateTime from an RFC 2822 string
       * @param {string} text - the RFC 2822 string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
       * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
       * @return {DateTime}
       */
      static fromRFC2822(text, opts = {}) {
        const [vals, parsedZone] = parseRFC2822Date2(text);
        return parseDataToDateTime2(vals, parsedZone, opts, "RFC 2822", text);
      }
      /**
       * Create a DateTime from an HTTP header date
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @param {string} text - the HTTP header date
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
       * @return {DateTime}
       */
      static fromHTTP(text, opts = {}) {
        const [vals, parsedZone] = parseHTTPDate2(text);
        return parseDataToDateTime2(vals, parsedZone, opts, "HTTP", opts);
      }
      /**
       * Create a DateTime from an input string and format string.
       * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromFormat(text, fmt, opts = {}) {
        if (isUndefined2(text) || isUndefined2(fmt)) {
          throw new InvalidArgumentError2("fromFormat requires an input string and a format");
        }
        const { locale = null, numberingSystem = null } = opts, localeToUse = Locale2.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens2(localeToUse, text, fmt);
        if (invalid) {
          return DateTime2.invalid(invalid);
        } else {
          return parseDataToDateTime2(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
        }
      }
      /**
       * @deprecated use fromFormat instead
       */
      static fromString(text, fmt, opts = {}) {
        return DateTime2.fromFormat(text, fmt, opts);
      }
      /**
       * Create a DateTime from a SQL date, time, or datetime
       * Defaults to en-US if no locale has been specified, regardless of the system's locale
       * @param {string} text - the string to parse
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @example DateTime.fromSQL('2017-05-15')
       * @example DateTime.fromSQL('2017-05-15 09:12:34')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
       * @example DateTime.fromSQL('09:12:34.342')
       * @return {DateTime}
       */
      static fromSQL(text, opts = {}) {
        const [vals, parsedZone] = parseSQL2(text);
        return parseDataToDateTime2(vals, parsedZone, opts, "SQL", text);
      }
      /**
       * Create an invalid DateTime.
       * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {DateTime}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError2("need to specify a reason the DateTime is invalid");
        }
        const invalid = reason instanceof Invalid2 ? reason : new Invalid2(reason, explanation);
        if (Settings2.throwOnInvalid) {
          throw new InvalidDateTimeError2(invalid);
        } else {
          return new DateTime2({ invalid });
        }
      }
      /**
       * Check if an object is an instance of DateTime. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDateTime(o) {
        return o && o.isLuxonDateTime || false;
      }
      /**
       * Produce the format string for a set of options
       * @param formatOpts
       * @param localeOpts
       * @returns {string}
       */
      static parseFormatForOpts(formatOpts, localeOpts = {}) {
        const tokenList = formatOptsToTokens2(formatOpts, Locale2.fromObject(localeOpts));
        return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
      }
      /**
       * Produce the the fully expanded format token for the locale
       * Does NOT quote characters, so quoted tokens will not round trip correctly
       * @param fmt
       * @param localeOpts
       * @returns {string}
       */
      static expandFormat(fmt, localeOpts = {}) {
        const expanded = expandMacroTokens2(Formatter2.parseFormat(fmt), Locale2.fromObject(localeOpts));
        return expanded.map((t) => t.val).join("");
      }
      // INFO
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
       * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
       * @return {number}
       */
      get(unit) {
        return this[unit];
      }
      /**
       * Returns whether the DateTime is valid. Invalid DateTimes occur when:
       * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
       * * The DateTime was created by an operation on another invalid date
       * @type {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
       *
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
       *
       * @type {string}
       */
      get outputCalendar() {
        return this.isValid ? this.loc.outputCalendar : null;
      }
      /**
       * Get the time zone associated with this DateTime.
       * @type {Zone}
       */
      get zone() {
        return this._zone;
      }
      /**
       * Get the name of the time zone.
       * @type {string}
       */
      get zoneName() {
        return this.isValid ? this.zone.name : null;
      }
      /**
       * Get the year
       * @example DateTime.local(2017, 5, 25).year //=> 2017
       * @type {number}
       */
      get year() {
        return this.isValid ? this.c.year : NaN;
      }
      /**
       * Get the quarter
       * @example DateTime.local(2017, 5, 25).quarter //=> 2
       * @type {number}
       */
      get quarter() {
        return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
      }
      /**
       * Get the month (1-12).
       * @example DateTime.local(2017, 5, 25).month //=> 5
       * @type {number}
       */
      get month() {
        return this.isValid ? this.c.month : NaN;
      }
      /**
       * Get the day of the month (1-30ish).
       * @example DateTime.local(2017, 5, 25).day //=> 25
       * @type {number}
       */
      get day() {
        return this.isValid ? this.c.day : NaN;
      }
      /**
       * Get the hour of the day (0-23).
       * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
       * @type {number}
       */
      get hour() {
        return this.isValid ? this.c.hour : NaN;
      }
      /**
       * Get the minute of the hour (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
       * @type {number}
       */
      get minute() {
        return this.isValid ? this.c.minute : NaN;
      }
      /**
       * Get the second of the minute (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
       * @type {number}
       */
      get second() {
        return this.isValid ? this.c.second : NaN;
      }
      /**
       * Get the millisecond of the second (0-999).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
       * @type {number}
       */
      get millisecond() {
        return this.isValid ? this.c.millisecond : NaN;
      }
      /**
       * Get the week year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
       * @type {number}
       */
      get weekYear() {
        return this.isValid ? possiblyCachedWeekData2(this).weekYear : NaN;
      }
      /**
       * Get the week number of the week year (1-52ish).
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
       * @type {number}
       */
      get weekNumber() {
        return this.isValid ? possiblyCachedWeekData2(this).weekNumber : NaN;
      }
      /**
       * Get the day of the week.
       * 1 is Monday and 7 is Sunday
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 11, 31).weekday //=> 4
       * @type {number}
       */
      get weekday() {
        return this.isValid ? possiblyCachedWeekData2(this).weekday : NaN;
      }
      /**
       * Get the ordinal (meaning the day of the year)
       * @example DateTime.local(2017, 5, 25).ordinal //=> 145
       * @type {number|DateTime}
       */
      get ordinal() {
        return this.isValid ? gregorianToOrdinal2(this.c).ordinal : NaN;
      }
      /**
       * Get the human readable short month name, such as 'Oct'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
       * @type {string}
       */
      get monthShort() {
        return this.isValid ? Info2.months("short", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable long month name, such as 'October'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthLong //=> October
       * @type {string}
       */
      get monthLong() {
        return this.isValid ? Info2.months("long", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable short weekday, such as 'Mon'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
       * @type {string}
       */
      get weekdayShort() {
        return this.isValid ? Info2.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the human readable long weekday, such as 'Monday'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
       * @type {string}
       */
      get weekdayLong() {
        return this.isValid ? Info2.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the UTC offset of this DateTime in minutes
       * @example DateTime.now().offset //=> -240
       * @example DateTime.utc().offset //=> 0
       * @type {number}
       */
      get offset() {
        return this.isValid ? +this.o : NaN;
      }
      /**
       * Get the short human name for the zone's current offset, for example "EST" or "EDT".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameShort() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "short",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameLong() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "long",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get whether this zone's offset ever changes, as in a DST.
       * @type {boolean}
       */
      get isOffsetFixed() {
        return this.isValid ? this.zone.isUniversal : null;
      }
      /**
       * Get whether the DateTime is in a DST.
       * @type {boolean}
       */
      get isInDST() {
        if (this.isOffsetFixed) {
          return false;
        } else {
          return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
        }
      }
      /**
       * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
       * in this DateTime's zone. During DST changes local time can be ambiguous, for example
       * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
       * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
       * @returns {DateTime[]}
       */
      getPossibleOffsets() {
        if (!this.isValid || this.isOffsetFixed) {
          return [this];
        }
        const dayMs = 864e5;
        const minuteMs = 6e4;
        const localTS = objToLocalTS2(this.c);
        const oEarlier = this.zone.offset(localTS - dayMs);
        const oLater = this.zone.offset(localTS + dayMs);
        const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
        const o2 = this.zone.offset(localTS - oLater * minuteMs);
        if (o1 === o2) {
          return [this];
        }
        const ts1 = localTS - o1 * minuteMs;
        const ts2 = localTS - o2 * minuteMs;
        const c1 = tsToObj2(ts1, o1);
        const c2 = tsToObj2(ts2, o2);
        if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
          return [clone2(this, { ts: ts1 }), clone2(this, { ts: ts2 })];
        }
        return [this];
      }
      /**
       * Returns true if this DateTime is in a leap year, false otherwise
       * @example DateTime.local(2016).isInLeapYear //=> true
       * @example DateTime.local(2013).isInLeapYear //=> false
       * @type {boolean}
       */
      get isInLeapYear() {
        return isLeapYear2(this.year);
      }
      /**
       * Returns the number of days in this DateTime's month
       * @example DateTime.local(2016, 2).daysInMonth //=> 29
       * @example DateTime.local(2016, 3).daysInMonth //=> 31
       * @type {number}
       */
      get daysInMonth() {
        return daysInMonth2(this.year, this.month);
      }
      /**
       * Returns the number of days in this DateTime's year
       * @example DateTime.local(2016).daysInYear //=> 366
       * @example DateTime.local(2013).daysInYear //=> 365
       * @type {number}
       */
      get daysInYear() {
        return this.isValid ? daysInYear2(this.year) : NaN;
      }
      /**
       * Returns the number of weeks in this DateTime's year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2004).weeksInWeekYear //=> 53
       * @example DateTime.local(2013).weeksInWeekYear //=> 52
       * @type {number}
       */
      get weeksInWeekYear() {
        return this.isValid ? weeksInWeekYear2(this.weekYear) : NaN;
      }
      /**
       * Returns the resolved Intl options for this DateTime.
       * This is useful in understanding the behavior of formatting methods
       * @param {Object} opts - the same options as toLocaleString
       * @return {Object}
       */
      resolvedLocaleOptions(opts = {}) {
        const { locale, numberingSystem, calendar } = Formatter2.create(
          this.loc.clone(opts),
          opts
        ).resolvedOptions(this);
        return { locale, numberingSystem, outputCalendar: calendar };
      }
      // TRANSFORM
      /**
       * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
       *
       * Equivalent to {@link DateTime#setZone}('utc')
       * @param {number} [offset=0] - optionally, an offset from UTC in minutes
       * @param {Object} [opts={}] - options to pass to `setZone()`
       * @return {DateTime}
       */
      toUTC(offset3 = 0, opts = {}) {
        return this.setZone(FixedOffsetZone2.instance(offset3), opts);
      }
      /**
       * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
       *
       * Equivalent to `setZone('local')`
       * @return {DateTime}
       */
      toLocal() {
        return this.setZone(Settings2.defaultZone);
      }
      /**
       * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
       *
       * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
       * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
       * @param {Object} opts - options
       * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
       * @return {DateTime}
       */
      setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
        zone = normalizeZone2(zone, Settings2.defaultZone);
        if (zone.equals(this.zone)) {
          return this;
        } else if (!zone.isValid) {
          return DateTime2.invalid(unsupportedZone2(zone));
        } else {
          let newTS = this.ts;
          if (keepLocalTime || keepCalendarTime) {
            const offsetGuess = zone.offset(this.ts);
            const asObj = this.toObject();
            [newTS] = objToTS2(asObj, offsetGuess, zone);
          }
          return clone2(this, { ts: newTS, zone });
        }
      }
      /**
       * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
       * @param {Object} properties - the properties to set
       * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
       * @return {DateTime}
       */
      reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
        return clone2(this, { loc });
      }
      /**
       * "Set" the locale. Returns a newly-constructed DateTime.
       * Just a convenient alias for reconfigure({ locale })
       * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
       * @return {DateTime}
       */
      setLocale(locale) {
        return this.reconfigure({ locale });
      }
      /**
       * "Set" the values of specified units. Returns a newly-constructed DateTime.
       * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
       * @param {Object} values - a mapping of units to numbers
       * @example dt.set({ year: 2017 })
       * @example dt.set({ hour: 8, minute: 30 })
       * @example dt.set({ weekday: 5 })
       * @example dt.set({ year: 2005, ordinal: 234 })
       * @return {DateTime}
       */
      set(values) {
        if (!this.isValid)
          return this;
        const normalized = normalizeObject2(values, normalizeUnit2), settingWeekStuff = !isUndefined2(normalized.weekYear) || !isUndefined2(normalized.weekNumber) || !isUndefined2(normalized.weekday), containsOrdinal = !isUndefined2(normalized.ordinal), containsGregorYear = !isUndefined2(normalized.year), containsGregorMD = !isUndefined2(normalized.month) || !isUndefined2(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError2(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError2("Can't mix ordinal dates with month/day");
        }
        let mixed;
        if (settingWeekStuff) {
          mixed = weekToGregorian2({ ...gregorianToWeek2(this.c), ...normalized });
        } else if (!isUndefined2(normalized.ordinal)) {
          mixed = ordinalToGregorian2({ ...gregorianToOrdinal2(this.c), ...normalized });
        } else {
          mixed = { ...this.toObject(), ...normalized };
          if (isUndefined2(normalized.day)) {
            mixed.day = Math.min(daysInMonth2(mixed.year, mixed.month), mixed.day);
          }
        }
        const [ts, o] = objToTS2(mixed, this.o, this.zone);
        return clone2(this, { ts, o });
      }
      /**
       * Add a period of time to this DateTime and return the resulting DateTime
       *
       * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @example DateTime.now().plus(123) //~> in 123 milliseconds
       * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
       * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
       * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
       * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
       * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
       * @return {DateTime}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration2.fromDurationLike(duration);
        return clone2(this, adjustTime2(this, dur));
      }
      /**
       * Subtract a period of time to this DateTime and return the resulting DateTime
       * See {@link DateTime#plus}
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       @return {DateTime}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration2.fromDurationLike(duration).negate();
        return clone2(this, adjustTime2(this, dur));
      }
      /**
       * "Set" this DateTime to the beginning of a unit of time.
       * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
       * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
       * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
       * @return {DateTime}
       */
      startOf(unit) {
        if (!this.isValid)
          return this;
        const o = {}, normalizedUnit = Duration2.normalizeUnit(unit);
        switch (normalizedUnit) {
          case "years":
            o.month = 1;
          case "quarters":
          case "months":
            o.day = 1;
          case "weeks":
          case "days":
            o.hour = 0;
          case "hours":
            o.minute = 0;
          case "minutes":
            o.second = 0;
          case "seconds":
            o.millisecond = 0;
            break;
        }
        if (normalizedUnit === "weeks") {
          o.weekday = 1;
        }
        if (normalizedUnit === "quarters") {
          const q = Math.ceil(this.month / 3);
          o.month = (q - 1) * 3 + 1;
        }
        return this.set(o);
      }
      /**
       * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
       * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
       * @return {DateTime}
       */
      endOf(unit) {
        return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit).minus(1) : this;
      }
      // OUTPUT
      /**
       * Returns a string representation of this DateTime formatted according to the specified format string.
       * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
       * Defaults to en-US if no locale has been specified, regardless of the system's locale.
       * @param {string} fmt - the format string
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
       * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
       * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
       * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        return this.isValid ? Formatter2.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID2;
      }
      /**
       * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
       * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
       * of the DateTime in the assigned locale.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toLocaleString(); //=> 4/20/2017
       * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'
       * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
       * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
       * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
       * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
       * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT2, opts = {}) {
        return this.isValid ? Formatter2.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID2;
      }
      /**
       * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
       * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
       * @example DateTime.now().toLocaleParts(); //=> [
       *                                   //=>   { type: 'day', value: '25' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'month', value: '05' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'year', value: '1982' }
       *                                   //=> ]
       */
      toLocaleParts(opts = {}) {
        return this.isValid ? Formatter2.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
       * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
       * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
       * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
       * @return {string}
       */
      toISO({
        format = "extended",
        suppressSeconds = false,
        suppressMilliseconds = false,
        includeOffset = true,
        extendedZone = false
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        const ext = format === "extended";
        let c = toISODate2(this, ext);
        c += "T";
        c += toISOTime2(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
        return c;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's date component
       * @param {Object} opts - options
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
       * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
       * @return {string}
       */
      toISODate({ format = "extended" } = {}) {
        if (!this.isValid) {
          return null;
        }
        return toISODate2(this, format === "extended");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's week date
       * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
       * @return {string}
       */
      toISOWeekDate() {
        return toTechFormat2(this, "kkkk-'W'WW-c");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's time component
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
       * @return {string}
       */
      toISOTime({
        suppressMilliseconds = false,
        suppressSeconds = false,
        includeOffset = true,
        includePrefix = false,
        extendedZone = false,
        format = "extended"
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        let c = includePrefix ? "T" : "";
        return c + toISOTime2(
          this,
          format === "extended",
          suppressSeconds,
          suppressMilliseconds,
          includeOffset,
          extendedZone
        );
      }
      /**
       * Returns an RFC 2822-compatible string representation of this DateTime
       * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
       * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
       * @return {string}
       */
      toRFC2822() {
        return toTechFormat2(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
       * Specifically, the string conforms to RFC 1123.
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
       * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
       * @return {string}
       */
      toHTTP() {
        return toTechFormat2(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Date
       * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
       * @return {string}
       */
      toSQLDate() {
        if (!this.isValid) {
          return null;
        }
        return toISODate2(this, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Time
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc().toSQL() //=> '05:15:16.345'
       * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
       * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
       * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
       * @return {string}
       */
      toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
        let fmt = "HH:mm:ss.SSS";
        if (includeZone || includeOffset) {
          if (includeOffsetSpace) {
            fmt += " ";
          }
          if (includeZone) {
            fmt += "z";
          } else if (includeOffset) {
            fmt += "ZZ";
          }
        }
        return toTechFormat2(this, fmt, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
       * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
       * @return {string}
       */
      toSQL(opts = {}) {
        if (!this.isValid) {
          return null;
        }
        return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
      }
      /**
       * Returns a string representation of this DateTime appropriate for debugging
       * @return {string}
       */
      toString() {
        return this.isValid ? this.toISO() : INVALID2;
      }
      /**
       * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Returns the epoch milliseconds of this DateTime.
       * @return {number}
       */
      toMillis() {
        return this.isValid ? this.ts : NaN;
      }
      /**
       * Returns the epoch seconds of this DateTime.
       * @return {number}
       */
      toSeconds() {
        return this.isValid ? this.ts / 1e3 : NaN;
      }
      /**
       * Returns the epoch seconds (as a whole number) of this DateTime.
       * @return {number}
       */
      toUnixInteger() {
        return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
      }
      /**
       * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns a BSON serializable equivalent to this DateTime.
       * @return {Date}
       */
      toBSON() {
        return this.toJSDate();
      }
      /**
       * Returns a JavaScript object with this DateTime's year, month, day, and so on.
       * @param opts - options for generating the object
       * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
       * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
       * @return {Object}
       */
      toObject(opts = {}) {
        if (!this.isValid)
          return {};
        const base = { ...this.c };
        if (opts.includeConfig) {
          base.outputCalendar = this.outputCalendar;
          base.numberingSystem = this.loc.numberingSystem;
          base.locale = this.loc.locale;
        }
        return base;
      }
      /**
       * Returns a JavaScript Date equivalent to this DateTime.
       * @return {Date}
       */
      toJSDate() {
        return new Date(this.isValid ? this.ts : NaN);
      }
      // COMPARE
      /**
       * Return the difference between two DateTimes as a Duration.
       * @param {DateTime} otherDateTime - the DateTime to compare this one to
       * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example
       * var i1 = DateTime.fromISO('1982-05-25T09:45'),
       *     i2 = DateTime.fromISO('1983-10-14T10:30');
       * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
       * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
       * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
       * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
       * @return {Duration}
       */
      diff(otherDateTime, unit = "milliseconds", opts = {}) {
        if (!this.isValid || !otherDateTime.isValid) {
          return Duration2.invalid("created by diffing an invalid DateTime");
        }
        const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
        const units = maybeArray2(unit).map(Duration2.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff2(earlier, later, units, durOpts);
        return otherIsLater ? diffed.negate() : diffed;
      }
      /**
       * Return the difference between this DateTime and right now.
       * See {@link DateTime#diff}
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      diffNow(unit = "milliseconds", opts = {}) {
        return this.diff(DateTime2.now(), unit, opts);
      }
      /**
       * Return an Interval spanning between this DateTime and another DateTime
       * @param {DateTime} otherDateTime - the other end point of the Interval
       * @return {Interval}
       */
      until(otherDateTime) {
        return this.isValid ? Interval2.fromDateTimes(this, otherDateTime) : this;
      }
      /**
       * Return whether this DateTime is in the same unit of time as another DateTime.
       * Higher-order units must also be identical for this function to return `true`.
       * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
       * @param {DateTime} otherDateTime - the other DateTime
       * @param {string} unit - the unit of time to check sameness on
       * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
       * @return {boolean}
       */
      hasSame(otherDateTime, unit) {
        if (!this.isValid)
          return false;
        const inputMs = otherDateTime.valueOf();
        const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
        return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
      }
      /**
       * Equality check
       * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
       * To compare just the millisecond values, use `+dt1 === +dt2`.
       * @param {DateTime} other - the other DateTime
       * @return {boolean}
       */
      equals(other) {
        return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
      }
      /**
       * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
       * platform supports Intl.RelativeTimeFormat. Rounds down by default.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
       * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
       * @param {boolean} [options.round=true] - whether to round the numbers in the output.
       * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
       * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
       * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
       * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
       * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
       * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
       */
      toRelative(options = {}) {
        if (!this.isValid)
          return null;
        const base = options.base || DateTime2.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
        let units = ["years", "months", "days", "hours", "minutes", "seconds"];
        let unit = options.unit;
        if (Array.isArray(options.unit)) {
          units = options.unit;
          unit = void 0;
        }
        return diffRelative2(base, this.plus(padding), {
          ...options,
          numeric: "always",
          units,
          unit
        });
      }
      /**
       * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
       * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
       * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
       * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
       */
      toRelativeCalendar(options = {}) {
        if (!this.isValid)
          return null;
        return diffRelative2(options.base || DateTime2.fromObject({}, { zone: this.zone }), this, {
          ...options,
          numeric: "auto",
          units: ["years", "months", "days"],
          calendary: true
        });
      }
      /**
       * Return the min of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
       * @return {DateTime} the min DateTime, or undefined if called with no argument
       */
      static min(...dateTimes) {
        if (!dateTimes.every(DateTime2.isDateTime)) {
          throw new InvalidArgumentError2("min requires all arguments be DateTimes");
        }
        return bestBy2(dateTimes, (i) => i.valueOf(), Math.min);
      }
      /**
       * Return the max of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
       * @return {DateTime} the max DateTime, or undefined if called with no argument
       */
      static max(...dateTimes) {
        if (!dateTimes.every(DateTime2.isDateTime)) {
          throw new InvalidArgumentError2("max requires all arguments be DateTimes");
        }
        return bestBy2(dateTimes, (i) => i.valueOf(), Math.max);
      }
      // MISC
      /**
       * Explain how a string would be parsed by fromFormat()
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see description)
       * @param {Object} options - options taken by fromFormat()
       * @return {Object}
       */
      static fromFormatExplain(text, fmt, options = {}) {
        const { locale = null, numberingSystem = null } = options, localeToUse = Locale2.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        });
        return explainFromTokens2(localeToUse, text, fmt);
      }
      /**
       * @deprecated use fromFormatExplain instead
       */
      static fromStringExplain(text, fmt, options = {}) {
        return DateTime2.fromFormatExplain(text, fmt, options);
      }
      // FORMAT PRESETS
      /**
       * {@link DateTime#toLocaleString} format like 10/14/1983
       * @type {Object}
       */
      static get DATE_SHORT() {
        return DATE_SHORT2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED() {
        return DATE_MED2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED_WITH_WEEKDAY() {
        return DATE_MED_WITH_WEEKDAY2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983'
       * @type {Object}
       */
      static get DATE_FULL() {
        return DATE_FULL2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
       * @type {Object}
       */
      static get DATE_HUGE() {
        return DATE_HUGE2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_SIMPLE() {
        return TIME_SIMPLE2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SECONDS() {
        return TIME_WITH_SECONDS2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SHORT_OFFSET() {
        return TIME_WITH_SHORT_OFFSET2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_LONG_OFFSET() {
        return TIME_WITH_LONG_OFFSET2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_SIMPLE() {
        return TIME_24_SIMPLE2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SECONDS() {
        return TIME_24_WITH_SECONDS2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SHORT_OFFSET() {
        return TIME_24_WITH_SHORT_OFFSET2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_LONG_OFFSET() {
        return TIME_24_WITH_LONG_OFFSET2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT() {
        return DATETIME_SHORT2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT_WITH_SECONDS() {
        return DATETIME_SHORT_WITH_SECONDS2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED() {
        return DATETIME_MED2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_SECONDS() {
        return DATETIME_MED_WITH_SECONDS2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_WEEKDAY() {
        return DATETIME_MED_WITH_WEEKDAY2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL() {
        return DATETIME_FULL2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL_WITH_SECONDS() {
        return DATETIME_FULL_WITH_SECONDS2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE() {
        return DATETIME_HUGE2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE_WITH_SECONDS() {
        return DATETIME_HUGE_WITH_SECONDS2;
      }
    };
    function friendlyDateTime2(dateTimeish) {
      if (DateTime2.isDateTime(dateTimeish)) {
        return dateTimeish;
      } else if (dateTimeish && dateTimeish.valueOf && isNumber2(dateTimeish.valueOf())) {
        return DateTime2.fromJSDate(dateTimeish);
      } else if (dateTimeish && typeof dateTimeish === "object") {
        return DateTime2.fromObject(dateTimeish);
      } else {
        throw new InvalidArgumentError2(
          `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
        );
      }
    }
    var DEFAULT_QUERY_SETTINGS = {
      renderNullAs: "\\-",
      taskCompletionTracking: false,
      taskCompletionUseEmojiShorthand: false,
      taskCompletionText: "completion",
      taskCompletionDateFormat: "yyyy-MM-dd",
      recursiveSubTaskCompletion: false,
      warnOnEmptyResult: true,
      refreshEnabled: true,
      refreshInterval: 2500,
      defaultDateFormat: "MMMM dd, yyyy",
      defaultDateTimeFormat: "h:mm a - MMMM dd, yyyy",
      maxRecursiveRenderDepth: 4,
      tableIdColumnName: "File",
      tableGroupColumnName: "Group",
      showResultCount: true
    };
    var DEFAULT_EXPORT_SETTINGS = {
      allowHtml: true
    };
    ({
      ...DEFAULT_QUERY_SETTINGS,
      ...DEFAULT_EXPORT_SETTINGS,
      ...{
        inlineQueryPrefix: "=",
        inlineJsQueryPrefix: "$=",
        inlineQueriesInCodeblocks: true,
        enableInlineDataview: true,
        enableDataviewJs: false,
        enableInlineDataviewJs: false,
        prettyRenderInlineFields: true,
        prettyRenderInlineFieldsInLivePreview: true,
        dataviewJsKeyword: "dataviewjs"
      }
    });
    var Success = class {
      constructor(value) {
        __publicField(this, "value");
        __publicField(this, "successful");
        this.value = value;
        this.successful = true;
      }
      map(f2) {
        return new Success(f2(this.value));
      }
      flatMap(f2) {
        return f2(this.value);
      }
      mapErr(f2) {
        return this;
      }
      bimap(succ, _fail) {
        return this.map(succ);
      }
      orElse(_value) {
        return this.value;
      }
      cast() {
        return this;
      }
      orElseThrow(_message) {
        return this.value;
      }
    };
    var Failure = class {
      constructor(error) {
        __publicField(this, "error");
        __publicField(this, "successful");
        this.error = error;
        this.successful = false;
      }
      map(_f2) {
        return this;
      }
      flatMap(_f2) {
        return this;
      }
      mapErr(f2) {
        return new Failure(f2(this.error));
      }
      bimap(_succ, fail) {
        return this.mapErr(fail);
      }
      orElse(value) {
        return value;
      }
      cast() {
        return this;
      }
      orElseThrow(message) {
        if (message)
          throw new Error(message(this.error));
        else
          throw new Error("" + this.error);
      }
    };
    var Result;
    (function(Result2) {
      function success(value) {
        return new Success(value);
      }
      Result2.success = success;
      function failure(error) {
        return new Failure(error);
      }
      Result2.failure = failure;
      function flatMap2(first, second, f2) {
        if (first.successful) {
          if (second.successful)
            return f2(first.value, second.value);
          else
            return failure(second.error);
        } else {
          return failure(first.error);
        }
      }
      Result2.flatMap2 = flatMap2;
      function map2(first, second, f2) {
        return flatMap2(first, second, (a, b) => success(f2(a, b)));
      }
      Result2.map2 = map2;
    })(Result || (Result = {}));
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    var parsimmon_umd_min = { exports: {} };
    parsimmon_umd_min.exports;
    (function(module3, exports2) {
      !function(n3, t) {
        module3.exports = t();
      }("undefined" != typeof self ? self : commonjsGlobal, function() {
        return function(n3) {
          var t = {};
          function r(e) {
            if (t[e])
              return t[e].exports;
            var u = t[e] = { i: e, l: false, exports: {} };
            return n3[e].call(u.exports, u, u.exports, r), u.l = true, u.exports;
          }
          return r.m = n3, r.c = t, r.d = function(n4, t2, e) {
            r.o(n4, t2) || Object.defineProperty(n4, t2, { configurable: false, enumerable: true, get: e });
          }, r.r = function(n4) {
            Object.defineProperty(n4, "__esModule", { value: true });
          }, r.n = function(n4) {
            var t2 = n4 && n4.__esModule ? function() {
              return n4.default;
            } : function() {
              return n4;
            };
            return r.d(t2, "a", t2), t2;
          }, r.o = function(n4, t2) {
            return Object.prototype.hasOwnProperty.call(n4, t2);
          }, r.p = "", r(r.s = 0);
        }([function(n3, t, r) {
          function e(n4) {
            if (!(this instanceof e))
              return new e(n4);
            this._ = n4;
          }
          var u = e.prototype;
          function o(n4, t2) {
            for (var r2 = 0; r2 < n4; r2++)
              t2(r2);
          }
          function i(n4, t2, r2) {
            return function(n5, t3) {
              o(t3.length, function(r3) {
                n5(t3[r3], r3, t3);
              });
            }(function(r3, e2, u2) {
              t2 = n4(t2, r3, e2, u2);
            }, r2), t2;
          }
          function a(n4, t2) {
            return i(function(t3, r2, e2, u2) {
              return t3.concat([n4(r2, e2, u2)]);
            }, [], t2);
          }
          function f2(n4, t2) {
            var r2 = { v: 0, buf: t2 };
            return o(n4, function() {
              var n5;
              r2 = { v: r2.v << 1 | (n5 = r2.buf, n5[0] >> 7), buf: function(n6) {
                var t3 = i(function(n7, t4, r3, e2) {
                  return n7.concat(r3 === e2.length - 1 ? Buffer.from([t4, 0]).readUInt16BE(0) : e2.readUInt16BE(r3));
                }, [], n6);
                return Buffer.from(a(function(n7) {
                  return (n7 << 1 & 65535) >> 8;
                }, t3));
              }(r2.buf) };
            }), r2;
          }
          function c() {
            return "undefined" != typeof Buffer;
          }
          function s3() {
            if (!c())
              throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
          }
          function l3(n4) {
            s3();
            var t2 = i(function(n5, t3) {
              return n5 + t3;
            }, 0, n4);
            if (t2 % 8 != 0)
              throw new Error("The bits [" + n4.join(", ") + "] add up to " + t2 + " which is not an even number of bytes; the total should be divisible by 8");
            var r2, u2 = t2 / 8, o2 = (r2 = function(n5) {
              return n5 > 48;
            }, i(function(n5, t3) {
              return n5 || (r2(t3) ? t3 : n5);
            }, null, n4));
            if (o2)
              throw new Error(o2 + " bit range requested exceeds 48 bit (6 byte) Number max.");
            return new e(function(t3, r3) {
              var e2 = u2 + r3;
              return e2 > t3.length ? x(r3, u2.toString() + " bytes") : b(e2, i(function(n5, t4) {
                var r4 = f2(t4, n5.buf);
                return { coll: n5.coll.concat(r4.v), buf: r4.buf };
              }, { coll: [], buf: t3.slice(r3, e2) }, n4).coll);
            });
          }
          function h(n4, t2) {
            return new e(function(r2, e2) {
              return s3(), e2 + t2 > r2.length ? x(e2, t2 + " bytes for " + n4) : b(e2 + t2, r2.slice(e2, e2 + t2));
            });
          }
          function p(n4, t2) {
            if ("number" != typeof (r2 = t2) || Math.floor(r2) !== r2 || t2 < 0 || t2 > 6)
              throw new Error(n4 + " requires integer length in range [0, 6].");
            var r2;
          }
          function d(n4) {
            return p("uintBE", n4), h("uintBE(" + n4 + ")", n4).map(function(t2) {
              return t2.readUIntBE(0, n4);
            });
          }
          function v(n4) {
            return p("uintLE", n4), h("uintLE(" + n4 + ")", n4).map(function(t2) {
              return t2.readUIntLE(0, n4);
            });
          }
          function g(n4) {
            return p("intBE", n4), h("intBE(" + n4 + ")", n4).map(function(t2) {
              return t2.readIntBE(0, n4);
            });
          }
          function m(n4) {
            return p("intLE", n4), h("intLE(" + n4 + ")", n4).map(function(t2) {
              return t2.readIntLE(0, n4);
            });
          }
          function y(n4) {
            return n4 instanceof e;
          }
          function E(n4) {
            return "[object Array]" === {}.toString.call(n4);
          }
          function w(n4) {
            return c() && Buffer.isBuffer(n4);
          }
          function b(n4, t2) {
            return { status: true, index: n4, value: t2, furthest: -1, expected: [] };
          }
          function x(n4, t2) {
            return E(t2) || (t2 = [t2]), { status: false, index: -1, value: null, furthest: n4, expected: t2 };
          }
          function B(n4, t2) {
            if (!t2)
              return n4;
            if (n4.furthest > t2.furthest)
              return n4;
            var r2 = n4.furthest === t2.furthest ? function(n5, t3) {
              if (function() {
                if (void 0 !== e._supportsSet)
                  return e._supportsSet;
                var n6 = "undefined" != typeof Set;
                return e._supportsSet = n6, n6;
              }() && Array.from) {
                for (var r3 = new Set(n5), u2 = 0; u2 < t3.length; u2++)
                  r3.add(t3[u2]);
                var o2 = Array.from(r3);
                return o2.sort(), o2;
              }
              for (var i2 = {}, a2 = 0; a2 < n5.length; a2++)
                i2[n5[a2]] = true;
              for (var f3 = 0; f3 < t3.length; f3++)
                i2[t3[f3]] = true;
              var c2 = [];
              for (var s4 in i2)
                ({}).hasOwnProperty.call(i2, s4) && c2.push(s4);
              return c2.sort(), c2;
            }(n4.expected, t2.expected) : t2.expected;
            return { status: n4.status, index: n4.index, value: n4.value, furthest: t2.furthest, expected: r2 };
          }
          var j = {};
          function S(n4, t2) {
            if (w(n4))
              return { offset: t2, line: -1, column: -1 };
            n4 in j || (j[n4] = {});
            for (var r2 = j[n4], e2 = 0, u2 = 0, o2 = 0, i2 = t2; i2 >= 0; ) {
              if (i2 in r2) {
                e2 = r2[i2].line, 0 === o2 && (o2 = r2[i2].lineStart);
                break;
              }
              ("\n" === n4.charAt(i2) || "\r" === n4.charAt(i2) && "\n" !== n4.charAt(i2 + 1)) && (u2++, 0 === o2 && (o2 = i2 + 1)), i2--;
            }
            var a2 = e2 + u2, f3 = t2 - o2;
            return r2[t2] = { line: a2, lineStart: o2 }, { offset: t2, line: a2 + 1, column: f3 + 1 };
          }
          function _(n4) {
            if (!y(n4))
              throw new Error("not a parser: " + n4);
          }
          function L(n4, t2) {
            return "string" == typeof n4 ? n4.charAt(t2) : n4[t2];
          }
          function O(n4) {
            if ("number" != typeof n4)
              throw new Error("not a number: " + n4);
          }
          function k(n4) {
            if ("function" != typeof n4)
              throw new Error("not a function: " + n4);
          }
          function P(n4) {
            if ("string" != typeof n4)
              throw new Error("not a string: " + n4);
          }
          var q = 2, A = 3, I = 8, F = 5 * I, M = 4 * I, z = "  ";
          function R(n4, t2) {
            return new Array(t2 + 1).join(n4);
          }
          function U(n4, t2, r2) {
            var e2 = t2 - n4.length;
            return e2 <= 0 ? n4 : R(r2, e2) + n4;
          }
          function W(n4, t2, r2, e2) {
            return { from: n4 - t2 > 0 ? n4 - t2 : 0, to: n4 + r2 > e2 ? e2 : n4 + r2 };
          }
          function D(n4, t2) {
            var r2, e2, u2, o2, f3, c2 = t2.index, s4 = c2.offset, l4 = 1;
            if (s4 === n4.length)
              return "Got the end of the input";
            if (w(n4)) {
              var h2 = s4 - s4 % I, p2 = s4 - h2, d2 = W(h2, F, M + I, n4.length), v2 = a(function(n5) {
                return a(function(n6) {
                  return U(n6.toString(16), 2, "0");
                }, n5);
              }, function(n5, t3) {
                var r3 = n5.length, e3 = [], u3 = 0;
                if (r3 <= t3)
                  return [n5.slice()];
                for (var o3 = 0; o3 < r3; o3++)
                  e3[u3] || e3.push([]), e3[u3].push(n5[o3]), (o3 + 1) % t3 == 0 && u3++;
                return e3;
              }(n4.slice(d2.from, d2.to).toJSON().data, I));
              o2 = function(n5) {
                return 0 === n5.from && 1 === n5.to ? { from: n5.from, to: n5.to } : { from: n5.from / I, to: Math.floor(n5.to / I) };
              }(d2), e2 = h2 / I, r2 = 3 * p2, p2 >= 4 && (r2 += 1), l4 = 2, u2 = a(function(n5) {
                return n5.length <= 4 ? n5.join(" ") : n5.slice(0, 4).join(" ") + "  " + n5.slice(4).join(" ");
              }, v2), (f3 = (8 * (o2.to > 0 ? o2.to - 1 : o2.to)).toString(16).length) < 2 && (f3 = 2);
            } else {
              var g2 = n4.split(/\r\n|[\n\r\u2028\u2029]/);
              r2 = c2.column - 1, e2 = c2.line - 1, o2 = W(e2, q, A, g2.length), u2 = g2.slice(o2.from, o2.to), f3 = o2.to.toString().length;
            }
            var m2 = e2 - o2.from;
            return w(n4) && (f3 = (8 * (o2.to > 0 ? o2.to - 1 : o2.to)).toString(16).length) < 2 && (f3 = 2), i(function(t3, e3, u3) {
              var i2, a2 = u3 === m2, c3 = a2 ? "> " : z;
              return i2 = w(n4) ? U((8 * (o2.from + u3)).toString(16), f3, "0") : U((o2.from + u3 + 1).toString(), f3, " "), [].concat(t3, [c3 + i2 + " | " + e3], a2 ? [z + R(" ", f3) + " | " + U("", r2, " ") + R("^", l4)] : []);
            }, [], u2).join("\n");
          }
          function N(n4, t2) {
            return ["\n", "-- PARSING FAILED " + R("-", 50), "\n\n", D(n4, t2), "\n\n", (r2 = t2.expected, 1 === r2.length ? "Expected:\n\n" + r2[0] : "Expected one of the following: \n\n" + r2.join(", ")), "\n"].join("");
            var r2;
          }
          function G(n4) {
            return void 0 !== n4.flags ? n4.flags : [n4.global ? "g" : "", n4.ignoreCase ? "i" : "", n4.multiline ? "m" : "", n4.unicode ? "u" : "", n4.sticky ? "y" : ""].join("");
          }
          function C() {
            for (var n4 = [].slice.call(arguments), t2 = n4.length, r2 = 0; r2 < t2; r2 += 1)
              _(n4[r2]);
            return e(function(r3, e2) {
              for (var u2, o2 = new Array(t2), i2 = 0; i2 < t2; i2 += 1) {
                if (!(u2 = B(n4[i2]._(r3, e2), u2)).status)
                  return u2;
                o2[i2] = u2.value, e2 = u2.index;
              }
              return B(b(e2, o2), u2);
            });
          }
          function J() {
            var n4 = [].slice.call(arguments);
            if (0 === n4.length)
              throw new Error("seqMap needs at least one argument");
            var t2 = n4.pop();
            return k(t2), C.apply(null, n4).map(function(n5) {
              return t2.apply(null, n5);
            });
          }
          function T2() {
            var n4 = [].slice.call(arguments), t2 = n4.length;
            if (0 === t2)
              return Y("zero alternates");
            for (var r2 = 0; r2 < t2; r2 += 1)
              _(n4[r2]);
            return e(function(t3, r3) {
              for (var e2, u2 = 0; u2 < n4.length; u2 += 1)
                if ((e2 = B(n4[u2]._(t3, r3), e2)).status)
                  return e2;
              return e2;
            });
          }
          function V(n4, t2) {
            return H(n4, t2).or(X([]));
          }
          function H(n4, t2) {
            return _(n4), _(t2), J(n4, t2.then(n4).many(), function(n5, t3) {
              return [n5].concat(t3);
            });
          }
          function K(n4) {
            P(n4);
            var t2 = "'" + n4 + "'";
            return e(function(r2, e2) {
              var u2 = e2 + n4.length, o2 = r2.slice(e2, u2);
              return o2 === n4 ? b(u2, o2) : x(e2, t2);
            });
          }
          function Q(n4, t2) {
            !function(n5) {
              if (!(n5 instanceof RegExp))
                throw new Error("not a regexp: " + n5);
              for (var t3 = G(n5), r3 = 0; r3 < t3.length; r3++) {
                var e2 = t3.charAt(r3);
                if ("i" !== e2 && "m" !== e2 && "u" !== e2 && "s" !== e2)
                  throw new Error('unsupported regexp flag "' + e2 + '": ' + n5);
              }
            }(n4), arguments.length >= 2 ? O(t2) : t2 = 0;
            var r2 = function(n5) {
              return RegExp("^(?:" + n5.source + ")", G(n5));
            }(n4), u2 = "" + n4;
            return e(function(n5, e2) {
              var o2 = r2.exec(n5.slice(e2));
              if (o2) {
                if (0 <= t2 && t2 <= o2.length) {
                  var i2 = o2[0], a2 = o2[t2];
                  return b(e2 + i2.length, a2);
                }
                return x(e2, "valid match group (0 to " + o2.length + ") in " + u2);
              }
              return x(e2, u2);
            });
          }
          function X(n4) {
            return e(function(t2, r2) {
              return b(r2, n4);
            });
          }
          function Y(n4) {
            return e(function(t2, r2) {
              return x(r2, n4);
            });
          }
          function Z(n4) {
            if (y(n4))
              return e(function(t2, r2) {
                var e2 = n4._(t2, r2);
                return e2.index = r2, e2.value = "", e2;
              });
            if ("string" == typeof n4)
              return Z(K(n4));
            if (n4 instanceof RegExp)
              return Z(Q(n4));
            throw new Error("not a string, regexp, or parser: " + n4);
          }
          function $(n4) {
            return _(n4), e(function(t2, r2) {
              var e2 = n4._(t2, r2), u2 = t2.slice(r2, e2.index);
              return e2.status ? x(r2, 'not "' + u2 + '"') : b(r2, null);
            });
          }
          function nn(n4) {
            return k(n4), e(function(t2, r2) {
              var e2 = L(t2, r2);
              return r2 < t2.length && n4(e2) ? b(r2 + 1, e2) : x(r2, "a character/byte matching " + n4);
            });
          }
          function tn(n4, t2) {
            arguments.length < 2 && (t2 = n4, n4 = void 0);
            var r2 = e(function(n5, e2) {
              return r2._ = t2()._, r2._(n5, e2);
            });
            return n4 ? r2.desc(n4) : r2;
          }
          function rn() {
            return Y("fantasy-land/empty");
          }
          u.parse = function(n4) {
            if ("string" != typeof n4 && !w(n4))
              throw new Error(".parse must be called with a string or Buffer as its argument");
            var t2, r2 = this.skip(an)._(n4, 0);
            return t2 = r2.status ? { status: true, value: r2.value } : { status: false, index: S(n4, r2.furthest), expected: r2.expected }, delete j[n4], t2;
          }, u.tryParse = function(n4) {
            var t2 = this.parse(n4);
            if (t2.status)
              return t2.value;
            var r2 = N(n4, t2), e2 = new Error(r2);
            throw e2.type = "ParsimmonError", e2.result = t2, e2;
          }, u.assert = function(n4, t2) {
            return this.chain(function(r2) {
              return n4(r2) ? X(r2) : Y(t2);
            });
          }, u.or = function(n4) {
            return T2(this, n4);
          }, u.trim = function(n4) {
            return this.wrap(n4, n4);
          }, u.wrap = function(n4, t2) {
            return J(n4, this, t2, function(n5, t3) {
              return t3;
            });
          }, u.thru = function(n4) {
            return n4(this);
          }, u.then = function(n4) {
            return _(n4), C(this, n4).map(function(n5) {
              return n5[1];
            });
          }, u.many = function() {
            var n4 = this;
            return e(function(t2, r2) {
              for (var e2 = [], u2 = void 0; ; ) {
                if (!(u2 = B(n4._(t2, r2), u2)).status)
                  return B(b(r2, e2), u2);
                if (r2 === u2.index)
                  throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
                r2 = u2.index, e2.push(u2.value);
              }
            });
          }, u.tieWith = function(n4) {
            return P(n4), this.map(function(t2) {
              if (function(n5) {
                if (!E(n5))
                  throw new Error("not an array: " + n5);
              }(t2), t2.length) {
                P(t2[0]);
                for (var r2 = t2[0], e2 = 1; e2 < t2.length; e2++)
                  P(t2[e2]), r2 += n4 + t2[e2];
                return r2;
              }
              return "";
            });
          }, u.tie = function() {
            return this.tieWith("");
          }, u.times = function(n4, t2) {
            var r2 = this;
            return arguments.length < 2 && (t2 = n4), O(n4), O(t2), e(function(e2, u2) {
              for (var o2 = [], i2 = void 0, a2 = void 0, f3 = 0; f3 < n4; f3 += 1) {
                if (a2 = B(i2 = r2._(e2, u2), a2), !i2.status)
                  return a2;
                u2 = i2.index, o2.push(i2.value);
              }
              for (; f3 < t2 && (a2 = B(i2 = r2._(e2, u2), a2), i2.status); f3 += 1)
                u2 = i2.index, o2.push(i2.value);
              return B(b(u2, o2), a2);
            });
          }, u.result = function(n4) {
            return this.map(function() {
              return n4;
            });
          }, u.atMost = function(n4) {
            return this.times(0, n4);
          }, u.atLeast = function(n4) {
            return J(this.times(n4), this.many(), function(n5, t2) {
              return n5.concat(t2);
            });
          }, u.map = function(n4) {
            k(n4);
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2._(r2, e2);
              return u2.status ? B(b(u2.index, n4(u2.value)), u2) : u2;
            });
          }, u.contramap = function(n4) {
            k(n4);
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2.parse(n4(r2.slice(e2)));
              return u2.status ? b(e2 + r2.length, u2.value) : u2;
            });
          }, u.promap = function(n4, t2) {
            return k(n4), k(t2), this.contramap(n4).map(t2);
          }, u.skip = function(n4) {
            return C(this, n4).map(function(n5) {
              return n5[0];
            });
          }, u.mark = function() {
            return J(en, this, en, function(n4, t2, r2) {
              return { start: n4, value: t2, end: r2 };
            });
          }, u.node = function(n4) {
            return J(en, this, en, function(t2, r2, e2) {
              return { name: n4, value: r2, start: t2, end: e2 };
            });
          }, u.sepBy = function(n4) {
            return V(this, n4);
          }, u.sepBy1 = function(n4) {
            return H(this, n4);
          }, u.lookahead = function(n4) {
            return this.skip(Z(n4));
          }, u.notFollowedBy = function(n4) {
            return this.skip($(n4));
          }, u.desc = function(n4) {
            E(n4) || (n4 = [n4]);
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2._(r2, e2);
              return u2.status || (u2.expected = n4), u2;
            });
          }, u.fallback = function(n4) {
            return this.or(X(n4));
          }, u.ap = function(n4) {
            return J(n4, this, function(n5, t2) {
              return n5(t2);
            });
          }, u.chain = function(n4) {
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2._(r2, e2);
              return u2.status ? B(n4(u2.value)._(r2, u2.index), u2) : u2;
            });
          }, u.concat = u.or, u.empty = rn, u.of = X, u["fantasy-land/ap"] = u.ap, u["fantasy-land/chain"] = u.chain, u["fantasy-land/concat"] = u.concat, u["fantasy-land/empty"] = u.empty, u["fantasy-land/of"] = u.of, u["fantasy-land/map"] = u.map;
          var en = e(function(n4, t2) {
            return b(t2, S(n4, t2));
          }), un = e(function(n4, t2) {
            return t2 >= n4.length ? x(t2, "any character/byte") : b(t2 + 1, L(n4, t2));
          }), on = e(function(n4, t2) {
            return b(n4.length, n4.slice(t2));
          }), an = e(function(n4, t2) {
            return t2 < n4.length ? x(t2, "EOF") : b(t2, null);
          }), fn = Q(/[0-9]/).desc("a digit"), cn = Q(/[0-9]*/).desc("optional digits"), sn = Q(/[a-z]/i).desc("a letter"), ln = Q(/[a-z]*/i).desc("optional letters"), hn = Q(/\s*/).desc("optional whitespace"), pn = Q(/\s+/).desc("whitespace"), dn = K("\r"), vn = K("\n"), gn = K("\r\n"), mn = T2(gn, vn, dn).desc("newline"), yn = T2(mn, an);
          e.all = on, e.alt = T2, e.any = un, e.cr = dn, e.createLanguage = function(n4) {
            var t2 = {};
            for (var r2 in n4)
              ({}).hasOwnProperty.call(n4, r2) && function(r3) {
                t2[r3] = tn(function() {
                  return n4[r3](t2);
                });
              }(r2);
            return t2;
          }, e.crlf = gn, e.custom = function(n4) {
            return e(n4(b, x));
          }, e.digit = fn, e.digits = cn, e.empty = rn, e.end = yn, e.eof = an, e.fail = Y, e.formatError = N, e.index = en, e.isParser = y, e.lazy = tn, e.letter = sn, e.letters = ln, e.lf = vn, e.lookahead = Z, e.makeFailure = x, e.makeSuccess = b, e.newline = mn, e.noneOf = function(n4) {
            return nn(function(t2) {
              return n4.indexOf(t2) < 0;
            }).desc("none of '" + n4 + "'");
          }, e.notFollowedBy = $, e.of = X, e.oneOf = function(n4) {
            for (var t2 = n4.split(""), r2 = 0; r2 < t2.length; r2++)
              t2[r2] = "'" + t2[r2] + "'";
            return nn(function(t3) {
              return n4.indexOf(t3) >= 0;
            }).desc(t2);
          }, e.optWhitespace = hn, e.Parser = e, e.range = function(n4, t2) {
            return nn(function(r2) {
              return n4 <= r2 && r2 <= t2;
            }).desc(n4 + "-" + t2);
          }, e.regex = Q, e.regexp = Q, e.sepBy = V, e.sepBy1 = H, e.seq = C, e.seqMap = J, e.seqObj = function() {
            for (var n4, t2 = {}, r2 = 0, u2 = (n4 = arguments, Array.prototype.slice.call(n4)), o2 = u2.length, i2 = 0; i2 < o2; i2 += 1) {
              var a2 = u2[i2];
              if (!y(a2)) {
                if (E(a2) && 2 === a2.length && "string" == typeof a2[0] && y(a2[1])) {
                  var f3 = a2[0];
                  if (Object.prototype.hasOwnProperty.call(t2, f3))
                    throw new Error("seqObj: duplicate key " + f3);
                  t2[f3] = true, r2++;
                  continue;
                }
                throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
              }
            }
            if (0 === r2)
              throw new Error("seqObj expects at least one named parser, found zero");
            return e(function(n5, t3) {
              for (var r3, e2 = {}, i3 = 0; i3 < o2; i3 += 1) {
                var a3, f4;
                if (E(u2[i3]) ? (a3 = u2[i3][0], f4 = u2[i3][1]) : (a3 = null, f4 = u2[i3]), !(r3 = B(f4._(n5, t3), r3)).status)
                  return r3;
                a3 && (e2[a3] = r3.value), t3 = r3.index;
              }
              return B(b(t3, e2), r3);
            });
          }, e.string = K, e.succeed = X, e.takeWhile = function(n4) {
            return k(n4), e(function(t2, r2) {
              for (var e2 = r2; e2 < t2.length && n4(L(t2, e2)); )
                e2++;
              return b(e2, t2.slice(r2, e2));
            });
          }, e.test = nn, e.whitespace = pn, e["fantasy-land/empty"] = rn, e["fantasy-land/of"] = X, e.Binary = { bitSeq: l3, bitSeqObj: function(n4) {
            s3();
            var t2 = {}, r2 = 0, e2 = a(function(n5) {
              if (E(n5)) {
                var e3 = n5;
                if (2 !== e3.length)
                  throw new Error("[" + e3.join(", ") + "] should be length 2, got length " + e3.length);
                if (P(e3[0]), O(e3[1]), Object.prototype.hasOwnProperty.call(t2, e3[0]))
                  throw new Error("duplicate key in bitSeqObj: " + e3[0]);
                return t2[e3[0]] = true, r2++, e3;
              }
              return O(n5), [null, n5];
            }, n4);
            if (r2 < 1)
              throw new Error("bitSeqObj expects at least one named pair, got [" + n4.join(", ") + "]");
            var u2 = a(function(n5) {
              return n5[0];
            }, e2);
            return l3(a(function(n5) {
              return n5[1];
            }, e2)).map(function(n5) {
              return i(function(n6, t3) {
                return null !== t3[0] && (n6[t3[0]] = t3[1]), n6;
              }, {}, a(function(t3, r3) {
                return [t3, n5[r3]];
              }, u2));
            });
          }, byte: function(n4) {
            if (s3(), O(n4), n4 > 255)
              throw new Error("Value specified to byte constructor (" + n4 + "=0x" + n4.toString(16) + ") is larger in value than a single byte.");
            var t2 = (n4 > 15 ? "0x" : "0x0") + n4.toString(16);
            return e(function(r2, e2) {
              var u2 = L(r2, e2);
              return u2 === n4 ? b(e2 + 1, u2) : x(e2, t2);
            });
          }, buffer: function(n4) {
            return h("buffer", n4).map(function(n5) {
              return Buffer.from(n5);
            });
          }, encodedString: function(n4, t2) {
            return h("string", t2).map(function(t3) {
              return t3.toString(n4);
            });
          }, uintBE: d, uint8BE: d(1), uint16BE: d(2), uint32BE: d(4), uintLE: v, uint8LE: v(1), uint16LE: v(2), uint32LE: v(4), intBE: g, int8BE: g(1), int16BE: g(2), int32BE: g(4), intLE: m, int8LE: m(1), int16LE: m(2), int32LE: m(4), floatBE: h("floatBE", 4).map(function(n4) {
            return n4.readFloatBE(0);
          }), floatLE: h("floatLE", 4).map(function(n4) {
            return n4.readFloatLE(0);
          }), doubleBE: h("doubleBE", 8).map(function(n4) {
            return n4.readDoubleBE(0);
          }), doubleLE: h("doubleLE", 8).map(function(n4) {
            return n4.readDoubleLE(0);
          }) }, n3.exports = e;
        }]);
      });
    })(parsimmon_umd_min, parsimmon_umd_min.exports);
    var parsimmon_umd_minExports = parsimmon_umd_min.exports;
    var emojiRegex = () => {
      return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
    };
    function normalizeDuration(dur) {
      if (dur === void 0 || dur === null)
        return dur;
      return dur.shiftToAll().normalize();
    }
    function getFileTitle(path) {
      if (path.includes("/"))
        path = path.substring(path.lastIndexOf("/") + 1);
      if (path.endsWith(".md"))
        path = path.substring(0, path.length - 3);
      return path;
    }
    parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_minExports.regex(/[0-9\p{Letter}_-]+/u).map((str2) => str2.toLocaleLowerCase()), parsimmon_umd_minExports.whitespace.map((_) => "-"), parsimmon_umd_minExports.any.map((_) => "")).many().map((result) => result.join(""));
    var HEADER_CANONICALIZER = parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_minExports.regex(/[0-9\p{Letter}_-]+/u), parsimmon_umd_minExports.whitespace.map((_) => " "), parsimmon_umd_minExports.any.map((_) => " ")).many().map((result) => {
      return result.join("").split(/\s+/).join(" ").trim();
    });
    function normalizeHeaderForLink(header) {
      return HEADER_CANONICALIZER.tryParse(header);
    }
    function renderMinimalDuration(dur) {
      dur = normalizeDuration(dur);
      dur = Duration2.fromObject(Object.fromEntries(Object.entries(dur.toObject()).filter(([, quantity]) => quantity != 0)));
      return dur.toHuman();
    }
    var Values;
    (function(Values2) {
      function toString2(field, setting = DEFAULT_QUERY_SETTINGS, recursive = false) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return setting.renderNullAs;
        switch (wrapped.type) {
          case "null":
            return setting.renderNullAs;
          case "string":
            return wrapped.value;
          case "number":
          case "boolean":
            return "" + wrapped.value;
          case "html":
            return wrapped.value.outerHTML;
          case "widget":
            return wrapped.value.markdown();
          case "link":
            return wrapped.value.markdown();
          case "function":
            return "<function>";
          case "array":
            let result = "";
            if (recursive)
              result += "[";
            result += wrapped.value.map((f2) => toString2(f2, setting, true)).join(", ");
            if (recursive)
              result += "]";
            return result;
          case "object":
            return "{ " + Object.entries(wrapped.value).map((e) => e[0] + ": " + toString2(e[1], setting, true)).join(", ") + " }";
          case "date":
            if (wrapped.value.second == 0 && wrapped.value.hour == 0 && wrapped.value.minute == 0) {
              return wrapped.value.toFormat(setting.defaultDateFormat);
            }
            return wrapped.value.toFormat(setting.defaultDateTimeFormat);
          case "duration":
            return renderMinimalDuration(wrapped.value);
        }
      }
      Values2.toString = toString2;
      function wrapValue(val) {
        if (isNull2(val))
          return { type: "null", value: val };
        else if (isNumber3(val))
          return { type: "number", value: val };
        else if (isString3(val))
          return { type: "string", value: val };
        else if (isBoolean2(val))
          return { type: "boolean", value: val };
        else if (isDuration(val))
          return { type: "duration", value: val };
        else if (isDate3(val))
          return { type: "date", value: val };
        else if (isWidget(val))
          return { type: "widget", value: val };
        else if (isArray(val))
          return { type: "array", value: val };
        else if (isLink(val))
          return { type: "link", value: val };
        else if (isFunction(val))
          return { type: "function", value: val };
        else if (isHtml(val))
          return { type: "html", value: val };
        else if (isObject2(val))
          return { type: "object", value: val };
        else
          return void 0;
      }
      Values2.wrapValue = wrapValue;
      function mapLeaves(val, func) {
        if (isObject2(val)) {
          let result = {};
          for (let [key, value] of Object.entries(val))
            result[key] = mapLeaves(value, func);
          return result;
        } else if (isArray(val)) {
          let result = [];
          for (let value of val)
            result.push(mapLeaves(value, func));
          return result;
        } else {
          return func(val);
        }
      }
      Values2.mapLeaves = mapLeaves;
      function compareValue(val1, val2, linkNormalizer) {
        var _a2, _b2;
        if (val1 === void 0)
          val1 = null;
        if (val2 === void 0)
          val2 = null;
        if (val1 === null && val2 === null)
          return 0;
        else if (val1 === null)
          return -1;
        else if (val2 === null)
          return 1;
        let wrap1 = wrapValue(val1);
        let wrap2 = wrapValue(val2);
        if (wrap1 === void 0 && wrap2 === void 0)
          return 0;
        else if (wrap1 === void 0)
          return -1;
        else if (wrap2 === void 0)
          return 1;
        if (wrap1.type != wrap2.type)
          return wrap1.type.localeCompare(wrap2.type);
        if (wrap1.value === wrap2.value)
          return 0;
        switch (wrap1.type) {
          case "string":
            return wrap1.value.localeCompare(wrap2.value);
          case "number":
            if (wrap1.value < wrap2.value)
              return -1;
            else if (wrap1.value == wrap2.value)
              return 0;
            return 1;
          case "null":
            return 0;
          case "boolean":
            if (wrap1.value == wrap2.value)
              return 0;
            else
              return wrap1.value ? 1 : -1;
          case "link":
            let link1 = wrap1.value;
            let link2 = wrap2.value;
            let normalize = linkNormalizer != null ? linkNormalizer : (x) => x;
            let pathCompare = normalize(link1.path).localeCompare(normalize(link2.path));
            if (pathCompare != 0)
              return pathCompare;
            let typeCompare = link1.type.localeCompare(link2.type);
            if (typeCompare != 0)
              return typeCompare;
            if (link1.subpath && !link2.subpath)
              return 1;
            if (!link1.subpath && link2.subpath)
              return -1;
            if (!link1.subpath && !link2.subpath)
              return 0;
            return ((_a2 = link1.subpath) != null ? _a2 : "").localeCompare((_b2 = link2.subpath) != null ? _b2 : "");
          case "date":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "duration":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "array":
            let f1 = wrap1.value;
            let f2 = wrap2.value;
            for (let index = 0; index < Math.min(f1.length, f2.length); index++) {
              let comp = compareValue(f1[index], f2[index]);
              if (comp != 0)
                return comp;
            }
            return f1.length - f2.length;
          case "object":
            let o1 = wrap1.value;
            let o2 = wrap2.value;
            let k1 = Array.from(Object.keys(o1));
            let k2 = Array.from(Object.keys(o2));
            k1.sort();
            k2.sort();
            let keyCompare = compareValue(k1, k2);
            if (keyCompare != 0)
              return keyCompare;
            for (let key of k1) {
              let comp = compareValue(o1[key], o2[key]);
              if (comp != 0)
                return comp;
            }
            return 0;
          case "widget":
          case "html":
          case "function":
            return 0;
        }
      }
      Values2.compareValue = compareValue;
      function typeOf(val) {
        var _a2;
        return (_a2 = wrapValue(val)) == null ? void 0 : _a2.type;
      }
      Values2.typeOf = typeOf;
      function isTruthy(field) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return false;
        switch (wrapped.type) {
          case "number":
            return wrapped.value != 0;
          case "string":
            return wrapped.value.length > 0;
          case "boolean":
            return wrapped.value;
          case "link":
            return !!wrapped.value.path;
          case "date":
            return wrapped.value.toMillis() != 0;
          case "duration":
            return wrapped.value.as("seconds") != 0;
          case "object":
            return Object.keys(wrapped.value).length > 0;
          case "array":
            return wrapped.value.length > 0;
          case "null":
            return false;
          case "html":
          case "widget":
          case "function":
            return true;
        }
      }
      Values2.isTruthy = isTruthy;
      function deepCopy(field) {
        if (field === null || field === void 0)
          return field;
        if (Values2.isArray(field)) {
          return [].concat(field.map((v) => deepCopy(v)));
        } else if (Values2.isObject(field)) {
          let result = {};
          for (let [key, value] of Object.entries(field))
            result[key] = deepCopy(value);
          return result;
        } else {
          return field;
        }
      }
      Values2.deepCopy = deepCopy;
      function isString3(val) {
        return typeof val == "string";
      }
      Values2.isString = isString3;
      function isNumber3(val) {
        return typeof val == "number";
      }
      Values2.isNumber = isNumber3;
      function isDate3(val) {
        return val instanceof DateTime2;
      }
      Values2.isDate = isDate3;
      function isDuration(val) {
        return val instanceof Duration2;
      }
      Values2.isDuration = isDuration;
      function isNull2(val) {
        return val === null || val === void 0;
      }
      Values2.isNull = isNull2;
      function isArray(val) {
        return Array.isArray(val);
      }
      Values2.isArray = isArray;
      function isBoolean2(val) {
        return typeof val === "boolean";
      }
      Values2.isBoolean = isBoolean2;
      function isLink(val) {
        return val instanceof Link;
      }
      Values2.isLink = isLink;
      function isWidget(val) {
        return val instanceof Widget;
      }
      Values2.isWidget = isWidget;
      function isHtml(val) {
        if (typeof HTMLElement !== "undefined") {
          return val instanceof HTMLElement;
        } else {
          return false;
        }
      }
      Values2.isHtml = isHtml;
      function isObject2(val) {
        return typeof val == "object" && !isHtml(val) && !isWidget(val) && !isArray(val) && !isDuration(val) && !isDate3(val) && !isLink(val) && val !== void 0 && !isNull2(val);
      }
      Values2.isObject = isObject2;
      function isFunction(val) {
        return typeof val == "function";
      }
      Values2.isFunction = isFunction;
    })(Values || (Values = {}));
    var Groupings;
    (function(Groupings2) {
      function isElementGroup(entry) {
        return Values.isObject(entry) && Object.keys(entry).length == 2 && "key" in entry && "rows" in entry;
      }
      Groupings2.isElementGroup = isElementGroup;
      function isGrouping(entry) {
        for (let element of entry)
          if (!isElementGroup(element))
            return false;
        return true;
      }
      Groupings2.isGrouping = isGrouping;
      function count(elements) {
        if (isGrouping(elements)) {
          let result = 0;
          for (let subgroup of elements)
            result += count(subgroup.rows);
          return result;
        } else {
          return elements.length;
        }
      }
      Groupings2.count = count;
    })(Groupings || (Groupings = {}));
    var Link = class {
      constructor(fields) {
        /** The file path this link points to. */
        __publicField(this, "path");
        /** The display name associated with the link. */
        __publicField(this, "display");
        /** The block ID or header this link points to within a file, if relevant. */
        __publicField(this, "subpath");
        /** Is this link an embedded link (!)? */
        __publicField(this, "embed");
        /** The type of this link, which determines what 'subpath' refers to, if anything. */
        __publicField(this, "type");
        Object.assign(this, fields);
      }
      /** Create a link to a specific file. */
      static file(path, embed = false, display) {
        return new Link({
          path,
          embed,
          display,
          subpath: void 0,
          type: "file"
        });
      }
      static infer(linkpath, embed = false, display) {
        if (linkpath.includes("#^")) {
          let split = linkpath.split("#^");
          return Link.block(split[0], split[1], embed, display);
        } else if (linkpath.includes("#")) {
          let split = linkpath.split("#");
          return Link.header(split[0], split[1], embed, display);
        } else
          return Link.file(linkpath, embed, display);
      }
      /** Create a link to a specific file and header in that file. */
      static header(path, header, embed, display) {
        return new Link({
          path,
          embed,
          display,
          subpath: normalizeHeaderForLink(header),
          type: "header"
        });
      }
      /** Create a link to a specific file and block in that file. */
      static block(path, blockId, embed, display) {
        return new Link({
          path,
          embed,
          display,
          subpath: blockId,
          type: "block"
        });
      }
      static fromObject(object) {
        return new Link(object);
      }
      /** Checks for link equality (i.e., that the links are pointing to the same exact location). */
      equals(other) {
        if (other == void 0 || other == null)
          return false;
        return this.path == other.path && this.type == other.type && this.subpath == other.subpath;
      }
      /** Convert this link to it's markdown representation. */
      toString() {
        return this.markdown();
      }
      /** Convert this link to a raw object which is serialization-friendly. */
      toObject() {
        return { path: this.path, type: this.type, subpath: this.subpath, display: this.display, embed: this.embed };
      }
      /** Update this link with a new path. */
      //@ts-ignore; error appeared after updating Obsidian to 0.15.4; it also updated other packages but didn't say which
      withPath(path) {
        return new Link(Object.assign({}, this, { path }));
      }
      /** Return a new link which points to the same location but with a new display value. */
      withDisplay(display) {
        return new Link(Object.assign({}, this, { display }));
      }
      /** Convert a file link into a link to a specific header. */
      withHeader(header) {
        return Link.header(this.path, header, this.embed, this.display);
      }
      /** Convert any link into a link to its file. */
      toFile() {
        return Link.file(this.path, this.embed, this.display);
      }
      /** Convert this link into an embedded link. */
      toEmbed() {
        if (this.embed) {
          return this;
        } else {
          let link = new Link(this);
          link.embed = true;
          return link;
        }
      }
      /** Convert this link into a non-embedded link. */
      fromEmbed() {
        if (!this.embed) {
          return this;
        } else {
          let link = new Link(this);
          link.embed = false;
          return link;
        }
      }
      /** Convert this link to markdown so it can be rendered. */
      markdown() {
        let result = (this.embed ? "!" : "") + "[[" + this.obsidianLink();
        if (this.display) {
          result += "|" + this.display;
        } else {
          result += "|" + getFileTitle(this.path);
          if (this.type == "header" || this.type == "block")
            result += " > " + this.subpath;
        }
        result += "]]";
        return result;
      }
      /** Convert the inner part of the link to something that Obsidian can open / understand. */
      obsidianLink() {
        var _a2, _b2;
        const escaped = this.path.replaceAll("|", "\\|");
        if (this.type == "header")
          return escaped + "#" + ((_a2 = this.subpath) == null ? void 0 : _a2.replaceAll("|", "\\|"));
        if (this.type == "block")
          return escaped + "#^" + ((_b2 = this.subpath) == null ? void 0 : _b2.replaceAll("|", "\\|"));
        else
          return escaped;
      }
      /** The stripped name of the file this link points to. */
      fileName() {
        return getFileTitle(this.path).replace(".md", "");
      }
    };
    var Widget = class {
      constructor($widget) {
        __publicField(this, "$widget");
        this.$widget = $widget;
      }
    };
    var ListPairWidget = class extends Widget {
      constructor(key, value) {
        super("dataview:list-pair");
        __publicField(this, "key");
        __publicField(this, "value");
        this.key = key;
        this.value = value;
      }
      markdown() {
        return `${Values.toString(this.key)}: ${Values.toString(this.value)}`;
      }
    };
    var ExternalLinkWidget = class extends Widget {
      constructor(url, display) {
        super("dataview:external-link");
        __publicField(this, "url");
        __publicField(this, "display");
        this.url = url;
        this.display = display;
      }
      markdown() {
        var _a2;
        return `[${(_a2 = this.display) != null ? _a2 : this.url}](${this.url})`;
      }
    };
    var Widgets;
    (function(Widgets2) {
      function listPair(key, value) {
        return new ListPairWidget(key, value);
      }
      Widgets2.listPair = listPair;
      function externalLink(url, display) {
        return new ExternalLinkWidget(url, display);
      }
      Widgets2.externalLink = externalLink;
      function isListPair(widget) {
        return widget.$widget === "dataview:list-pair";
      }
      Widgets2.isListPair = isListPair;
      function isExternalLink(widget) {
        return widget.$widget === "dataview:external-link";
      }
      Widgets2.isExternalLink = isExternalLink;
      function isBuiltin(widget) {
        return isListPair(widget) || isExternalLink(widget);
      }
      Widgets2.isBuiltin = isBuiltin;
    })(Widgets || (Widgets = {}));
    var Fields;
    (function(Fields2) {
      function variable(name) {
        return { type: "variable", name };
      }
      Fields2.variable = variable;
      function literal(value) {
        return { type: "literal", value };
      }
      Fields2.literal = literal;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Fields2.binaryOp = binaryOp;
      function index(obj, index2) {
        return { type: "index", object: obj, index: index2 };
      }
      Fields2.index = index;
      function indexVariable(name) {
        let parts = name.split(".");
        let result = Fields2.variable(parts[0]);
        for (let index2 = 1; index2 < parts.length; index2++) {
          result = Fields2.index(result, Fields2.literal(parts[index2]));
        }
        return result;
      }
      Fields2.indexVariable = indexVariable;
      function lambda(args, value) {
        return { type: "lambda", arguments: args, value };
      }
      Fields2.lambda = lambda;
      function func(func2, args) {
        return { type: "function", func: func2, arguments: args };
      }
      Fields2.func = func;
      function list(values) {
        return { type: "list", values };
      }
      Fields2.list = list;
      function object(values) {
        return { type: "object", values };
      }
      Fields2.object = object;
      function negate(child) {
        return { type: "negated", child };
      }
      Fields2.negate = negate;
      function isCompareOp(op) {
        return op == "<=" || op == "<" || op == ">" || op == ">=" || op == "!=" || op == "=";
      }
      Fields2.isCompareOp = isCompareOp;
      Fields2.NULL = Fields2.literal(null);
    })(Fields || (Fields = {}));
    var Sources;
    (function(Sources2) {
      function tag(tag2) {
        return { type: "tag", tag: tag2 };
      }
      Sources2.tag = tag;
      function csv(path) {
        return { type: "csv", path };
      }
      Sources2.csv = csv;
      function folder(prefix) {
        return { type: "folder", folder: prefix };
      }
      Sources2.folder = folder;
      function link(file, incoming) {
        return { type: "link", file, direction: incoming ? "incoming" : "outgoing" };
      }
      Sources2.link = link;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Sources2.binaryOp = binaryOp;
      function and(left, right) {
        return { type: "binaryop", left, op: "&", right };
      }
      Sources2.and = and;
      function or(left, right) {
        return { type: "binaryop", left, op: "|", right };
      }
      Sources2.or = or;
      function negate(child) {
        return { type: "negate", child };
      }
      Sources2.negate = negate;
      function empty() {
        return { type: "empty" };
      }
      Sources2.empty = empty;
    })(Sources || (Sources = {}));
    var EMOJI_REGEX = new RegExp(emojiRegex(), "");
    var DURATION_TYPES = {
      year: Duration2.fromObject({ years: 1 }),
      years: Duration2.fromObject({ years: 1 }),
      yr: Duration2.fromObject({ years: 1 }),
      yrs: Duration2.fromObject({ years: 1 }),
      month: Duration2.fromObject({ months: 1 }),
      months: Duration2.fromObject({ months: 1 }),
      mo: Duration2.fromObject({ months: 1 }),
      mos: Duration2.fromObject({ months: 1 }),
      week: Duration2.fromObject({ weeks: 1 }),
      weeks: Duration2.fromObject({ weeks: 1 }),
      wk: Duration2.fromObject({ weeks: 1 }),
      wks: Duration2.fromObject({ weeks: 1 }),
      w: Duration2.fromObject({ weeks: 1 }),
      day: Duration2.fromObject({ days: 1 }),
      days: Duration2.fromObject({ days: 1 }),
      d: Duration2.fromObject({ days: 1 }),
      hour: Duration2.fromObject({ hours: 1 }),
      hours: Duration2.fromObject({ hours: 1 }),
      hr: Duration2.fromObject({ hours: 1 }),
      hrs: Duration2.fromObject({ hours: 1 }),
      h: Duration2.fromObject({ hours: 1 }),
      minute: Duration2.fromObject({ minutes: 1 }),
      minutes: Duration2.fromObject({ minutes: 1 }),
      min: Duration2.fromObject({ minutes: 1 }),
      mins: Duration2.fromObject({ minutes: 1 }),
      m: Duration2.fromObject({ minutes: 1 }),
      second: Duration2.fromObject({ seconds: 1 }),
      seconds: Duration2.fromObject({ seconds: 1 }),
      sec: Duration2.fromObject({ seconds: 1 }),
      secs: Duration2.fromObject({ seconds: 1 }),
      s: Duration2.fromObject({ seconds: 1 })
    };
    var DATE_SHORTHANDS = {
      now: () => DateTime2.local(),
      today: () => DateTime2.local().startOf("day"),
      yesterday: () => DateTime2.local().startOf("day").minus(Duration2.fromObject({ days: 1 })),
      tomorrow: () => DateTime2.local().startOf("day").plus(Duration2.fromObject({ days: 1 })),
      sow: () => DateTime2.local().startOf("week"),
      "start-of-week": () => DateTime2.local().startOf("week"),
      eow: () => DateTime2.local().endOf("week"),
      "end-of-week": () => DateTime2.local().endOf("week"),
      soy: () => DateTime2.local().startOf("year"),
      "start-of-year": () => DateTime2.local().startOf("year"),
      eoy: () => DateTime2.local().endOf("year"),
      "end-of-year": () => DateTime2.local().endOf("year"),
      som: () => DateTime2.local().startOf("month"),
      "start-of-month": () => DateTime2.local().startOf("month"),
      eom: () => DateTime2.local().endOf("month"),
      "end-of-month": () => DateTime2.local().endOf("month")
    };
    var KEYWORDS = ["FROM", "WHERE", "LIMIT", "GROUP", "FLATTEN"];
    function splitOnUnescapedPipe(link) {
      let pipe = -1;
      while ((pipe = link.indexOf("|", pipe + 1)) >= 0) {
        if (pipe > 0 && link[pipe - 1] == "\\")
          continue;
        return [link.substring(0, pipe).replace(/\\\|/g, "|"), link.substring(pipe + 1)];
      }
      return [link.replace(/\\\|/g, "|"), void 0];
    }
    function parseInnerLink(rawlink) {
      let [link, display] = splitOnUnescapedPipe(rawlink);
      return Link.infer(link, false, display);
    }
    function createBinaryParser(child, sep, combine) {
      return parsimmon_umd_minExports.seqMap(child, parsimmon_umd_minExports.seq(parsimmon_umd_minExports.optWhitespace, sep, parsimmon_umd_minExports.optWhitespace, child).many(), (first, rest) => {
        if (rest.length == 0)
          return first;
        let node = combine(first, rest[0][1], rest[0][3]);
        for (let index = 1; index < rest.length; index++) {
          node = combine(node, rest[index][1], rest[index][3]);
        }
        return node;
      });
    }
    function chainOpt(base, ...funcs) {
      return parsimmon_umd_minExports.custom((success, failure) => {
        return (input, i) => {
          let result = base._(input, i);
          if (!result.status)
            return result;
          for (let func of funcs) {
            let next = func(result.value)._(input, result.index);
            if (!next.status)
              return result;
            result = next;
          }
          return result;
        };
      });
    }
    var EXPRESSION = parsimmon_umd_minExports.createLanguage({
      // A floating point number; the decimal point is optional.
      number: (q) => parsimmon_umd_minExports.regexp(/-?[0-9]+(\.[0-9]+)?/).map((str2) => Number.parseFloat(str2)).desc("number"),
      // A quote-surrounded string which supports escape characters ('\').
      string: (q) => parsimmon_umd_minExports.string('"').then(parsimmon_umd_minExports.alt(q.escapeCharacter, parsimmon_umd_minExports.noneOf('"\\')).atLeast(0).map((chars) => chars.join(""))).skip(parsimmon_umd_minExports.string('"')).desc("string"),
      escapeCharacter: (_) => parsimmon_umd_minExports.string("\\").then(parsimmon_umd_minExports.any).map((escaped) => {
        if (escaped === '"')
          return '"';
        if (escaped === "\\")
          return "\\";
        else
          return "\\" + escaped;
      }),
      // A boolean true/false value.
      bool: (_) => parsimmon_umd_minExports.regexp(/true|false|True|False/).map((str2) => str2.toLowerCase() == "true").desc("boolean ('true' or 'false')"),
      // A tag of the form '#stuff/hello-there'.
      tag: (_) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("#"), parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/[^\u2000-\u206F\u2E00-\u2E7F'!"#$%&()*+,.:;<=>?@^`{|}~\[\]\\\s]/).desc("text")).many(), (start, rest) => start + rest.join("")).desc("tag ('#hello/stuff')"),
      // A variable identifier, which is alphanumeric and must start with a letter or... emoji.
      identifier: (_) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/\p{Letter}/u), parsimmon_umd_minExports.regexp(EMOJI_REGEX).desc("text")), parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/[0-9\p{Letter}_-]/u), parsimmon_umd_minExports.regexp(EMOJI_REGEX).desc("text")).many(), (first, rest) => first + rest.join("")).desc("variable identifier"),
      // An Obsidian link of the form [[<link>]].
      link: (_) => parsimmon_umd_minExports.regexp(/\[\[([^\[\]]*?)\]\]/u, 1).map((linkInner) => parseInnerLink(linkInner)).desc("file link"),
      // An embeddable link which can start with '!'. This overlaps with the normal negation operator, so it is only
      // provided for metadata parsing.
      embedLink: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("!").atMost(1), q.link, (p, l3) => {
        if (p.length > 0)
          l3.embed = true;
        return l3;
      }).desc("file link"),
      // Binary plus or minus operator.
      binaryPlusMinus: (_) => parsimmon_umd_minExports.regexp(/\+|-/).map((str2) => str2).desc("'+' or '-'"),
      // Binary times or divide operator.
      binaryMulDiv: (_) => parsimmon_umd_minExports.regexp(/\*|\/|%/).map((str2) => str2).desc("'*' or '/' or '%'"),
      // Binary comparison operator.
      binaryCompareOp: (_) => parsimmon_umd_minExports.regexp(/>=|<=|!=|>|<|=/).map((str2) => str2).desc("'>=' or '<=' or '!=' or '=' or '>' or '<'"),
      // Binary boolean combination operator.
      binaryBooleanOp: (_) => parsimmon_umd_minExports.regexp(/and|or|&|\|/i).map((str2) => {
        if (str2.toLowerCase() == "and")
          return "&";
        else if (str2.toLowerCase() == "or")
          return "|";
        else
          return str2;
      }).desc("'and' or 'or'"),
      // A date which can be YYYY-MM[-DDTHH:mm:ss].
      rootDate: (_) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/\d{4}/), parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.regexp(/\d{2}/), (year, _2, month) => {
        return DateTime2.fromObject({ year: Number.parseInt(year), month: Number.parseInt(month) });
      }).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      dateShorthand: (_) => parsimmon_umd_minExports.alt(...Object.keys(DATE_SHORTHANDS).sort((a, b) => b.length - a.length).map(parsimmon_umd_minExports.string)),
      date: (q) => chainOpt(q.rootDate, (ym) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.regexp(/\d{2}/), (_, day) => ym.set({ day: Number.parseInt(day) })), (ymd) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("T"), parsimmon_umd_minExports.regexp(/\d{2}/), (_, hour) => ymd.set({ hour: Number.parseInt(hour) })), (ymdh) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string(":"), parsimmon_umd_minExports.regexp(/\d{2}/), (_, minute) => ymdh.set({ minute: Number.parseInt(minute) })), (ymdhm) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string(":"), parsimmon_umd_minExports.regexp(/\d{2}/), (_, second) => ymdhm.set({ second: Number.parseInt(second) })), (ymdhms) => parsimmon_umd_minExports.alt(
        parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("."), parsimmon_umd_minExports.regexp(/\d{3}/), (_, millisecond) => ymdhms.set({ millisecond: Number.parseInt(millisecond) })),
        parsimmon_umd_minExports.succeed(ymdhms)
        // pass
      ), (dt) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("+").or(parsimmon_umd_minExports.string("-")), parsimmon_umd_minExports.regexp(/\d{1,2}(:\d{2})?/), (pm, hr) => dt.setZone("UTC" + pm + hr, { keepLocalTime: true })), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("Z"), () => dt.setZone("utc", { keepLocalTime: true })), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("["), parsimmon_umd_minExports.regexp(/[0-9A-Za-z+-\/]+/u), parsimmon_umd_minExports.string("]"), (_a2, zone, _b2) => dt.setZone(zone, { keepLocalTime: true })))).assert((dt) => dt.isValid, "valid date").desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      // A date, plus various shorthand times of day it could be.
      datePlus: (q) => parsimmon_umd_minExports.alt(q.dateShorthand.map((d) => DATE_SHORTHANDS[d]()), q.date).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS] or in shorthand"),
      // A duration of time.
      durationType: (_) => parsimmon_umd_minExports.alt(...Object.keys(DURATION_TYPES).sort((a, b) => b.length - a.length).map(parsimmon_umd_minExports.string)),
      duration: (q) => parsimmon_umd_minExports.seqMap(q.number, parsimmon_umd_minExports.optWhitespace, q.durationType, (count, _, t) => DURATION_TYPES[t].mapUnits((x) => x * count)).sepBy1(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace).or(parsimmon_umd_minExports.optWhitespace)).map((durations) => durations.reduce((p, c) => p.plus(c))).desc("duration like 4hr2min"),
      // A raw null value.
      rawNull: (_) => parsimmon_umd_minExports.string("null"),
      // Source parsing.
      tagSource: (q) => q.tag.map((tag) => Sources.tag(tag)),
      csvSource: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("csv(").skip(parsimmon_umd_minExports.optWhitespace), q.string, parsimmon_umd_minExports.string(")"), (_1, path, _2) => Sources.csv(path)),
      linkIncomingSource: (q) => q.link.map((link) => Sources.link(link.path, true)),
      linkOutgoingSource: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("outgoing(").skip(parsimmon_umd_minExports.optWhitespace), q.link, parsimmon_umd_minExports.string(")"), (_1, link, _2) => Sources.link(link.path, false)),
      folderSource: (q) => q.string.map((str2) => Sources.folder(str2)),
      parensSource: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q.source, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_1, _2, field, _3, _4) => field),
      negateSource: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.alt(parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.string("!")), q.atomSource, (_, source) => Sources.negate(source)),
      atomSource: (q) => parsimmon_umd_minExports.alt(q.parensSource, q.negateSource, q.linkOutgoingSource, q.linkIncomingSource, q.folderSource, q.tagSource, q.csvSource),
      binaryOpSource: (q) => createBinaryParser(q.atomSource, q.binaryBooleanOp.map((s3) => s3), Sources.binaryOp),
      source: (q) => q.binaryOpSource,
      // Field parsing.
      variableField: (q) => q.identifier.chain((r) => {
        if (KEYWORDS.includes(r.toUpperCase())) {
          return parsimmon_umd_minExports.fail("Variable fields cannot be a keyword (" + KEYWORDS.join(" or ") + ")");
        } else {
          return parsimmon_umd_minExports.succeed(Fields.variable(r));
        }
      }).desc("variable"),
      numberField: (q) => q.number.map((val) => Fields.literal(val)).desc("number"),
      stringField: (q) => q.string.map((val) => Fields.literal(val)).desc("string"),
      boolField: (q) => q.bool.map((val) => Fields.literal(val)).desc("boolean"),
      dateField: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("date("), parsimmon_umd_minExports.optWhitespace, q.datePlus, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (prefix, _1, date, _2, postfix) => Fields.literal(date)).desc("date"),
      durationField: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("dur("), parsimmon_umd_minExports.optWhitespace, q.duration, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (prefix, _1, dur, _2, postfix) => Fields.literal(dur)).desc("duration"),
      nullField: (q) => q.rawNull.map((_) => Fields.NULL),
      linkField: (q) => q.link.map((f2) => Fields.literal(f2)),
      listField: (q) => q.field.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("[").skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.optWhitespace.then(parsimmon_umd_minExports.string("]"))).map((l3) => Fields.list(l3)).desc("list ('[1, 2, 3]')"),
      objectField: (q) => parsimmon_umd_minExports.seqMap(q.identifier.or(q.string), parsimmon_umd_minExports.string(":").trim(parsimmon_umd_minExports.optWhitespace), q.field, (name, _sep, value) => {
        return { name, value };
      }).sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("{").skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.optWhitespace.then(parsimmon_umd_minExports.string("}"))).map((vals) => {
        let res = {};
        for (let entry of vals)
          res[entry.name] = entry.value;
        return Fields.object(res);
      }).desc("object ('{ a: 1, b: 2 }')"),
      atomInlineField: (q) => parsimmon_umd_minExports.alt(q.date, q.duration.map((d) => normalizeDuration(d)), q.string, q.tag, q.embedLink, q.bool, q.number, q.rawNull),
      inlineFieldList: (q) => q.atomInlineField.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace).lookahead(q.atomInlineField)),
      inlineField: (q) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.seqMap(q.atomInlineField, parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace), q.inlineFieldList, (f2, _s, l3) => [f2].concat(l3)), q.atomInlineField),
      atomField: (q) => parsimmon_umd_minExports.alt(
        // Place embed links above negated fields as they are the special parser case '![[thing]]' and are generally unambiguous.
        q.embedLink.map((l3) => Fields.literal(l3)),
        q.negatedField,
        q.linkField,
        q.listField,
        q.objectField,
        q.lambdaField,
        q.parensField,
        q.boolField,
        q.numberField,
        q.stringField,
        q.dateField,
        q.durationField,
        q.nullField,
        q.variableField
      ),
      indexField: (q) => parsimmon_umd_minExports.seqMap(q.atomField, parsimmon_umd_minExports.alt(q.dotPostfix, q.indexPostfix, q.functionPostfix).many(), (obj, postfixes) => {
        let result = obj;
        for (let post of postfixes) {
          switch (post.type) {
            case "dot":
              result = Fields.index(result, Fields.literal(post.field));
              break;
            case "index":
              result = Fields.index(result, post.field);
              break;
            case "function":
              result = Fields.func(result, post.fields);
              break;
          }
        }
        return result;
      }),
      negatedField: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("!"), q.indexField, (_, field) => Fields.negate(field)).desc("negated field"),
      parensField: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q.field, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_1, _2, field, _3, _4) => field),
      lambdaField: (q) => parsimmon_umd_minExports.seqMap(q.identifier.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("(").trim(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.string(")").trim(parsimmon_umd_minExports.optWhitespace)), parsimmon_umd_minExports.string("=>").trim(parsimmon_umd_minExports.optWhitespace), q.field, (ident, _ignore, value) => {
        return { type: "lambda", arguments: ident, value };
      }),
      dotPostfix: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("."), q.identifier, (_, field) => {
        return { type: "dot", field };
      }),
      indexPostfix: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("["), parsimmon_umd_minExports.optWhitespace, q.field, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string("]"), (_, _2, field, _3, _4) => {
        return { type: "index", field };
      }),
      functionPostfix: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q.field.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_, _1, fields, _2, _3) => {
        return { type: "function", fields };
      }),
      // The precedence hierarchy of operators - multiply/divide, add/subtract, compare, and then boolean operations.
      binaryMulDivField: (q) => createBinaryParser(q.indexField, q.binaryMulDiv, Fields.binaryOp),
      binaryPlusMinusField: (q) => createBinaryParser(q.binaryMulDivField, q.binaryPlusMinus, Fields.binaryOp),
      binaryCompareField: (q) => createBinaryParser(q.binaryPlusMinusField, q.binaryCompareOp, Fields.binaryOp),
      binaryBooleanField: (q) => createBinaryParser(q.binaryCompareField, q.binaryBooleanOp, Fields.binaryOp),
      binaryOpField: (q) => q.binaryBooleanField,
      field: (q) => q.binaryOpField
    });
    function parseField(text) {
      try {
        return Result.success(EXPRESSION.field.tryParse(text));
      } catch (error) {
        return Result.failure("" + error);
      }
    }
    var QueryFields;
    (function(QueryFields2) {
      function named(name, field) {
        return { name, field };
      }
      QueryFields2.named = named;
      function sortBy(field, dir) {
        return { field, direction: dir };
      }
      QueryFields2.sortBy = sortBy;
    })(QueryFields || (QueryFields = {}));
    function captureRaw(base) {
      return parsimmon_umd_minExports.custom((success, failure) => {
        return (input, i) => {
          let result = base._(input, i);
          if (!result.status)
            return result;
          return Object.assign({}, result, { value: [result.value, input.substring(i, result.index)] });
        };
      });
    }
    function stripNewlines(text) {
      return text.split(/[\r\n]+/).map((t) => t.trim()).join("");
    }
    function precededByWhitespaceIfNotEof(if_eof, parser) {
      return parsimmon_umd_minExports.eof.map(if_eof).or(parsimmon_umd_minExports.whitespace.then(parser));
    }
    var QUERY_LANGUAGE = parsimmon_umd_minExports.createLanguage({
      // Simple atom parsing, like words, identifiers, numbers.
      queryType: (q) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/TABLE|LIST|TASK|CALENDAR/i)).map((str2) => str2.toLowerCase()).desc("query type ('TABLE', 'LIST', 'TASK', or 'CALENDAR')"),
      explicitNamedField: (q) => parsimmon_umd_minExports.seqMap(EXPRESSION.field.skip(parsimmon_umd_minExports.whitespace), parsimmon_umd_minExports.regexp(/AS/i).skip(parsimmon_umd_minExports.whitespace), EXPRESSION.identifier.or(EXPRESSION.string), (field, _as, ident) => QueryFields.named(ident, field)),
      comment: () => parsimmon_umd_minExports.Parser((input, i) => {
        let line = input.substring(i);
        if (!line.startsWith("//"))
          return parsimmon_umd_minExports.makeFailure(i, "Not a comment");
        line = line.split("\n")[0];
        let comment = line.substring(2).trim();
        return parsimmon_umd_minExports.makeSuccess(i + line.length, comment);
      }),
      namedField: (q) => parsimmon_umd_minExports.alt(q.explicitNamedField, captureRaw(EXPRESSION.field).map(([value, text]) => QueryFields.named(stripNewlines(text), value))),
      sortField: (q) => parsimmon_umd_minExports.seqMap(EXPRESSION.field.skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.regexp(/ASCENDING|DESCENDING|ASC|DESC/i).atMost(1), (field, dir) => {
        let direction = dir.length == 0 ? "ascending" : dir[0].toLowerCase();
        if (direction == "desc")
          direction = "descending";
        if (direction == "asc")
          direction = "ascending";
        return {
          field,
          direction
        };
      }),
      headerClause: (q) => q.queryType.chain((type2) => {
        switch (type2) {
          case "table": {
            return precededByWhitespaceIfNotEof(() => ({ type: type2, fields: [], showId: true }), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_minExports.optWhitespace).atMost(1), parsimmon_umd_minExports.sepBy(q.namedField, parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), (withoutId, fields) => {
              return { type: type2, fields, showId: withoutId.length == 0 };
            }));
          }
          case "list":
            return precededByWhitespaceIfNotEof(() => ({ type: type2, format: void 0, showId: true }), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_minExports.optWhitespace).atMost(1), EXPRESSION.field.atMost(1), (withoutId, format) => {
              return {
                type: type2,
                format: format.length == 1 ? format[0] : void 0,
                showId: withoutId.length == 0
              };
            }));
          case "task":
            return parsimmon_umd_minExports.succeed({ type: type2 });
          case "calendar":
            return parsimmon_umd_minExports.whitespace.then(parsimmon_umd_minExports.seqMap(q.namedField, (field) => {
              return {
                type: type2,
                showId: true,
                field
              };
            }));
          default:
            return parsimmon_umd_minExports.fail(`Unrecognized query type '${type2}'`);
        }
      }).desc("TABLE or LIST or TASK or CALENDAR"),
      fromClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/FROM/i), parsimmon_umd_minExports.whitespace, EXPRESSION.source, (_1, _2, source) => source),
      whereClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WHERE/i), parsimmon_umd_minExports.whitespace, EXPRESSION.field, (where, _, field) => {
        return { type: "where", clause: field };
      }).desc("WHERE <expression>"),
      sortByClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/SORT/i), parsimmon_umd_minExports.whitespace, q.sortField.sepBy1(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), (sort, _1, fields) => {
        return { type: "sort", fields };
      }).desc("SORT field [ASC/DESC]"),
      limitClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/LIMIT/i), parsimmon_umd_minExports.whitespace, EXPRESSION.field, (limit, _1, field) => {
        return { type: "limit", amount: field };
      }).desc("LIMIT <value>"),
      flattenClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/FLATTEN/i).skip(parsimmon_umd_minExports.whitespace), q.namedField, (_, field) => {
        return { type: "flatten", field };
      }).desc("FLATTEN <value> [AS <name>]"),
      groupByClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/GROUP BY/i).skip(parsimmon_umd_minExports.whitespace), q.namedField, (_, field) => {
        return { type: "group", field };
      }).desc("GROUP BY <value> [AS <name>]"),
      // Full query parsing.
      clause: (q) => parsimmon_umd_minExports.alt(q.fromClause, q.whereClause, q.sortByClause, q.limitClause, q.groupByClause, q.flattenClause),
      query: (q) => parsimmon_umd_minExports.seqMap(q.headerClause.trim(optionalWhitespaceOrComment), q.fromClause.trim(optionalWhitespaceOrComment).atMost(1), q.clause.trim(optionalWhitespaceOrComment).many(), (header, from, clauses) => {
        return {
          header,
          source: from.length == 0 ? Sources.folder("") : from[0],
          operations: clauses,
          settings: DEFAULT_QUERY_SETTINGS
        };
      })
    });
    var optionalWhitespaceOrComment = parsimmon_umd_minExports.alt(parsimmon_umd_minExports.whitespace, QUERY_LANGUAGE.comment).many().map((arr) => arr.join(""));
    var getAPI2 = (app) => {
      var _a2;
      if (app)
        return (_a2 = app.plugins.plugins.dataview) == null ? void 0 : _a2.api;
      else
        return window.DataviewAPI;
    };
    var isPluginEnabled = (app) => app.plugins.enabledPlugins.has("dataview");
    exports.DATE_SHORTHANDS = DATE_SHORTHANDS;
    exports.DURATION_TYPES = DURATION_TYPES;
    exports.EXPRESSION = EXPRESSION;
    exports.KEYWORDS = KEYWORDS;
    exports.QUERY_LANGUAGE = QUERY_LANGUAGE;
    exports.getAPI = getAPI2;
    exports.isPluginEnabled = isPluginEnabled;
    exports.parseField = parseField;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BlockLinkPlus
});
module.exports = __toCommonJS(main_exports);
var import_obsidian23 = require("obsidian");

// src/types/index.ts
var DEFAULT_SETTINGS = {
  mult_line_handle: 0 /* oneline */,
  // Default: treat multi-line selection as single block
  alias_type: 0 /* Default */,
  // Default: no alias text for block links
  enable_right_click_block: true,
  enable_right_click_embed: true,
  enable_right_click_url: false,
  alias_length: 20,
  enable_prefix: false,
  // Default: no prefix for block IDs
  id_prefix: "",
  // Custom prefix for block IDs (empty by default)
  id_length: 4,
  // Default block ID length in characters
  heading_id_newline: false,
  enable_block_notification: true,
  enable_embed_notification: true,
  enable_url_notification: true,
  // File Outliner View (v2)
  fileOutlinerEnabledFolders: [],
  fileOutlinerEnabledFiles: [],
  fileOutlinerHideSystemLine: true,
  fileOutlinerViewEnabled: true,
  fileOutlinerDragAndDropEnabled: true,
  fileOutlinerZoomEnabled: true,
  fileOutlinerEmphasisLineEnabled: true,
  fileOutlinerDebugLogging: false,
  fileOutlinerChildrenOnSplit: "keep",
  fileOutlinerPasteMultiline: "split",
  fileOutlinerBackspaceWithChildren: "merge",
  fileOutlinerEditorContextMenuEnabled: true,
  fileOutlinerEditorContextMenuAllowedPlugins: [],
  fileOutlinerEditorCommandBridgeEnabled: true,
  fileOutlinerEditorCommandAllowedPlugins: ["core"],
  // blp-view (Query/View) guardrails
  blpViewAllowMaterialize: true,
  blpViewMaxSourceFiles: 0,
  blpViewMaxResults: 0,
  blpViewShowDiagnostics: false,
  // Inline edit (default: enabled, but file-embed editing off)
  inlineEditEnabled: true,
  inlineEditFile: false,
  inlineEditHeading: true,
  inlineEditBlock: true,
  // Internal
  lastSeenVersion: ""
};

// src/basics/codemirror.ts
var getActiveCM = (plugin) => {
  let rcm;
  plugin.app.workspace.iterateLeaves((leaf) => {
    var _a2;
    const cm = (_a2 = leaf.view.editor) == null ? void 0 : _a2.cm;
    if (cm == null ? void 0 : cm.hasFocus) {
      rcm = cm;
      return true;
    }
  }, plugin.app.workspace["rootSplit"]);
  return rcm;
};

// src/shared/utils/codemirror/selectiveEditor.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var combinedRangeFacets = (rangeA, rangeB) => {
  const aStart = rangeA == null ? void 0 : rangeA[0];
  const aEnd = rangeA == null ? void 0 : rangeA[1];
  const bStart = rangeB == null ? void 0 : rangeB[0];
  const bEnd = rangeB == null ? void 0 : rangeB[1];
  const start = aStart === void 0 ? bStart : bStart === void 0 ? aStart : Math.max(aStart, bStart);
  const end = aEnd === void 0 ? bEnd : bEnd === void 0 ? aEnd : Math.min(aEnd, bEnd);
  if (start !== void 0 && end !== void 0 && start > end) {
    return [void 0, void 0];
  }
  return [start, end];
};
var isCompleteLineRange = (range) => typeof range[0] === "number" && typeof range[1] === "number";
var editableRange = import_state.Annotation.define();
var contentRange = import_state.Annotation.define();
var setEditableRange = import_state.StateEffect.define();
var setContentRange = import_state.StateEffect.define();
var initialEditableRangeFacet = import_state.Facet.define({
  combine: (values) => values.length > 0 ? values[values.length - 1] : [void 0, void 0]
});
var initialContentRangeFacet = import_state.Facet.define({
  combine: (values) => values.length > 0 ? values[values.length - 1] : [void 0, void 0]
});
var hiddenLine = import_view.Decoration.replace({ inclusive: true, block: true });
var OUTLINER_SYS_MARKER_RE = /\[blp_sys::\s*1\]/;
var hideLine = import_state.StateField.define({
  create() {
    return import_view.Decoration.none;
  },
  update(value, tr) {
    const builder = new import_state.RangeSetBuilder();
    const editableLines = tr.state.field(selectiveLinesFacet, false);
    const contentLines = tr.state.field(frontmatterFacet, false);
    const visibleLines = (contentLines == null ? void 0 : contentLines[0]) ? contentLines : editableLines;
    if ((visibleLines == null ? void 0 : visibleLines[0]) != null && (visibleLines == null ? void 0 : visibleLines[1]) != null) {
      const startLine = Math.min(tr.state.doc.lines, visibleLines[0]);
      const endLine = Math.min(tr.state.doc.lines, visibleLines[1]);
      if (startLine > 1) {
        const hideBeforeTo = tr.state.doc.line(startLine).from - 1;
        if (hideBeforeTo >= tr.state.doc.line(1).from) {
          builder.add(tr.state.doc.line(1).from, hideBeforeTo, hiddenLine);
        }
      }
      for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++) {
        const line = tr.state.doc.line(lineNumber);
        if (!OUTLINER_SYS_MARKER_RE.test(line.text))
          continue;
        const to = lineNumber === endLine ? line.to : tr.state.doc.line(Math.min(tr.state.doc.lines, lineNumber + 1)).from;
        builder.add(line.from, to, hiddenLine);
      }
      if (endLine < tr.state.doc.lines) {
        builder.add(
          tr.state.doc.line(endLine).to,
          tr.state.doc.line(tr.state.doc.lines).to,
          hiddenLine
        );
      }
    }
    const dec = builder.finish();
    return dec;
  },
  provide: (f2) => import_view.EditorView.decorations.from(f2)
});
var frontmatterFacet = import_state.StateField.define({
  create: () => [void 0, void 0],
  update(value, tr) {
    let next = void 0;
    for (const effect of tr.effects) {
      if (effect.is(setContentRange))
        next = effect.value;
    }
    if (next === void 0) {
      next = tr.annotation(contentRange);
    }
    if (next === void 0) {
      const facetNext = tr.state.facet(initialContentRangeFacet);
      if ((facetNext == null ? void 0 : facetNext[0]) !== void 0 || (facetNext == null ? void 0 : facetNext[1]) !== void 0) {
        next = facetNext;
      }
    }
    if (next !== void 0) {
      const [startLine, endLine] = next;
      if (startLine !== void 0) {
        const clampedEnd = endLine === void 0 ? endLine : Math.min(tr.state.doc.lines, endLine);
        return [startLine, clampedEnd];
      }
      return next;
    }
    return value;
  }
});
var selectiveLinesFacet = import_state.StateField.define({
  create: () => [void 0, void 0],
  update(value, tr) {
    let next = void 0;
    for (const effect of tr.effects) {
      if (effect.is(setEditableRange))
        next = effect.value;
    }
    if (next === void 0) {
      next = tr.annotation(editableRange);
    }
    if (next === void 0) {
      const facetNext = tr.state.facet(initialEditableRangeFacet);
      if ((facetNext == null ? void 0 : facetNext[0]) !== void 0 || (facetNext == null ? void 0 : facetNext[1]) !== void 0) {
        next = facetNext;
      }
    }
    if (next !== void 0) {
      const [startLine, endLine] = next;
      if (startLine !== void 0) {
        const clampedEnd = endLine === void 0 ? endLine : Math.min(tr.state.doc.lines, endLine);
        return [startLine, clampedEnd];
      }
      return next;
    }
    return value;
  }
});
var lineRangeToPosRange = (state, range) => {
  return {
    from: state.doc.line(range[0]).from,
    to: state.doc.line(Math.min(state.doc.lines, range[1])).to
  };
};
var smartDelete = import_state.EditorState.transactionFilter.of(
  (tr) => {
    var _a2;
    const userEvent = (_a2 = tr.annotation(import_state.Transaction.userEvent)) != null ? _a2 : "delete";
    if (tr.isUserEvent("delete") && !userEvent.endsWith(".smart")) {
      const initialSelections = tr.startState.selection.ranges.map((range) => ({
        from: range.from,
        to: range.to
      }));
      const betterFacet = combinedRangeFacets(
        tr.startState.field(selectiveLinesFacet, false),
        tr.startState.field(frontmatterFacet, false)
      );
      if (initialSelections.length > 0 && isCompleteLineRange(betterFacet)) {
        const posRange = lineRangeToPosRange(
          tr.startState,
          betterFacet
        );
        if (tr.changes.touchesRange(0, posRange.from - 1)) {
          const minFrom = Math.max(posRange.from, initialSelections[0].from);
          const minTo = Math.min(posRange.to, initialSelections[0].to);
          return [{
            changes: {
              from: Math.min(minFrom, minTo),
              to: Math.max(minFrom, minTo)
            },
            annotations: import_state.Transaction.userEvent.of(
              `${userEvent}.smart`
            )
          }];
        }
      }
    }
    return tr;
  }
);
var preventModifyTargetRanges = import_state.EditorState.transactionFilter.of(
  (tr) => {
    var _a2, _b2;
    const newTrans = [];
    try {
      const editableLines = (_a2 = tr.startState.field(selectiveLinesFacet, false)) != null ? _a2 : [void 0, void 0];
      const contentLines = (_b2 = tr.startState.field(frontmatterFacet, false)) != null ? _b2 : [void 0, void 0];
      const selectiveLines = combinedRangeFacets(editableLines, contentLines);
      if (tr.isUserEvent("input") || tr.isUserEvent("delete") || tr.isUserEvent("move")) {
        if (isCompleteLineRange(selectiveLines)) {
          const posRange = lineRangeToPosRange(
            tr.startState,
            selectiveLines
          );
          if (!tr.changes.touchesRange(posRange.from, posRange.to)) {
            return [];
          }
        }
      }
      if (tr.state.doc.lines != tr.startState.doc.lines) {
        const numberNewLines = tr.state.doc.lines - tr.startState.doc.lines;
        if (isCompleteLineRange(selectiveLines)) {
          const posRange = lineRangeToPosRange(
            tr.startState,
            selectiveLines
          );
          if (tr.changes.touchesRange(0, posRange.from - 1)) {
            const newAnnotations = [];
            if (editableLines[0] !== void 0 && editableLines[1] !== void 0) {
              newAnnotations.push(editableRange.of([
                editableLines[0] + numberNewLines,
                editableLines[1] + numberNewLines
              ]));
            }
            if (contentLines[0] !== void 0 && contentLines[1] !== void 0) {
              newAnnotations.push(contentRange.of([
                contentLines[0] + numberNewLines,
                contentLines[1] + numberNewLines
              ]));
            }
            newTrans.push({
              annotations: newAnnotations
            });
          } else if (tr.changes.touchesRange(posRange.from - 1, posRange.to)) {
            const newAnnotations = [];
            if (editableLines[0] !== void 0 && editableLines[1] !== void 0) {
              newAnnotations.push(editableRange.of([
                editableLines[0],
                editableLines[1] + numberNewLines
              ]));
            }
            if (contentLines[0] !== void 0 && contentLines[1] !== void 0) {
              newAnnotations.push(contentRange.of([
                contentLines[0],
                contentLines[1] + numberNewLines
              ]));
            }
            newTrans.push({
              annotations: newAnnotations
            });
          }
        }
      }
    } catch (e) {
      return [];
    }
    return [tr, ...newTrans];
  }
);
var readOnlyRangesExtension = [smartDelete, preventModifyTargetRanges];
var editBlockExtensions = () => [
  readOnlyRangesExtension,
  hideLine,
  selectiveLinesFacet,
  frontmatterFacet
];

// src/basics/cmExtensions.ts
var cmExtensions = (plugin) => {
  const extensions = [...editBlockExtensions()];
  return extensions;
};

// src/basics/enactor/obsidian.tsx
var import_obsidian3 = require("obsidian");

// src/shared/utils/obsidian.ts
var import_obsidian = require("obsidian");
function getMultilineBlockId(inputStr) {
  const trimmed = inputStr.trim();
  const hasHashPrefix = trimmed.startsWith("#");
  const candidate = hasHashPrefix ? trimmed.slice(1) : trimmed;
  const matchResult = candidate.match(/^\^([a-z0-9_]+)-\1$/i);
  if (!matchResult)
    return null;
  return `${hasHashPrefix ? "#" : ""}^${matchResult[1]}`;
}
function getLastContentLineFromCache(cache) {
  if (!cache) {
    return 0;
  }
  if (cache.sections && cache.sections.length > 0) {
    const lastSection = cache.sections[cache.sections.length - 1];
    return lastSection.position.end.line;
  }
  if (cache.frontmatter) {
    return cache.frontmatter.position.end.line;
  }
  return 0;
}
var getLineRangeFromRef = (path, ref, app) => {
  if (!ref)
    return [void 0, void 0];
  const cache = app.metadataCache.getCache(path);
  if (!cache)
    return [void 0, void 0];
  const resolved = (0, import_obsidian.resolveSubpath)(cache, ref);
  if (!resolved)
    return [void 0, void 0];
  if (resolved.type === "block") {
    const multilineBlockId = getMultilineBlockId(ref);
    const { position } = resolved.block;
    if (multilineBlockId) {
      const startBlock = (0, import_obsidian.resolveSubpath)(cache, multilineBlockId);
      if (startBlock && startBlock.type === "block") {
        return [startBlock.block.position.start.line + 1, position.end.line + 1];
      }
    }
    return [position.start.line + 1, position.end.line + 1];
  }
  if (resolved.type === "heading") {
    const { current: heading, next } = resolved;
    const start = heading.position.start.line + 1;
    const end = next ? next.position.start.line : getLastContentLineFromCache(cache) + 1;
    return [start, end];
  }
  return [void 0, void 0];
};

// src/shared/FlowEditor.tsx
var import_obsidian2 = require("obsidian");

// src/shared/utils/uuid.js
function genId() {
  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(
    /[018]/g,
    (c) => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
  );
}

// src/shared/FlowEditor.tsx
var popovers = /* @__PURE__ */ new WeakMap();
var mouseCoords = { x: 0, y: 0 };
function nosuper(base) {
  const derived = function() {
    return Object.setPrototypeOf(new import_obsidian2.Component(), new.target.prototype);
  };
  derived.prototype = base.prototype;
  return Object.setPrototypeOf(derived, base);
}
var _a, _b, _c, _d, _e, _f;
var FlowEditor = class extends nosuper(import_obsidian2.HoverPopover) {
  constructor(parent, targetEl, app, waitTime, onShowCallback) {
    super();
    this.targetEl = targetEl;
    this.app = app;
    this.onShowCallback = onShowCallback;
    this.abortController = this.addChild(new import_obsidian2.Component());
    this.detaching = false;
    this.opening = false;
    this.rootSplit = new import_obsidian2.WorkspaceSplit(
      this.app.workspace,
      "vertical"
    );
    this.targetRect = (_a = this.targetEl) == null ? void 0 : _a.getBoundingClientRect();
    this.oldPopover = (_c = (_b = this.parent) == null ? void 0 : _b.flowEditors) == null ? void 0 : _c.find(
      (he) => he.id !== this.id
    );
    this.document = (_f = (_e = (_d = this.targetEl) == null ? void 0 : _d.ownerDocument) != null ? _e : window.activeDocument) != null ? _f : window.document;
    this.id = genId();
    this.hoverEl = this.document.defaultView.createDiv({
      cls: "mk-floweditor mk-hover-popover",
      attr: { id: "he" + this.id }
    });
    if (waitTime === void 0) {
      waitTime = 10;
    }
    this.onTarget = true;
    this.parent = parent;
    this.waitTime = waitTime;
    this.state = import_obsidian2.PopoverState.Showing;
    const { hoverEl } = this;
    this.abortController.load();
    this.timer = window.setTimeout(this.show.bind(this), waitTime);
    this.setActive = this._setActive.bind(this);
    if (hoverEl) {
      hoverEl.addEventListener("mousedown", this.setActive);
      hoverEl.addEventListener("mousedown", (e) => e.stopPropagation());
    }
    popovers.set(this.hoverEl, this);
    this.hoverEl.addClass("hover-editor");
    this.containerEl = this.hoverEl.createDiv("popover-content");
    this.setTitleBar();
    this.hoverEl.style.height = "auto";
    this.hoverEl.style.width = "100%";
    this.hoverEl.addEventListener("keydown", (e) => e.stopPropagation());
  }
  static activeWindows(app) {
    const windows = [window];
    const { floatingSplit } = app.workspace;
    if (floatingSplit) {
      for (const split of floatingSplit.children) {
        if (split.win)
          windows.push(split.win);
      }
    }
    return windows;
  }
  static containerForDocument(app, doc) {
    if (doc !== document && app.workspace.floatingSplit)
      for (const container of app.workspace.floatingSplit.children) {
        if (container.doc === doc)
          return container;
      }
    return app.workspace.rootSplit;
  }
  static activePopovers(app) {
    return this.activeWindows(app).flatMap(this.popoversForWindow);
  }
  static popoversForWindow(win) {
    var _a2, _b2;
    return Array.prototype.slice.call(
      (_b2 = (_a2 = win == null ? void 0 : win.document) == null ? void 0 : _a2.body.querySelectorAll(".mk-hover-popover")) != null ? _b2 : []
    ).map((el) => popovers.get(el)).filter((he) => he);
  }
  static forLeaf(leaf) {
    const el = leaf && document.body.matchParent.call(leaf.containerEl, ".mk-hover-popover");
    return el ? popovers.get(el) : void 0;
  }
  onunload() {
    this.hide();
  }
  _setActive() {
    this.app.workspace.setActiveLeaf(this.leaves()[0], { focus: true });
  }
  getDefaultMode() {
    var _a2, _b2;
    return ((_b2 = (_a2 = this.parent) == null ? void 0 : _a2.view) == null ? void 0 : _b2.getMode) ? this.parent.view.getMode() : "preview";
  }
  updateLeaves() {
    if (this.onTarget && this.targetEl && !this.document.contains(this.targetEl)) {
      this.onTarget = false;
      this.transition();
    }
    let leafCount = 0;
    this.app.workspace.iterateLeaves((leaf) => {
      leafCount++;
    }, this.rootSplit);
    if (leafCount === 0) {
      this.hide();
    } else if (leafCount > 1) {
    }
    this.hoverEl.setAttribute("data-leaf-count", leafCount.toString());
  }
  setTitleBar() {
    this.titleEl = this.document.defaultView.createDiv("mk-flow-titlebar");
    this.containerEl.prepend(this.titleEl);
  }
  attachLeaf() {
    this.rootSplit.getRoot = () => this.app.workspace[this.document === document ? "rootSplit" : "floatingSplit"];
    this.rootSplit.getContainer = () => FlowEditor.containerForDocument(this.app, this.document);
    this.titleEl.insertAdjacentElement("afterend", this.rootSplit.containerEl);
    const leaf = this.app.workspace.createLeafInParent(this.rootSplit, 0);
    leaf.isFlowBlock = true;
    this.updateLeaves();
    return leaf;
  }
  onload() {
    super.onload();
    this.registerEvent(
      this.app.workspace.on("layout-change", this.updateLeaves, this)
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this.rootSplit.children.forEach((item, index) => {
          if (item instanceof import_obsidian2.WorkspaceTabs) {
            this.rootSplit.replaceChild(index, item.children[0]);
          }
        });
      })
    );
  }
  leaves() {
    const leaves = [];
    this.app.workspace.iterateLeaves((leaf) => {
      leaves.push(leaf);
    }, this.rootSplit);
    return leaves;
  }
  async onShow() {
    var _a2, _b2, _c2;
    const closeDelay = 600;
    setTimeout(() => this.waitTime = closeDelay, closeDelay);
    (_a2 = this.oldPopover) == null ? void 0 : _a2.hide();
    this.oldPopover = void 0;
    this.hoverEl.classList.add("is-new");
    this.document.body.addEventListener(
      "click",
      () => {
        this.hoverEl.classList.remove("is-new");
      },
      { once: true, capture: true }
    );
    if (this.parent) {
      if (!this.parent.flowEditors)
        this.parent.flowEditors = [];
      this.parent.flowEditors.push(this);
      (_b2 = this.parent.view) == null ? void 0 : _b2.addChild(this);
    }
    await ((_c2 = this.onShowCallback) == null ? void 0 : _c2.call(this, this));
    this.onShowCallback = void 0;
    const viewHeaderEl = this.hoverEl.querySelector(".view-header");
    viewHeaderEl == null ? void 0 : viewHeaderEl.remove();
    const sizer = this.hoverEl.querySelector(".workspace-leaf");
    if (sizer)
      this.hoverEl.appendChild(sizer);
    const inlineTitle = this.hoverEl.querySelector(".inline-title");
    inlineTitle == null ? void 0 : inlineTitle.remove();
  }
  transition() {
    if (this.shouldShow()) {
      if (this.state === import_obsidian2.PopoverState.Hiding) {
        this.state = import_obsidian2.PopoverState.Shown;
        clearTimeout(this.timer);
      }
    } else {
      if (this.state === import_obsidian2.PopoverState.Showing) {
        this.hide();
      } else {
        if (this.state === import_obsidian2.PopoverState.Shown) {
          this.state = import_obsidian2.PopoverState.Hiding;
          this.timer = window.setTimeout(() => {
            if (this.shouldShow()) {
              this.transition();
            } else {
              this.hide();
            }
          }, this.waitTime);
        }
      }
    }
  }
  shouldShow() {
    return this.shouldShowSelf() || this.shouldShowChild();
  }
  shouldShowChild() {
    return FlowEditor.activePopovers(this.app).some((popover) => {
      if (popover !== this && popover.targetEl && this.hoverEl.contains(popover.targetEl)) {
        return popover.shouldShow();
      }
      return false;
    });
  }
  shouldShowSelf() {
    return !this.detaching && !!(this.onTarget || this.state == import_obsidian2.PopoverState.Shown || this.document.querySelector(
      `body>.modal-container, body > #he${this.id} ~ .menu, body > #he${this.id} ~ .suggestion-container`
    ));
  }
  show() {
    this.state = import_obsidian2.PopoverState.Shown;
    this.timer = 0;
    this.shownPos = mouseCoords;
    this.targetEl.replaceChildren(this.hoverEl);
    this.onShow();
    this.app.workspace.onLayoutChange();
    this.load();
  }
  onHide() {
    this.oldPopover = void 0;
    const parent = this.parent;
    const flowEditors = parent == null ? void 0 : parent.flowEditors;
    if (parent && (flowEditors == null ? void 0 : flowEditors.some((he) => he === this))) {
      parent.flowEditors = flowEditors.filter((he) => he.id !== this.id);
    }
  }
  hide() {
    var _a2;
    this.onTarget = false;
    this.detaching = true;
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = 0;
    }
    this.hoverEl.hide();
    if (this.opening)
      return;
    const leaves = this.leaves();
    if (leaves.length) {
      leaves.forEach((leaf) => {
        leaf.detach();
      });
    } else {
      this.parent = null;
      (_a2 = this.abortController) == null ? void 0 : _a2.unload();
      this.abortController = void 0;
      return this.nativeHide();
    }
  }
  nativeHide() {
    var _a2;
    const { hoverEl, targetEl } = this;
    this.state = import_obsidian2.PopoverState.Hidden;
    hoverEl.detach();
    if (targetEl) {
      const parent = targetEl.matchParent(".mk-hover-popover");
      if (parent)
        (_a2 = popovers.get(parent)) == null ? void 0 : _a2.transition();
    }
    this.onHide();
    this.unload();
  }
  async openContext(file, openState, useLeaf) {
    if (this.detaching)
      return;
    const leaf = useLeaf != null ? useLeaf : this.attachLeaf();
    this.opening = true;
    try {
      await leaf.openFile(file, openState);
    } catch (e) {
      console.error(e);
    } finally {
      this.opening = false;
      if (this.detaching)
        this.hide();
    }
    return leaf;
  }
  async openFile(file, openState, useLeaf) {
    if (this.detaching)
      return;
    const leaf = useLeaf != null ? useLeaf : this.attachLeaf();
    this.opening = true;
    try {
      await leaf.openFile(file, openState);
    } catch (e) {
      console.error(e);
    } finally {
      this.opening = false;
      if (this.detaching)
        this.hide();
    }
    return leaf;
  }
  buildState(parentMode, eState) {
    return {
      active: false,
      state: {},
      eState
    };
  }
  buildEphemeralState(file, link) {
    const cache = this.app.metadataCache.getFileCache(file);
    const subpath = cache ? (0, import_obsidian2.resolveSubpath)(cache, (link == null ? void 0 : link.subpath) || "") : void 0;
    const eState = { subpath: link == null ? void 0 : link.subpath };
    if (subpath) {
      eState.line = subpath.start.line;
      eState.startLoc = subpath.start;
      eState.endLoc = subpath.end || void 0;
    }
    return eState;
  }
};

// src/shared/utils/openPathInElement.ts
var openPathInElement = (app, parentLeaf, initiatingEl, fileName, onShowCallback) => {
  const parent = parentLeaf != null ? parentLeaf : app.workspace.getLeaf();
  if (!initiatingEl)
    initiatingEl = parent.containerEl;
  const hoverPopover = new FlowEditor(
    parent,
    initiatingEl,
    app,
    void 0,
    onShowCallback
  );
  if (fileName)
    hoverPopover.titleEl.textContent = fileName.substring(
      0,
      fileName.lastIndexOf(".")
    );
};

// src/shared/utils/paths.ts
var removeTrailingSlashFromFolder = (path) => path == "/" ? path : path.slice(-1) == "/" ? path.substring(0, path.length - 1) : path;

// src/shared/utils/uri.ts
var parseURI = (uri) => {
  const fullPath = uri;
  let refTypeChar = "";
  const parseQuery = (queryString) => {
    const query2 = {};
    queryString.split("&").forEach((param) => {
      const [key, value] = param.split("=");
      query2[decodeURIComponent(key)] = decodeURIComponent(value);
    });
    return query2;
  };
  const mapRefType = (refTypeChar2, isSpace) => {
    if (isSpace) {
      if (refTypeChar2 === "^")
        return "context";
      if (refTypeChar2 === "*")
        return "frame";
      if (refTypeChar2 === ";")
        return "action";
      return void 0;
    }
    if (refTypeChar2 === "^")
      return "block";
    return "heading";
  };
  let space = void 0;
  let path = void 0;
  let alias = void 0;
  let reference = void 0;
  let refType = void 0;
  let query = void 0;
  let scheme = "vault";
  if (fullPath.indexOf("://") != -1) {
    scheme = uri.slice(0, uri.indexOf("://"));
    const spaceStr = uri.slice(uri.indexOf("://") + 3);
    if (spaceStr.charAt(0) == "#" || spaceStr.charAt(0) == "$") {
      const endIndex = spaceStr.split("/")[0].lastIndexOf("#");
      if (endIndex > 0) {
        space = removeTrailingSlashFromFolder(spaceStr.slice(0, endIndex));
        uri = spaceStr.slice(endIndex);
      } else {
        space = spaceStr.split("/")[0];
        uri = spaceStr.replace(space, "");
        if (uri.length > 0) {
          uri = uri.slice(1);
        }
        if (uri == "") {
          uri = "/";
        }
      }
    } else {
      const spaceParts = spaceStr.split("/");
      space = spaceParts[0];
      uri = spaceParts.slice(1).join("/") || "";
    }
  }
  const lastSlashIndex = uri.lastIndexOf("/");
  const lastHashIndex = uri.lastIndexOf("#");
  const lastPipeIndex = uri.lastIndexOf("|");
  const queryIndex = uri.lastIndexOf("?");
  let trailSlash = false;
  if (queryIndex !== -1) {
    query = parseQuery(uri.slice(queryIndex + 1));
    uri = uri.slice(0, queryIndex);
  }
  if (lastPipeIndex !== -1 && lastPipeIndex > lastSlashIndex) {
    alias = uri.slice(lastPipeIndex + 1);
    uri = uri.slice(0, lastPipeIndex);
  }
  if (lastHashIndex !== -1 && lastHashIndex > lastSlashIndex) {
    if (lastHashIndex == lastSlashIndex + 1) {
      trailSlash = true;
    }
    const refPart = uri.slice(lastHashIndex + 1);
    refType = mapRefType(refPart[0], trailSlash);
    if (refType || lastHashIndex != lastSlashIndex + 1) {
      refTypeChar = refPart[0];
      reference = refType ? refPart.slice(1) : refPart;
      uri = uri.slice(0, lastHashIndex);
    }
  }
  if (uri.charAt(uri.length - 1) == "/") {
    trailSlash = true;
  }
  path = uri;
  return {
    basePath: removeTrailingSlashFromFolder(`${space ? `${scheme}://${space}/${path != "/" ? path : ""}` : path}`),
    authority: space != null ? space : "",
    fullPath,
    scheme,
    path: removeTrailingSlashFromFolder(uri),
    alias,
    ref: reference,
    refType,
    refStr: refType && reference ? refTypeChar + reference : reference,
    query,
    trailSlash
  };
};

// src/basics/schemas/settings.ts
var BasicDefaultSettings = {
  inlineEditEnabled: true,
  inlineEditFile: false,
  inlineEditHeading: true,
  inlineEditBlock: true
};

// src/basics/enactor/obsidian.tsx
var ObsidianEnactor = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.name = "Obsidian";
  }
  load() {
    this.plugin.settings = Object.assign(
      {},
      BasicDefaultSettings,
      this.plugin.settings
    );
    this.loadCommands();
  }
  loadCommands() {
    this.plugin.addCommand({
      id: "mk-flow-editor",
      name: "Toggle Inline Edit",
      callback: () => {
        this.plugin.settings.inlineEditEnabled = !this.plugin.settings.inlineEditEnabled;
        void this.plugin.saveSettings();
        this.plugin.flowEditorManager.reloadExtensions(false);
      }
    });
    return [
      {
        label: "embed",
        value: `![[]]`,
        icon: "mk-make-embed"
      },
      {
        label: "link",
        value: `[[]]`,
        icon: "mk-make-link"
      }
    ];
  }
  loadExtensions(firstLoad) {
    const extensions = cmExtensions(this.plugin);
    if (firstLoad) {
      this.plugin.registerEditorExtension(extensions);
    }
  }
  uriByString(uri, source) {
    if (!uri)
      return null;
    let basePath = uri;
    let subpath;
    if (uri.includes("#")) {
      const parts = uri.split("#");
      basePath = parts[0];
      subpath = "#" + parts.slice(1).join("#");
    }
    if (source) {
      const file = this.plugin.app.metadataCache.getFirstLinkpathDest(basePath, source);
      if (!file)
        return null;
      basePath = file.path;
    }
    const finalUri = subpath ? `${basePath}${subpath}` : basePath;
    return parseURI(finalUri);
  }
  openPath(path, source, isReadOnly) {
    const uri = this.uriByString(path);
    if (!uri) {
      new import_obsidian3.Notice(`File not found: ${path}`);
      return;
    }
    openPathInElement(
      this.plugin.app,
      this.plugin.app.workspace.getLeaf(),
      source,
      void 0,
      async (editor) => {
        var _a2, _b2, _c2;
        const leaf = editor.attachLeaf();
        if (this.plugin.app.vault.getAbstractFileByPath(uri.basePath) instanceof import_obsidian3.TFile) {
          await leaf.openFile(this.plugin.app.vault.getAbstractFileByPath(uri.basePath));
          const selectiveRange = getLineRangeFromRef(uri.basePath, uri.refStr, this.plugin.app);
          if (!((_a2 = leaf.view) == null ? void 0 : _a2.editor))
            return;
          if (selectiveRange[0] && selectiveRange[1]) {
            (_b2 = leaf.view.editor) == null ? void 0 : _b2.cm.dispatch({
              annotations: [editableRange.of(selectiveRange)]
            });
          }
          if (isReadOnly && ((_c2 = leaf.view) == null ? void 0 : _c2.editor)) {
            leaf.view.editor.cm.contentDOM.contentEditable = "false";
            leaf.view.editor.cm.dom.classList.add("mk-readonly-editor");
          }
        }
      }
    );
  }
};

// src/features/flow-editor/index.ts
var FlowEditorManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.enactor = new ObsidianEnactor(this.plugin);
  }
  /**
   * Legacy FlowEditorManager now only loads CodeMirror extensions required by BLP
   * (e.g. selective editor ranges). Range (`^id-id`) rendering is handled by InlineEditEngine.
   */
  initialize() {
    this.enactor.load();
    this.reloadExtensions(true);
  }
  reloadExtensions(firstLoad) {
    this.enactor.loadExtensions(firstLoad);
  }
  // Deprecated API surface (kept for compatibility).
  openFlow() {
  }
  closeFlow() {
  }
};

// src/features/inline-edit-engine/InlineEditEngine.ts
var import_state2 = require("@codemirror/state");
var import_obsidian7 = require("obsidian");

// node_modules/monkey-around/mjs/index.js
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const original = obj[method], hadOwn = obj.hasOwnProperty(method);
  let current = createWrapper(original);
  if (original)
    Object.setPrototypeOf(current, original);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, original || Function);
  }
}

// src/features/inline-edit-engine/EmbedLeafManager.ts
var import_obsidian6 = require("obsidian");

// src/shared/utils/workspaceLeafFlags.ts
var BLP_DETACHED_LEAF_MARK = Symbol.for("block-link-plus.detachedLeaf");
function markLeafAsDetached(leaf) {
  try {
    leaf[BLP_DETACHED_LEAF_MARK] = true;
  } catch (e) {
  }
}
function isDetachedLeaf(leaf) {
  try {
    return Boolean(leaf && leaf[BLP_DETACHED_LEAF_MARK] === true);
  } catch (e) {
    return false;
  }
}

// src/features/inline-edit-engine/EmbedLeafManager.ts
var _EmbedLeafManager = class {
  constructor(plugin) {
    this.embedRegistry = /* @__PURE__ */ new WeakMap();
    this.activeEmbeds = /* @__PURE__ */ new Set();
    this.plugin = plugin;
  }
  getActiveEmbeds() {
    return Array.from(this.activeEmbeds);
  }
  cleanup() {
    const embeds = Array.from(this.activeEmbeds);
    for (const embed of embeds) {
      this.detach(embed);
    }
  }
  getEmbedFromElement(element) {
    if (!element)
      return null;
    let current = element;
    while (current && current !== document.body) {
      const embed = this.embedRegistry.get(current);
      if (embed)
        return embed;
      current = current.parentElement;
    }
    return null;
  }
  isNestedWithinEmbed(element) {
    if (!element)
      return false;
    return element.matchParent(`.${_EmbedLeafManager.INLINE_EDIT_ROOT_CLASS}`) !== null;
  }
  isLegacyDoubleBangEmbed(embedEl) {
    var _a2;
    let prev = embedEl.previousSibling;
    let collected = "";
    let nonEmptyTextNodes = 0;
    while (prev && nonEmptyTextNodes < 2 && collected.length < 16) {
      if (prev.nodeType === Node.TEXT_NODE) {
        const text = (_a2 = prev.textContent) != null ? _a2 : "";
        if (text.trim() === "") {
          prev = prev.previousSibling;
          continue;
        }
        collected = text + collected;
        nonEmptyTextNodes += 1;
        prev = prev.previousSibling;
        continue;
      }
      break;
    }
    const trimmed = collected.replace(/\s+$/, "");
    return trimmed.endsWith("!!");
  }
  async createEmbedLeaf(args) {
    const leaf = new import_obsidian6.WorkspaceLeaf(this.plugin.app);
    markLeafAsDetached(leaf);
    const embed = {
      containerEl: args.containerEl,
      file: args.file,
      subpath: args.subpath,
      sourcePath: args.sourcePath,
      component: void 0,
      leaf,
      view: void 0
    };
    const component = new import_obsidian6.MarkdownRenderChild(args.containerEl);
    component.load();
    component.register(() => {
      this.detachLeafFromComponentUnload(embed);
    });
    embed.component = component;
    args.containerEl.addClass(_EmbedLeafManager.INLINE_EDIT_ROOT_CLASS);
    try {
      await leaf.openFile(args.file, {
        state: { mode: "source" }
      });
    } catch (error) {
      component.unload();
      leaf.detach();
      throw error;
    }
    if (!(leaf.view instanceof import_obsidian6.MarkdownView)) {
      component.unload();
      leaf.detach();
      throw new Error("InlineEdit: failed to load MarkdownView");
    }
    embed.view = leaf.view;
    this.embedRegistry.set(args.containerEl, embed);
    this.activeEmbeds.add(embed);
    return embed;
  }
  reparent(embeddingContainerEl, viewContainerEl) {
    embeddingContainerEl.replaceChildren(viewContainerEl);
  }
  detachLeafFromComponentUnload(embed) {
    var _a2;
    this.embedRegistry.delete(embed.containerEl);
    this.activeEmbeds.delete(embed);
    try {
      (_a2 = embed.restore) == null ? void 0 : _a2.call(embed);
    } catch (e) {
    }
    try {
      embed.containerEl.removeClass(_EmbedLeafManager.INLINE_EDIT_ROOT_CLASS);
    } catch (e) {
    }
    try {
      embed.leaf.detach();
    } catch (e) {
    }
  }
  detach(embed) {
    try {
      embed.component.unload();
    } catch (e) {
    }
  }
};
var EmbedLeafManager = _EmbedLeafManager;
EmbedLeafManager.INLINE_EDIT_ROOT_CLASS = "blp-inline-edit-root";

// src/features/inline-edit-engine/FocusTracker.ts
var FocusTracker = class {
  constructor() {
    this.focused = null;
  }
  getFocused() {
    if (this.focused && !this.focused.containerEl.isConnected) {
      this.focused = null;
    }
    return this.focused;
  }
  setFocused(embed) {
    this.focused = embed;
  }
  cleanup() {
    this.focused = null;
  }
};

// src/features/inline-edit-engine/InlineEditEngine.ts
var INLINE_EDIT_ACTIVE_CLASS = "blp-inline-edit-active";
var INLINE_EDIT_HOST_CLASS = "blp-inline-edit-host";
var LIVE_PREVIEW_GRACE_MS = 5e3;
var READING_RANGE_ACTIVE_CLASS = "blp-reading-range-active";
var LIVE_PREVIEW_RANGE_ACTIVE_CLASS = "blp-live-preview-range-active";
var READING_RANGE_HOST_CLASS = "blp-reading-range-host";
var LIVE_PREVIEW_RANGE_HOST_CLASS = "blp-live-preview-range-host";
var InlineEditEngine = class {
  constructor(plugin) {
    this.loaded = false;
    this.didInitialMetadataResolve = false;
    this.commandRoutingDepth = 0;
    this.commandRoutingUninstallers = [];
    this.readingRangeEmbedsByPath = /* @__PURE__ */ new Map();
    this.livePreviewRangeEmbedsByPath = /* @__PURE__ */ new Map();
    this.readingRangeDebounceTimers = /* @__PURE__ */ new Map();
    this.readingRangeChildByEmbed = /* @__PURE__ */ new WeakMap();
    this.readingRangeChildren = /* @__PURE__ */ new Set();
    this.livePreviewRangeChildByEmbed = /* @__PURE__ */ new WeakMap();
    this.livePreviewRangeChildren = /* @__PURE__ */ new Set();
    this.readingRangeObserver = null;
    this.pendingEmbeds = /* @__PURE__ */ new WeakSet();
    this.livePreviewObservers = /* @__PURE__ */ new Map();
    this.debugSkipCache = /* @__PURE__ */ new WeakMap();
    this.debugPrefix = "[BLP InlineEdit]";
    this.plugin = plugin;
    this.leaves = new EmbedLeafManager(plugin);
    this.focus = new FocusTracker();
  }
  load() {
    if (this.loaded)
      return;
    this.loaded = true;
    this.installCommandRouting();
    this.installFocusTracking();
    this.installReadingRangeRendering();
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("layout-change", () => {
        if (!this.loaded)
          return;
        if (!this.isInlineEditActive()) {
          this.disconnectAllObservers();
          this.leaves.cleanup();
          this.focus.cleanup();
          return;
        }
        window.setTimeout(() => {
          this.refreshLivePreviewObservers();
          this.cleanupHiddenEmbeds();
        }, 50);
      })
    );
    this.plugin.app.workspace.onLayoutReady(() => {
      if (!this.loaded)
        return;
      if (!this.isInlineEditActive())
        return;
      this.refreshLivePreviewObservers(true);
    });
    this.plugin.registerEvent(
      this.plugin.app.metadataCache.on("resolved", () => {
        if (!this.loaded)
          return;
        if (!this.isInlineEditActive())
          return;
        if (this.didInitialMetadataResolve)
          return;
        this.didInitialMetadataResolve = true;
        this.refreshLivePreviewObservers(true);
      })
    );
    window.setTimeout(() => {
      if (!this.loaded)
        return;
      if (!this.isInlineEditActive())
        return;
      this.refreshLivePreviewObservers();
    }, 0);
  }
  unload() {
    if (!this.loaded)
      return;
    this.loaded = false;
    this.disconnectAllObservers();
    this.uninstallCommandRouting();
    this.cleanupReadingRangeRendering();
    this.focus.cleanup();
    this.leaves.cleanup();
  }
  isLoaded() {
    return this.loaded;
  }
  /**
   * File Outliner View renders markdown outside Live Preview. This opt-in API allows the outliner
   * surface to mount an inline embed editor on demand (e.g. for `![[note#^id-id]]`).
   *
   * Safety: guarded by a `.blp-file-outliner-view` DOM check so normal MarkdownView preview
   * cannot accidentally trigger embed editing.
   */
  async mountInlineEmbedInOutliner(embedEl, sourcePath) {
    var _a2, _b2, _c2, _d2;
    if (!this.loaded)
      return false;
    if (!this.isInlineEditActive())
      return false;
    if (!(embedEl == null ? void 0 : embedEl.isConnected))
      return false;
    if (!embedEl.classList.contains("internal-embed") || !embedEl.classList.contains("markdown-embed"))
      return false;
    if (!embedEl.closest(".blp-file-outliner-view"))
      return false;
    if (this.isInLivePreview(embedEl))
      return false;
    const existingRoot = embedEl.querySelector(`.${EmbedLeafManager.INLINE_EDIT_ROOT_CLASS}`);
    if (existingRoot) {
      try {
        (_b2 = (_a2 = this.leaves.getEmbedFromElement(existingRoot)) == null ? void 0 : _a2.view.editor) == null ? void 0 : _b2.focus();
      } catch (e) {
      }
      return true;
    }
    if (this.pendingEmbeds.has(embedEl))
      return false;
    const ctx = {
      sourcePath,
      addChild: () => {
      }
    };
    await this.mountInlineEmbedCore(embedEl, ctx, { requireLivePreview: false, origin: "outliner" });
    const root = embedEl.querySelector(`.${EmbedLeafManager.INLINE_EDIT_ROOT_CLASS}`);
    if (!root)
      return false;
    try {
      (_d2 = (_c2 = this.leaves.getEmbedFromElement(root)) == null ? void 0 : _c2.view.editor) == null ? void 0 : _d2.focus();
    } catch (e) {
    }
    return true;
  }
  isDebugEnabled() {
    return window.BLP_INLINE_EDIT_DEBUG === true;
  }
  debugLog(...args) {
    if (!this.isDebugEnabled())
      return;
    console.log(this.debugPrefix, ...args);
  }
  debugSkip(embedEl, key, data) {
    if (!this.isDebugEnabled())
      return;
    const now2 = Date.now();
    const previous = this.debugSkipCache.get(embedEl);
    if (previous && previous.key === key && now2 - previous.at < 2e3)
      return;
    this.debugSkipCache.set(embedEl, { key, at: now2 });
    this.debugLog(key, data != null ? data : embedEl.getAttribute("src"));
  }
  ensureEmbedEditorExtensions(cm) {
    if (!(cm == null ? void 0 : cm.state) || typeof cm.dispatch !== "function")
      return;
    let hasHideLine = false;
    try {
      hasHideLine = cm.state.field(hideLine, false) !== void 0;
    } catch (e) {
      hasHideLine = false;
    }
    try {
      cm.__blpInlineEditHasHideLine = hasHideLine;
    } catch (e) {
    }
    if (hasHideLine)
      return;
    try {
      cm.dispatch({ filter: false, effects: import_state2.StateEffect.appendConfig.of(editBlockExtensions()) });
    } catch (e) {
    }
    try {
      cm.__blpInlineEditHasHideLine = cm.state.field(hideLine, false) !== void 0;
    } catch (e) {
    }
  }
  isInlineEditActive() {
    const { inlineEditEnabled, inlineEditFile, inlineEditHeading, inlineEditBlock } = this.plugin.settings;
    return inlineEditEnabled && (inlineEditFile || inlineEditHeading || inlineEditBlock);
  }
  onSettingsChanged() {
    if (!this.loaded)
      return;
    if (!this.isInlineEditActive()) {
      this.disconnectAllObservers();
      this.leaves.cleanup();
      this.focus.cleanup();
      return;
    }
    this.refreshLivePreviewObservers();
  }
  installFocusTracking() {
    this.plugin.registerDomEvent(document, "focusin", (event) => {
      const target = event.target;
      if (!(target instanceof HTMLElement))
        return;
      const embed = this.leaves.getEmbedFromElement(target);
      if (embed) {
        this.focus.setFocused(embed);
      }
    });
    this.plugin.registerDomEvent(document, "focusout", (event) => {
      const next = event.relatedTarget;
      if (next instanceof HTMLElement) {
        const embed = this.leaves.getEmbedFromElement(next);
        if (embed) {
          this.focus.setFocused(embed);
          return;
        }
      }
      this.focus.setFocused(null);
    });
  }
  installReadingRangeRendering() {
    this.plugin.registerMarkdownPostProcessor((element, ctx) => {
      var _a2;
      const embeds = ((_a2 = element.matches) == null ? void 0 : _a2.call(element, ".internal-embed.markdown-embed")) ? [element] : Array.from(element.querySelectorAll(".internal-embed.markdown-embed"));
      for (const embedEl of embeds) {
        this.ensureReadingRangeEmbedChild(embedEl, ctx.sourcePath, "postprocessor");
        this.ensureLivePreviewRangeEmbedChild(embedEl, ctx.sourcePath, "postprocessor");
      }
    });
    this.plugin.registerEvent(
      this.plugin.app.vault.on("modify", (file) => {
        if (!this.loaded)
          return;
        if (!(file instanceof import_obsidian7.TFile))
          return;
        this.scheduleReadingRangeRefresh(file.path);
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.metadataCache.on("changed", (file) => {
        if (!this.loaded)
          return;
        if (!(file instanceof import_obsidian7.TFile))
          return;
        this.scheduleReadingRangeRefresh(file.path);
      })
    );
    this.installReadingRangeObserver();
  }
  cleanupReadingRangeRendering() {
    if (this.readingRangeObserver) {
      try {
        this.readingRangeObserver.disconnect();
      } catch (e) {
      }
      this.readingRangeObserver = null;
    }
    for (const child of Array.from(this.readingRangeChildren)) {
      try {
        child.unload();
      } catch (e) {
      }
    }
    this.readingRangeChildren.clear();
    for (const child of Array.from(this.livePreviewRangeChildren)) {
      try {
        child.unload();
      } catch (e) {
      }
    }
    this.livePreviewRangeChildren.clear();
    for (const timer of this.readingRangeDebounceTimers.values()) {
      try {
        window.clearTimeout(timer);
      } catch (e) {
      }
    }
    this.readingRangeDebounceTimers.clear();
    this.readingRangeEmbedsByPath.clear();
    this.livePreviewRangeEmbedsByPath.clear();
  }
  installReadingRangeObserver() {
    if (this.readingRangeObserver)
      return;
    const root = this.plugin.app.workspace.containerEl;
    if (!root)
      return;
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        for (const removed of Array.from(mutation.removedNodes)) {
          if (!(removed instanceof HTMLElement))
            continue;
          this.cleanupReadingRangeChildrenInNode(removed);
        }
        for (const added of Array.from(mutation.addedNodes)) {
          if (!(added instanceof HTMLElement))
            continue;
          this.scanReadingRangeEmbedsInNode(added, null, "mutation");
        }
      }
    });
    try {
      observer.observe(root, { childList: true, subtree: true });
      this.readingRangeObserver = observer;
    } catch (e) {
      return;
    }
    this.scanReadingRangeEmbedsInNode(root, null, "initial-scan");
  }
  scanReadingRangeEmbedsInNode(node, sourcePath, origin) {
    var _a2, _b2, _c2;
    const hasAnyEmbeds = ((_a2 = node.matches) == null ? void 0 : _a2.call(node, ".internal-embed.markdown-embed")) || ((_b2 = node.querySelector) == null ? void 0 : _b2.call(node, ".internal-embed.markdown-embed")) !== null;
    if (!hasAnyEmbeds)
      return;
    const embeds = ((_c2 = node.matches) == null ? void 0 : _c2.call(node, ".internal-embed.markdown-embed")) ? [node] : Array.from(node.querySelectorAll(".internal-embed.markdown-embed"));
    for (const embedEl of embeds) {
      this.ensureReadingRangeEmbedChild(embedEl, sourcePath, origin);
      this.ensureLivePreviewRangeEmbedChild(embedEl, sourcePath, origin);
    }
  }
  cleanupReadingRangeChildrenInNode(node) {
    var _a2, _b2, _c2;
    const hasAnyEmbeds = ((_a2 = node.matches) == null ? void 0 : _a2.call(node, ".internal-embed.markdown-embed")) || ((_b2 = node.querySelector) == null ? void 0 : _b2.call(node, ".internal-embed.markdown-embed")) !== null;
    if (!hasAnyEmbeds)
      return;
    const embeds = ((_c2 = node.matches) == null ? void 0 : _c2.call(node, ".internal-embed.markdown-embed")) ? [node] : Array.from(node.querySelectorAll(".internal-embed.markdown-embed"));
    for (const embedEl of embeds) {
      const readingChild = this.readingRangeChildByEmbed.get(embedEl);
      if (readingChild) {
        this.debugLog("reading:unload", embedEl.getAttribute("src"));
        try {
          readingChild.unload();
        } catch (e) {
        } finally {
          this.readingRangeChildByEmbed.delete(embedEl);
          this.readingRangeChildren.delete(readingChild);
        }
      }
      const liveChild = this.livePreviewRangeChildByEmbed.get(embedEl);
      if (liveChild) {
        this.debugLog("live-preview:unload", embedEl.getAttribute("src"));
        try {
          liveChild.unload();
        } catch (e) {
        } finally {
          this.livePreviewRangeChildByEmbed.delete(embedEl);
          this.livePreviewRangeChildren.delete(liveChild);
        }
      }
    }
  }
  getSourcePathForEmbedElement(embedEl) {
    let sourcePath = null;
    try {
      this.plugin.app.workspace.iterateAllLeaves((leaf) => {
        var _a2;
        if (sourcePath)
          return;
        const view = leaf.view;
        if (!(view instanceof import_obsidian7.MarkdownView))
          return;
        if (!view.file)
          return;
        if (!((_a2 = view.containerEl) == null ? void 0 : _a2.contains(embedEl)))
          return;
        sourcePath = view.file.path;
      });
    } catch (e) {
    }
    return sourcePath;
  }
  ensureReadingRangeEmbedChild(embedEl, sourcePath, origin) {
    var _a2, _b2, _c2, _d2, _e2;
    if (this.readingRangeChildByEmbed.has(embedEl))
      return;
    if (!embedEl.isConnected)
      return;
    if (embedEl.closest(".markdown-source-view")) {
      this.debugSkip(embedEl, "reading:skip:source-view", { origin });
      return;
    }
    if (embedEl.classList.contains(INLINE_EDIT_ACTIVE_CLASS)) {
      this.debugSkip(embedEl, "reading:skip:inline-edit-active", { origin });
      return;
    }
    if (this.leaves.isNestedWithinEmbed(embedEl)) {
      this.debugSkip(embedEl, "reading:skip:nested", { origin });
      return;
    }
    if (embedEl.classList.contains(READING_RANGE_ACTIVE_CLASS))
      return;
    const resolvedSourcePath = (_c2 = (_b2 = sourcePath != null ? sourcePath : this.getSourcePathForEmbedElement(embedEl)) != null ? _b2 : (_a2 = this.plugin.app.workspace.getActiveFile()) == null ? void 0 : _a2.path) != null ? _c2 : "";
    const parsed = this.parseRangeEmbedForReading(embedEl, resolvedSourcePath);
    if (!parsed) {
      const src = (_d2 = embedEl.getAttribute("src")) != null ? _d2 : "";
      const alt = (_e2 = embedEl.getAttribute("alt")) != null ? _e2 : "";
      if (/#\^([a-z0-9_]+)-\1$/i.test(src.split("|")[0]) || /\^([a-z0-9_]+)-\1$/i.test(alt)) {
        this.debugSkip(embedEl, "reading:skip:parse-failed", {
          origin,
          src,
          alt,
          sourcePath: resolvedSourcePath
        });
      }
      return;
    }
    this.debugLog("reading:attach", {
      origin,
      src: embedEl.getAttribute("src"),
      alt: embedEl.getAttribute("alt"),
      sourcePath: resolvedSourcePath,
      file: parsed.file.path,
      subpath: parsed.subpath
    });
    const child = new ReadingRangeEmbedChild({
      plugin: this.plugin,
      embedEl,
      file: parsed.file,
      subpath: parsed.subpath,
      registerEmbed: this.registerReadingRangeEmbed.bind(this),
      unregisterEmbed: this.unregisterReadingRangeEmbed.bind(this)
    });
    this.readingRangeChildByEmbed.set(embedEl, child);
    this.readingRangeChildren.add(child);
    child.register(() => {
      this.readingRangeChildren.delete(child);
      this.readingRangeChildByEmbed.delete(embedEl);
    });
    child.load();
  }
  ensureLivePreviewRangeEmbedChild(embedEl, sourcePath, origin) {
    var _a2, _b2, _c2, _d2, _e2;
    if (this.livePreviewRangeChildByEmbed.has(embedEl))
      return;
    if (!embedEl.isConnected)
      return;
    if (!embedEl.closest(".markdown-source-view")) {
      this.debugSkip(embedEl, "live-preview:skip:not-source-view", { origin });
      return;
    }
    if (this.leaves.isNestedWithinEmbed(embedEl)) {
      this.debugSkip(embedEl, "live-preview:skip:nested", { origin });
      return;
    }
    if (embedEl.classList.contains(LIVE_PREVIEW_RANGE_ACTIVE_CLASS))
      return;
    if (embedEl.classList.contains(INLINE_EDIT_ACTIVE_CLASS))
      return;
    const resolvedSourcePath = (_c2 = (_b2 = sourcePath != null ? sourcePath : this.getSourcePathForEmbedElement(embedEl)) != null ? _b2 : (_a2 = this.plugin.app.workspace.getActiveFile()) == null ? void 0 : _a2.path) != null ? _c2 : "";
    const parsed = this.parseRangeEmbedForReading(embedEl, resolvedSourcePath);
    if (!parsed) {
      const src = (_d2 = embedEl.getAttribute("src")) != null ? _d2 : "";
      const alt = (_e2 = embedEl.getAttribute("alt")) != null ? _e2 : "";
      if (/#\^([a-z0-9_]+)-\1$/i.test(src.split("|")[0]) || /\^([a-z0-9_]+)-\1$/i.test(alt)) {
        this.debugSkip(embedEl, "live-preview:skip:parse-failed", {
          origin,
          src,
          alt,
          sourcePath: resolvedSourcePath
        });
      }
      return;
    }
    this.debugLog("live-preview:attach", {
      origin,
      src: embedEl.getAttribute("src"),
      alt: embedEl.getAttribute("alt"),
      sourcePath: resolvedSourcePath,
      file: parsed.file.path,
      subpath: parsed.subpath
    });
    const child = new LivePreviewRangeEmbedChild({
      plugin: this.plugin,
      embedEl,
      file: parsed.file,
      subpath: parsed.subpath,
      registerEmbed: this.registerLivePreviewRangeEmbed.bind(this),
      unregisterEmbed: this.unregisterLivePreviewRangeEmbed.bind(this)
    });
    this.livePreviewRangeChildByEmbed.set(embedEl, child);
    this.livePreviewRangeChildren.add(child);
    child.register(() => {
      this.livePreviewRangeChildren.delete(child);
      this.livePreviewRangeChildByEmbed.delete(embedEl);
    });
    child.load();
  }
  registerReadingRangeEmbed(filePath, child) {
    let set2 = this.readingRangeEmbedsByPath.get(filePath);
    if (!set2) {
      set2 = /* @__PURE__ */ new Set();
      this.readingRangeEmbedsByPath.set(filePath, set2);
    }
    set2.add(child);
  }
  unregisterReadingRangeEmbed(filePath, child) {
    const set2 = this.readingRangeEmbedsByPath.get(filePath);
    if (!set2)
      return;
    set2.delete(child);
    if (set2.size > 0)
      return;
    this.readingRangeEmbedsByPath.delete(filePath);
    if (this.livePreviewRangeEmbedsByPath.has(filePath))
      return;
    const timer = this.readingRangeDebounceTimers.get(filePath);
    if (timer !== void 0) {
      try {
        window.clearTimeout(timer);
      } catch (e) {
      }
      this.readingRangeDebounceTimers.delete(filePath);
    }
  }
  registerLivePreviewRangeEmbed(filePath, child) {
    let set2 = this.livePreviewRangeEmbedsByPath.get(filePath);
    if (!set2) {
      set2 = /* @__PURE__ */ new Set();
      this.livePreviewRangeEmbedsByPath.set(filePath, set2);
    }
    set2.add(child);
  }
  unregisterLivePreviewRangeEmbed(filePath, child) {
    const set2 = this.livePreviewRangeEmbedsByPath.get(filePath);
    if (!set2)
      return;
    set2.delete(child);
    if (set2.size > 0)
      return;
    this.livePreviewRangeEmbedsByPath.delete(filePath);
    if (this.readingRangeEmbedsByPath.has(filePath))
      return;
    const timer = this.readingRangeDebounceTimers.get(filePath);
    if (timer !== void 0) {
      try {
        window.clearTimeout(timer);
      } catch (e) {
      }
      this.readingRangeDebounceTimers.delete(filePath);
    }
  }
  scheduleReadingRangeRefresh(filePath, delayMs = 200) {
    if (!this.readingRangeEmbedsByPath.has(filePath) && !this.livePreviewRangeEmbedsByPath.has(filePath))
      return;
    const existing = this.readingRangeDebounceTimers.get(filePath);
    if (existing !== void 0) {
      try {
        window.clearTimeout(existing);
      } catch (e) {
      }
    }
    const timer = window.setTimeout(() => {
      this.readingRangeDebounceTimers.delete(filePath);
      const readingEmbeds = this.readingRangeEmbedsByPath.get(filePath);
      if (readingEmbeds) {
        for (const child of Array.from(readingEmbeds)) {
          void child.render();
        }
      }
      const livePreviewEmbeds = this.livePreviewRangeEmbedsByPath.get(filePath);
      if (livePreviewEmbeds) {
        for (const child of Array.from(livePreviewEmbeds)) {
          void child.render();
        }
      }
    }, delayMs);
    this.readingRangeDebounceTimers.set(filePath, timer);
  }
  installCommandRouting() {
    const uninstallers = [];
    try {
      const uninstallExecuteCommand = around(this.plugin.app.commands, {
        executeCommand: (old) => {
          const engine = this;
          return function(command, ...args) {
            var _a2;
            const focusedEmbed = engine.focus.getFocused();
            const editor = (_a2 = focusedEmbed == null ? void 0 : focusedEmbed.view) == null ? void 0 : _a2.editor;
            const isEditorCommand2 = typeof (command == null ? void 0 : command.editorCallback) === "function" || typeof (command == null ? void 0 : command.editorCheckCallback) === "function" || typeof (command == null ? void 0 : command.id) === "string" && command.id.startsWith("editor:");
            if (focusedEmbed && editor && isEditorCommand2) {
              if (typeof (command == null ? void 0 : command.editorCheckCallback) === "function") {
                try {
                  return command.editorCheckCallback(false, editor, focusedEmbed.view);
                } catch (e) {
                }
              }
              if (typeof (command == null ? void 0 : command.editorCallback) === "function") {
                try {
                  return command.editorCallback(editor, focusedEmbed.view);
                } catch (e) {
                }
              }
              engine.commandRoutingDepth += 1;
              try {
                return old.call(this, command, ...args);
              } finally {
                engine.commandRoutingDepth -= 1;
              }
            }
            return old.call(this, command, ...args);
          };
        }
      });
      uninstallers.push(uninstallExecuteCommand);
    } catch (error) {
      console.error("InlineEditEngine: failed to patch commands.executeCommand", error);
    }
    try {
      const uninstallGetActiveView = around(this.plugin.app.workspace, {
        getActiveViewOfType: (old) => {
          const engine = this;
          return function(type2) {
            if (engine.commandRoutingDepth > 0) {
              const focusedEmbed = engine.focus.getFocused();
              if (focusedEmbed && focusedEmbed.view instanceof type2) {
                return focusedEmbed.view;
              }
            }
            return old.call(this, type2);
          };
        }
      });
      uninstallers.push(uninstallGetActiveView);
    } catch (error) {
      console.error("InlineEditEngine: failed to patch workspace.getActiveViewOfType", error);
    }
    try {
      const uninstallActiveLeaf = this.patchWorkspaceActiveLeafGetter();
      uninstallers.push(uninstallActiveLeaf);
    } catch (error) {
      console.error("InlineEditEngine: failed to patch workspace.activeLeaf", error);
    }
    if (uninstallers.length > 0) {
      this.commandRoutingUninstallers.push(...uninstallers);
    }
  }
  patchWorkspaceActiveLeafGetter() {
    var _a2;
    const workspace = this.plugin.app.workspace;
    const key = "activeLeaf";
    const hadOwn = Object.prototype.hasOwnProperty.call(workspace, key);
    const originalOwnDescriptor = Object.getOwnPropertyDescriptor(workspace, key);
    const originalDescriptor = originalOwnDescriptor;
    if (!originalDescriptor)
      return () => {
      };
    if (originalDescriptor.configurable === false)
      return () => {
      };
    let storedValue = "value" in originalDescriptor ? originalDescriptor.value : workspace[key];
    const originalGetter = originalDescriptor.get;
    const originalSetter = originalDescriptor.set;
    const engine = this;
    Object.defineProperty(workspace, key, {
      configurable: true,
      enumerable: (_a2 = originalDescriptor.enumerable) != null ? _a2 : true,
      get() {
        if (engine.commandRoutingDepth > 0) {
          const focusedEmbed = engine.focus.getFocused();
          if (focusedEmbed == null ? void 0 : focusedEmbed.leaf)
            return focusedEmbed.leaf;
        }
        if (typeof originalGetter === "function") {
          return originalGetter.call(this);
        }
        return storedValue;
      },
      set(value) {
        if (typeof originalSetter === "function") {
          originalSetter.call(this, value);
          return;
        }
        storedValue = value;
      }
    });
    return () => {
      try {
        const currentStored = (() => {
          if (typeof originalGetter === "function") {
            try {
              return originalGetter.call(workspace);
            } catch (e) {
              return storedValue;
            }
          }
          return storedValue;
        })();
        if (hadOwn && originalOwnDescriptor) {
          if ("value" in originalOwnDescriptor) {
            Object.defineProperty(workspace, key, {
              ...originalOwnDescriptor,
              value: currentStored
            });
          } else {
            Object.defineProperty(workspace, key, originalOwnDescriptor);
          }
          return;
        }
        delete workspace[key];
      } catch (e) {
      }
    };
  }
  uninstallCommandRouting() {
    const uninstallers = this.commandRoutingUninstallers.splice(0);
    for (const uninstall of uninstallers) {
      try {
        uninstall();
      } catch (e) {
      }
    }
    this.commandRoutingDepth = 0;
  }
  cleanupHiddenEmbeds() {
    const embeds = this.leaves.getActiveEmbeds();
    for (const embed of embeds) {
      if (!embed.containerEl.isConnected || !embed.containerEl.isShown()) {
        if (this.focus.getFocused() === embed) {
          this.focus.setFocused(null);
        }
        this.leaves.detach(embed);
      }
    }
  }
  disconnectObserverEntry(entry) {
    try {
      entry.observer.disconnect();
    } catch (e) {
    }
    if (entry.scheduled !== null) {
      try {
        window.clearTimeout(entry.scheduled);
      } catch (e) {
      }
      entry.scheduled = null;
    }
    entry.pendingEmbeds.clear();
  }
  disconnectAllObservers() {
    for (const entry of this.livePreviewObservers.values()) {
      this.disconnectObserverEntry(entry);
    }
    this.livePreviewObservers.clear();
  }
  scheduleObserverEntry(entry, delayMs = 25) {
    if (!this.loaded)
      return;
    if (entry.scheduled !== null)
      return;
    entry.scheduled = window.setTimeout(() => {
      entry.scheduled = null;
      void this.processObserverEntry(entry);
    }, delayMs);
  }
  getLivePreviewState(entry) {
    var _a2, _b2, _c2;
    const view = entry.view;
    if (!view.file)
      return "unknown";
    if (view.getMode() === "preview")
      return "not-live";
    if (entry.rootEl.classList.contains("is-live-preview")) {
      return "live";
    }
    const cm = (_a2 = view.editor) == null ? void 0 : _a2.cm;
    if (!cm)
      return "unknown";
    try {
      if (((_c2 = (_b2 = cm.state) == null ? void 0 : _b2.field) == null ? void 0 : _c2.call(_b2, import_obsidian7.editorLivePreviewField, false)) === true) {
        return "live";
      }
    } catch (e) {
    }
    if (Date.now() - entry.createdAt < LIVE_PREVIEW_GRACE_MS) {
      return "unknown";
    }
    return "not-live";
  }
  refreshLivePreviewObservers(forceRescan = false) {
    for (const [view, entry] of this.livePreviewObservers) {
      if (!view.containerEl.isConnected || !entry.rootEl.isConnected || view.getMode() === "preview" || view.containerEl.closest(`.${EmbedLeafManager.INLINE_EDIT_ROOT_CLASS}`)) {
        this.disconnectObserverEntry(entry);
        this.livePreviewObservers.delete(view);
      }
    }
    if (!this.isInlineEditActive())
      return;
    const leaves = this.plugin.app.workspace.getLeavesOfType("markdown");
    for (const leaf of leaves) {
      const view = leaf.view;
      if (!(view instanceof import_obsidian7.MarkdownView))
        continue;
      if (view.getMode() === "preview")
        continue;
      if (view.containerEl.closest(`.${EmbedLeafManager.INLINE_EDIT_ROOT_CLASS}`))
        continue;
      this.ensureLivePreviewObserver(view, forceRescan);
    }
  }
  ensureLivePreviewObserver(view, forceRescan = false) {
    const rootEl = view.containerEl.querySelector(".markdown-source-view");
    if (!rootEl)
      return;
    const existing = this.livePreviewObservers.get(view);
    if (existing && existing.rootEl === rootEl && !forceRescan)
      return;
    if (existing) {
      this.disconnectObserverEntry(existing);
      this.livePreviewObservers.delete(view);
    }
    const entry = {
      view,
      rootEl,
      observer: void 0,
      pendingEmbeds: /* @__PURE__ */ new Set(),
      scheduled: null,
      processing: false,
      createdAt: Date.now()
    };
    entry.observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type !== "childList")
          continue;
        for (const node of mutation.addedNodes) {
          if (!(node instanceof HTMLElement))
            continue;
          const candidates = [];
          if (this.isInternalMarkdownEmbed(node)) {
            candidates.push(node);
          }
          node.querySelectorAll(".internal-embed.markdown-embed").forEach((embed) => {
            candidates.push(embed);
          });
          for (const embed of candidates) {
            if (!embed.isConnected)
              continue;
            if (this.leaves.isNestedWithinEmbed(embed))
              continue;
            entry.pendingEmbeds.add(embed);
          }
        }
      }
      if (entry.pendingEmbeds.size > 0) {
        this.scheduleObserverEntry(entry);
      }
    });
    try {
      entry.observer.observe(rootEl, { childList: true, subtree: true });
    } catch (e) {
    }
    this.livePreviewObservers.set(view, entry);
    rootEl.querySelectorAll(".internal-embed.markdown-embed").forEach((embed) => {
      if (this.leaves.isNestedWithinEmbed(embed))
        return;
      entry.pendingEmbeds.add(embed);
    });
    if (entry.pendingEmbeds.size > 0) {
      this.scheduleObserverEntry(entry);
    }
  }
  async processObserverEntry(entry) {
    if (!this.loaded)
      return;
    if (entry.processing)
      return;
    entry.processing = true;
    try {
      if (!this.isInlineEditActive()) {
        entry.pendingEmbeds.clear();
        return;
      }
      const livePreviewState = this.getLivePreviewState(entry);
      if (livePreviewState === "not-live") {
        entry.pendingEmbeds.clear();
        return;
      }
      if (livePreviewState === "unknown") {
        return;
      }
      const view = entry.view;
      const ctx = {
        sourcePath: view.file.path,
        addChild: () => {
        }
      };
      const embeds = Array.from(entry.pendingEmbeds).filter((el) => el.isConnected);
      entry.pendingEmbeds.clear();
      for (const embedEl of embeds) {
        await this.processInlineEmbed(embedEl, ctx, view);
      }
      this.cleanupHiddenEmbeds();
    } finally {
      entry.processing = false;
      if (entry.pendingEmbeds.size > 0) {
        this.scheduleObserverEntry(entry);
      }
    }
  }
  async waitForEditorView(view, timeoutMs = 2e3) {
    var _a2;
    const deadline = Date.now() + timeoutMs;
    while (Date.now() < deadline) {
      const cm = (_a2 = view.editor) == null ? void 0 : _a2.cm;
      if (cm)
        return cm;
      await new Promise((resolve) => window.setTimeout(resolve, 25));
    }
    return null;
  }
  isInternalMarkdownEmbed(el) {
    return el.classList.contains("internal-embed") && el.classList.contains("markdown-embed");
  }
  isInLivePreview(embedEl) {
    return embedEl.closest(".markdown-source-view") !== null;
  }
  cleanupOrphanedShell(embedEl) {
    if (!embedEl.classList.contains(INLINE_EDIT_ACTIVE_CLASS))
      return;
    if (embedEl.querySelector(`.${EmbedLeafManager.INLINE_EDIT_ROOT_CLASS}`))
      return;
    if (embedEl.querySelector(`.${INLINE_EDIT_HOST_CLASS}`))
      return;
    try {
      embedEl.removeClass(INLINE_EDIT_ACTIVE_CLASS);
    } catch (e) {
    }
  }
  getInternalEmbedLink(embedEl) {
    let embedLink = embedEl.getAttribute("src");
    const altText = embedEl.getAttribute("alt");
    if (!embedLink && altText) {
      const match2 = altText.match(/(.+?)\\s*>\\s*(.+)/);
      if (match2) {
        let subpath = match2[2].trim();
        if (subpath.startsWith("#")) {
          subpath = subpath.slice(1).trim();
        }
        embedLink = `${match2[1].trim()}#${subpath}`;
      }
    }
    return embedLink;
  }
  parseRangeEmbedForReading(embedEl, sourcePath) {
    const embedLink = this.getInternalEmbedLink(embedEl);
    if (!embedLink)
      return null;
    const pipeIndex = embedLink.indexOf("|");
    const actualLink = pipeIndex === -1 ? embedLink : embedLink.substring(0, pipeIndex);
    const hashIndex = actualLink.indexOf("#");
    if (hashIndex === -1)
      return null;
    let notePath = actualLink.substring(0, hashIndex).trim();
    let ref = actualLink.substring(hashIndex + 1).trim();
    if (ref.startsWith("#")) {
      ref = ref.slice(1).trim();
    }
    if (!ref.startsWith("^"))
      return null;
    if (!/^\^[a-zA-Z0-9_-]+$/.test(ref))
      return null;
    if (!/^\^([a-z0-9_]+)-\1$/i.test(ref))
      return null;
    let file = null;
    if (!notePath) {
      const current = this.plugin.app.vault.getAbstractFileByPath(sourcePath);
      if (current instanceof import_obsidian7.TFile) {
        file = current;
      }
    } else {
      file = this.plugin.app.metadataCache.getFirstLinkpathDest(notePath, sourcePath);
    }
    if (!file)
      return null;
    return { file, subpath: `#${ref}` };
  }
  parseBlockIdEmbed(embedEl, ctx) {
    const embedLink = this.getInternalEmbedLink(embedEl);
    if (!embedLink)
      return null;
    const pipeIndex = embedLink.indexOf("|");
    const actualLink = pipeIndex === -1 ? embedLink : embedLink.substring(0, pipeIndex);
    const hashIndex = actualLink.indexOf("#");
    if (hashIndex === -1)
      return null;
    let notePath = actualLink.substring(0, hashIndex).trim();
    const ref = actualLink.substring(hashIndex + 1).trim();
    if (!ref.startsWith("^"))
      return null;
    if (!/^\^[a-zA-Z0-9_-]+$/.test(ref))
      return null;
    const isRange = /^\^([a-z0-9_]+)-\1$/i.test(ref);
    if (!notePath) {
      notePath = ctx.sourcePath;
    }
    const file = this.plugin.app.metadataCache.getFirstLinkpathDest(notePath, ctx.sourcePath);
    if (!file)
      return null;
    const subpath = `#${ref}`;
    const [start, end] = getLineRangeFromRef(file.path, subpath, this.plugin.app);
    if (!start || !end)
      return null;
    return { file, subpath, range: [start, end], isRange };
  }
  parseHeadingEmbed(embedEl, ctx) {
    const embedLink = this.getInternalEmbedLink(embedEl);
    if (!embedLink)
      return null;
    const pipeIndex = embedLink.indexOf("|");
    const actualLink = pipeIndex === -1 ? embedLink : embedLink.substring(0, pipeIndex);
    const hashIndex = actualLink.indexOf("#");
    if (hashIndex === -1)
      return null;
    let notePath = actualLink.substring(0, hashIndex).trim();
    const ref = actualLink.substring(hashIndex + 1).trim();
    if (!ref)
      return null;
    if (ref.startsWith("^"))
      return null;
    if (!notePath) {
      notePath = ctx.sourcePath;
    }
    const file = this.plugin.app.metadataCache.getFirstLinkpathDest(notePath, ctx.sourcePath);
    if (!file)
      return null;
    const subpath = `#${ref}`;
    const [start, end] = getLineRangeFromRef(file.path, subpath, this.plugin.app);
    if (!start || !end)
      return null;
    const editableStart = start + 1;
    if (editableStart > end)
      return null;
    return {
      kind: "heading",
      file,
      subpath,
      visibleRange: [start, end],
      editableRange: [editableStart, end]
    };
  }
  parseInlineEmbed(embedEl, ctx) {
    if (!this.plugin.settings.inlineEditEnabled)
      return null;
    if (this.plugin.settings.inlineEditBlock) {
      const parsedBlock = this.parseBlockIdEmbed(embedEl, ctx);
      if (parsedBlock) {
        return {
          kind: parsedBlock.isRange ? "range" : "block",
          file: parsedBlock.file,
          subpath: parsedBlock.subpath,
          visibleRange: parsedBlock.range,
          editableRange: parsedBlock.range
        };
      }
    }
    if (this.plugin.settings.inlineEditHeading) {
      return this.parseHeadingEmbed(embedEl, ctx);
    }
    return null;
  }
  cleanupLegacyMultilineEmbed(embedEl) {
    var _a2, _b2, _c2, _d2;
    if (!embedEl.classList.contains("mk-multiline-block") && !embedEl.querySelector(".mk-multiline-react-container")) {
      return;
    }
    try {
      (_a2 = embedEl.querySelector(".mk-multiline-react-container")) == null ? void 0 : _a2.remove();
    } catch (e) {
    }
    try {
      (_b2 = embedEl.querySelector(".mk-multiline-jump-link")) == null ? void 0 : _b2.remove();
    } catch (e) {
    }
    try {
      (_c2 = embedEl.querySelector(".mk-multiline-external-edit")) == null ? void 0 : _c2.remove();
    } catch (e) {
    }
    try {
      (_d2 = embedEl.querySelector(".mk-floweditor")) == null ? void 0 : _d2.remove();
    } catch (e) {
    }
    try {
      embedEl.classList.remove("mk-multiline-block");
      embedEl.classList.remove("mk-multiline-readonly");
    } catch (e) {
    }
    const nativeContent = embedEl.querySelector(".markdown-embed-content");
    if (nativeContent) {
      try {
        nativeContent.style.display = "";
      } catch (e) {
      }
    }
    const nativeLink = embedEl.querySelector(".markdown-embed-link");
    if (nativeLink) {
      try {
        nativeLink.style.display = "";
      } catch (e) {
      }
    }
  }
  getIndentWidth(text) {
    let width = 0;
    for (let i = 0; i < text.length; i++) {
      width += text[i] === "	" ? 4 : 1;
    }
    return width;
  }
  stripBlockquotePrefix(line, depth) {
    if (depth <= 0)
      return { ok: true, text: line };
    let remaining = line;
    for (let i = 0; i < depth; i++) {
      const match2 = remaining.match(/^[ \t]*>[ \t]?/);
      if (!match2)
        return { ok: false, text: remaining };
      remaining = remaining.slice(match2[0].length);
    }
    return { ok: true, text: remaining };
  }
  extendListItemBlockEndLine(doc, visibleStart, visibleEnd) {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    let startText = "";
    try {
      startText = (_a2 = doc.line(visibleStart).text) != null ? _a2 : "";
    } catch (e) {
      return visibleEnd;
    }
    const listItemMatch = startText.match(/^((?:[ \t]*>[ \t]*)*)([ \t]*)(?:[-+*]|\d+[.)])[ \t]+/);
    if (!listItemMatch)
      return visibleEnd;
    const quoteDepth = ((_b2 = listItemMatch[1].match(/>/g)) != null ? _b2 : []).length;
    const baseIndentWidth = this.getIndentWidth((_c2 = listItemMatch[2]) != null ? _c2 : "");
    let endLine = visibleEnd;
    for (let lineNumber = visibleEnd + 1; lineNumber <= doc.lines; lineNumber++) {
      let lineText = "";
      try {
        lineText = (_d2 = doc.line(lineNumber).text) != null ? _d2 : "";
      } catch (e) {
        break;
      }
      const stripped = this.stripBlockquotePrefix(lineText, quoteDepth);
      if (!stripped.ok)
        break;
      const normalized = stripped.text;
      if (normalized.trim() === "") {
        endLine = lineNumber;
        continue;
      }
      const leadingWhitespace = (_f2 = (_e2 = normalized.match(/^[ \t]*/)) == null ? void 0 : _e2[0]) != null ? _f2 : "";
      const indentWidth = this.getIndentWidth(leadingWhitespace);
      if (indentWidth > baseIndentWidth) {
        endLine = lineNumber;
        continue;
      }
      break;
    }
    return endLine;
  }
  resolveEmbedLineRanges(parsed, cm) {
    var _a2;
    const doc = (_a2 = cm == null ? void 0 : cm.state) == null ? void 0 : _a2.doc;
    if (!(doc == null ? void 0 : doc.line) || typeof doc.lines !== "number") {
      return { visibleRange: parsed.visibleRange, editableRange: parsed.editableRange };
    }
    let [start, end] = parsed.visibleRange;
    if (start > end) {
      [start, end] = [end, start];
    }
    const clamp3 = (line) => Math.min(Math.max(1, line), doc.lines);
    const visibleStart = clamp3(start);
    const visibleEnd = clamp3(end);
    if (parsed.kind !== "range") {
      let [editableStart, editableEnd] = parsed.editableRange;
      if (editableStart > editableEnd) {
        [editableStart, editableEnd] = [editableEnd, editableStart];
      }
      const normalizedEditableStart = clamp3(Math.max(visibleStart, editableStart));
      const normalizedEditableEnd = clamp3(Math.min(visibleEnd, editableEnd));
      const extendedVisibleEnd = parsed.kind === "block" ? this.extendListItemBlockEndLine(doc, visibleStart, visibleEnd) : visibleEnd;
      const extendedEditableEnd = parsed.kind === "block" ? Math.max(normalizedEditableEnd, extendedVisibleEnd) : normalizedEditableEnd;
      return {
        visibleRange: [visibleStart, extendedVisibleEnd],
        editableRange: [
          normalizedEditableStart,
          Math.max(normalizedEditableStart, Math.min(extendedVisibleEnd, extendedEditableEnd))
        ]
      };
    }
    const marker = parsed.subpath.startsWith("#") ? parsed.subpath.slice(1) : parsed.subpath;
    const isMarkerLine = (lineNumber) => {
      var _a3;
      try {
        const text = (_a3 = doc.line(lineNumber).text) != null ? _a3 : "";
        return text.trim() === marker;
      } catch (e) {
        return false;
      }
    };
    if (isMarkerLine(visibleEnd)) {
      const editableEnd = clamp3(Math.max(visibleStart, visibleEnd - 1));
      return { visibleRange: [visibleStart, visibleEnd], editableRange: [visibleStart, editableEnd] };
    }
    const nextLine = visibleEnd + 1;
    if (nextLine <= doc.lines && isMarkerLine(nextLine)) {
      return { visibleRange: [visibleStart, nextLine], editableRange: [visibleStart, visibleEnd] };
    }
    return { visibleRange: [visibleStart, visibleEnd], editableRange: [visibleStart, visibleEnd] };
  }
  prepareEmbedShell(embedEl) {
    var _a2, _b2, _c2, _d2;
    embedEl.addClass(INLINE_EDIT_ACTIVE_CLASS);
    let nativeContent = embedEl.querySelector(".markdown-embed-content");
    let nativeLink = embedEl.querySelector(".markdown-embed-link");
    let contentParent = (_a2 = nativeContent == null ? void 0 : nativeContent.parentElement) != null ? _a2 : null;
    let contentNext = (_b2 = nativeContent == null ? void 0 : nativeContent.nextSibling) != null ? _b2 : null;
    let linkParent = (_c2 = nativeLink == null ? void 0 : nativeLink.parentElement) != null ? _c2 : null;
    let linkNext = (_d2 = nativeLink == null ? void 0 : nativeLink.nextSibling) != null ? _d2 : null;
    const detachNative = (el) => {
      if (!el)
        return;
      try {
        el.detach();
        return;
      } catch (e) {
      }
      try {
        el.remove();
      } catch (e) {
      }
    };
    const scanAndDetach = () => {
      var _a3, _b3, _c3, _d3;
      const currentContent = embedEl.querySelector(".markdown-embed-content");
      if (currentContent) {
        if (!nativeContent) {
          nativeContent = currentContent;
          contentParent = (_a3 = currentContent.parentElement) != null ? _a3 : contentParent;
          contentNext = (_b3 = currentContent.nextSibling) != null ? _b3 : contentNext;
        }
        detachNative(currentContent);
      }
      const currentLink = embedEl.querySelector(".markdown-embed-link");
      if (currentLink) {
        if (!nativeLink) {
          nativeLink = currentLink;
          linkParent = (_c3 = currentLink.parentElement) != null ? _c3 : linkParent;
          linkNext = (_d3 = currentLink.nextSibling) != null ? _d3 : linkNext;
        }
        detachNative(currentLink);
      }
    };
    scanAndDetach();
    let detachObserver = null;
    try {
      detachObserver = new MutationObserver(() => scanAndDetach());
      detachObserver.observe(embedEl, { childList: true, subtree: true });
    } catch (e) {
      detachObserver = null;
    }
    const hostEl = document.createElement("div");
    hostEl.className = INLINE_EDIT_HOST_CLASS;
    try {
      const parent = contentParent != null ? contentParent : embedEl;
      const before = contentNext && parent.contains(contentNext) ? contentNext : null;
      parent.insertBefore(hostEl, before);
    } catch (e) {
      try {
        embedEl.appendChild(hostEl);
      } catch (e2) {
      }
    }
    const cleanup = () => {
      try {
        detachObserver == null ? void 0 : detachObserver.disconnect();
      } catch (e) {
      }
      try {
        hostEl.detach();
      } catch (e) {
      }
      try {
        embedEl.removeClass(INLINE_EDIT_ACTIVE_CLASS);
      } catch (e) {
      }
      try {
        if (nativeLink) {
          const parent = linkParent != null ? linkParent : embedEl;
          const before = linkNext && parent.contains(linkNext) ? linkNext : null;
          parent.insertBefore(nativeLink, before);
        }
      } catch (e) {
      }
      try {
        if (nativeContent) {
          const parent = contentParent != null ? contentParent : embedEl;
          const before = contentNext && parent.contains(contentNext) ? contentNext : null;
          parent.insertBefore(nativeContent, before);
        }
      } catch (e) {
      }
    };
    return { hostEl, cleanup };
  }
  attachHostRemeasure(hostEl, hostView) {
    var _a2;
    const hostCm = (_a2 = hostView == null ? void 0 : hostView.editor) == null ? void 0 : _a2.cm;
    if (!(hostCm == null ? void 0 : hostCm.requestMeasure))
      return () => {
      };
    let raf = null;
    const schedule = () => {
      if (raf !== null)
        return;
      raf = window.requestAnimationFrame(() => {
        raf = null;
        try {
          hostCm.requestMeasure();
        } catch (e) {
        }
      });
    };
    let observer = null;
    if (typeof ResizeObserver !== "undefined") {
      try {
        observer = new ResizeObserver(() => schedule());
        observer.observe(hostEl);
      } catch (e) {
        observer = null;
      }
    }
    schedule();
    window.setTimeout(schedule, 50);
    return () => {
      if (raf !== null) {
        try {
          window.cancelAnimationFrame(raf);
        } catch (e) {
        }
      }
      if (observer) {
        try {
          observer.disconnect();
        } catch (e) {
        }
      }
    };
  }
  async processInlineEmbed(embedEl, ctx, hostView) {
    await this.mountInlineEmbedCore(embedEl, ctx, { requireLivePreview: true, hostView, origin: "live-preview" });
  }
  async mountInlineEmbedCore(embedEl, ctx, opts) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g, _h, _i, _j, _k;
    if (opts.requireLivePreview && !this.isInLivePreview(embedEl)) {
      this.debugSkip(embedEl, "skip:not-live-preview", { origin: opts.origin });
      return;
    }
    if (this.leaves.isNestedWithinEmbed(embedEl)) {
      this.debugSkip(embedEl, "skip:nested", { origin: opts.origin });
      return;
    }
    if (this.leaves.isLegacyDoubleBangEmbed(embedEl)) {
      this.debugSkip(embedEl, "skip:legacy-doublebang", { origin: opts.origin });
      return;
    }
    this.cleanupOrphanedShell(embedEl);
    if (embedEl.querySelector(`.${EmbedLeafManager.INLINE_EDIT_ROOT_CLASS}`)) {
      this.debugSkip(embedEl, "skip:already-mounted", { origin: opts.origin });
      return;
    }
    if (this.pendingEmbeds.has(embedEl)) {
      this.debugSkip(embedEl, "skip:pending", { origin: opts.origin });
      return;
    }
    const parsed = this.parseInlineEmbed(embedEl, ctx);
    if (!parsed) {
      this.debugSkip(embedEl, "skip:parse-failed", {
        origin: opts.origin,
        src: embedEl.getAttribute("src"),
        alt: embedEl.getAttribute("alt"),
        ctxSourcePath: ctx.sourcePath
      });
      return;
    }
    if (parsed.kind === "range") {
      this.cleanupLegacyMultilineEmbed(embedEl);
      try {
        this.cleanupReadingRangeChildrenInNode(embedEl);
      } catch (e) {
      }
    }
    this.pendingEmbeds.add(embedEl);
    const { hostEl, cleanup } = this.prepareEmbedShell(embedEl);
    try {
      this.debugLog("mount:start", {
        src: embedEl.getAttribute("src"),
        kind: parsed.kind,
        filePath: parsed.file.path,
        subpath: parsed.subpath,
        visibleRange: parsed.visibleRange,
        editableRange: parsed.editableRange,
        origin: opts.origin
      });
      const embed = await this.leaves.createEmbedLeaf({
        containerEl: hostEl,
        file: parsed.file,
        sourcePath: ctx.sourcePath,
        subpath: parsed.subpath
      });
      const stopPropagation = (event) => {
        event.stopPropagation();
      };
      const focusEditor = (event) => {
        var _a3;
        event.stopPropagation();
        (_a3 = embed.view.editor) == null ? void 0 : _a3.focus();
      };
      hostEl.addEventListener("mousedown", focusEditor);
      hostEl.addEventListener("click", focusEditor);
      hostEl.addEventListener("keydown", stopPropagation);
      const stopRemeasure = this.attachHostRemeasure(hostEl, opts.hostView);
      embed.restore = () => {
        try {
          stopRemeasure();
        } catch (e) {
        }
        try {
          hostEl.removeEventListener("mousedown", focusEditor);
        } catch (e) {
        }
        try {
          hostEl.removeEventListener("click", focusEditor);
        } catch (e) {
        }
        try {
          hostEl.removeEventListener("keydown", stopPropagation);
        } catch (e) {
        }
        cleanup();
      };
      if (!hostEl.isConnected) {
        this.leaves.detach(embed);
        return;
      }
      this.leaves.reparent(hostEl, embed.view.containerEl);
      const cm = await this.waitForEditorView(embed.view);
      if (cm) {
        try {
          cm.contentDOM.contentEditable = "true";
        } catch (e) {
        }
        try {
          (_a2 = cm.requestMeasure) == null ? void 0 : _a2.call(cm);
        } catch (e) {
        }
        this.ensureEmbedEditorExtensions(cm);
        const resolvedRanges = this.resolveEmbedLineRanges(parsed, cm);
        try {
          cm.__blpInlineEditResolvedVisibleRange = resolvedRanges.visibleRange;
          cm.__blpInlineEditResolvedEditableRange = resolvedRanges.editableRange;
        } catch (e) {
        }
        const prevState = cm.state;
        cm.dispatch({
          filter: false,
          annotations: [
            contentRange.of(resolvedRanges.visibleRange),
            editableRange.of(resolvedRanges.editableRange)
          ]
        });
        try {
          cm.__blpInlineEditStateChanged = prevState !== cm.state;
          const dec = cm.state.field(hideLine, false);
          let count = 0;
          if (dec && typeof dec.between === "function") {
            dec.between(0, cm.state.doc.length, () => {
              count += 1;
            });
          }
          cm.__blpInlineEditHideLineDecCount = count;
          cm.__blpInlineEditContentRange = (_b2 = cm.state.field(frontmatterFacet, false)) != null ? _b2 : null;
          cm.__blpInlineEditEditableRange = (_c2 = cm.state.field(selectiveLinesFacet, false)) != null ? _c2 : null;
        } catch (e) {
        }
        try {
          const startLine = Math.max(0, resolvedRanges.editableRange[0] - 1);
          (_d2 = embed.view.editor) == null ? void 0 : _d2.setCursor({ line: startLine, ch: 0 });
          (_e2 = embed.view.editor) == null ? void 0 : _e2.scrollIntoView(
            { from: { line: startLine, ch: 0 }, to: { line: startLine, ch: 0 } },
            true
          );
        } catch (e) {
        }
      } else {
        this.debugLog("mount:no-cm", embedEl.getAttribute("src"));
      }
      try {
        (_i = (_h = (_g = (_f2 = opts.hostView) == null ? void 0 : _f2.editor) == null ? void 0 : _g.cm) == null ? void 0 : _h.requestMeasure) == null ? void 0 : _i.call(_h);
      } catch (e) {
      }
      this.debugLog("mount:done", embedEl.getAttribute("src"));
    } catch (error) {
      cleanup();
      try {
        window.__blpInlineEditLastError = String((_j = error == null ? void 0 : error.message) != null ? _j : error);
        window.__blpInlineEditLastErrorStack = String((_k = error == null ? void 0 : error.stack) != null ? _k : "");
      } catch (e) {
      }
      console.error("InlineEditEngine: failed to mount embed editor", error);
    } finally {
      this.pendingEmbeds.delete(embedEl);
    }
  }
};
var LivePreviewRangeEmbedChild = class extends import_obsidian7.MarkdownRenderChild {
  constructor(args) {
    super(args.embedEl);
    this.renderSeq = 0;
    this.mounted = false;
    this.activated = false;
    this.renderChild = null;
    this.retryTimer = null;
    this.retryCount = 0;
    this.nativeContentEl = null;
    this.hostEl = null;
    this.plugin = args.plugin;
    this.embedEl = args.embedEl;
    this.file = args.file;
    this.subpath = args.subpath;
    this.registerEmbed = args.registerEmbed;
    this.unregisterEmbed = args.unregisterEmbed;
  }
  onload() {
    this.mounted = true;
    void this.render();
  }
  onunload() {
    var _a2;
    this.mounted = false;
    if (this.retryTimer !== null) {
      try {
        window.clearTimeout(this.retryTimer);
      } catch (e) {
      }
      this.retryTimer = null;
    }
    if (this.activated) {
      try {
        this.embedEl.classList.remove(LIVE_PREVIEW_RANGE_ACTIVE_CLASS);
      } catch (e) {
      }
      try {
        this.unregisterEmbed(this.file.path, this);
      } catch (e) {
      }
    }
    try {
      (_a2 = this.renderChild) == null ? void 0 : _a2.unload();
    } catch (e) {
    }
    this.renderChild = null;
    this.showNativeEmbed();
    this.removeHostEl();
    this.nativeContentEl = null;
  }
  scheduleRetry(delayMs) {
    if (!this.mounted)
      return;
    if (this.retryTimer !== null)
      return;
    if (this.retryCount >= 60)
      return;
    this.retryCount += 1;
    this.retryTimer = window.setTimeout(() => {
      this.retryTimer = null;
      void this.render();
    }, delayMs);
  }
  getNativeContentEl() {
    var _a2;
    if ((_a2 = this.nativeContentEl) == null ? void 0 : _a2.isConnected)
      return this.nativeContentEl;
    const el = this.embedEl.querySelector(".markdown-embed-content");
    this.nativeContentEl = el;
    return el;
  }
  getOrCreateHostEl() {
    var _a2, _b2;
    if ((_a2 = this.hostEl) == null ? void 0 : _a2.isConnected)
      return this.hostEl;
    const existing = this.embedEl.querySelector(`.${LIVE_PREVIEW_RANGE_HOST_CLASS}`);
    if (existing) {
      this.hostEl = existing;
      return existing;
    }
    const host = document.createElement("div");
    host.className = LIVE_PREVIEW_RANGE_HOST_CLASS;
    host.style.display = "none";
    const nativeContent = this.getNativeContentEl();
    const parent = (_b2 = nativeContent == null ? void 0 : nativeContent.parentElement) != null ? _b2 : this.embedEl;
    try {
      parent.insertBefore(host, nativeContent != null ? nativeContent : null);
    } catch (e) {
      try {
        parent.appendChild(host);
      } catch (e2) {
      }
    }
    this.hostEl = host;
    return host;
  }
  showNativeEmbed() {
    const nativeContent = this.getNativeContentEl();
    if (nativeContent) {
      try {
        nativeContent.style.display = "";
      } catch (e) {
      }
    }
    if (this.hostEl) {
      try {
        this.hostEl.style.display = "none";
      } catch (e) {
      }
    }
  }
  showRangeEmbed() {
    const nativeContent = this.getNativeContentEl();
    if (nativeContent) {
      try {
        nativeContent.style.display = "none";
      } catch (e) {
      }
    }
    const host = this.getOrCreateHostEl();
    if (host) {
      try {
        host.style.display = "";
      } catch (e) {
      }
    }
  }
  removeHostEl() {
    if (!this.hostEl)
      return;
    try {
      this.hostEl.remove();
    } catch (e) {
    }
    this.hostEl = null;
  }
  cleanupLegacyMultilineShell() {
    var _a2, _b2, _c2, _d2;
    try {
      (_a2 = this.embedEl.querySelector(".mk-multiline-react-container")) == null ? void 0 : _a2.remove();
    } catch (e) {
    }
    try {
      (_b2 = this.embedEl.querySelector(".mk-multiline-jump-link")) == null ? void 0 : _b2.remove();
    } catch (e) {
    }
    try {
      (_c2 = this.embedEl.querySelector(".mk-multiline-external-edit")) == null ? void 0 : _c2.remove();
    } catch (e) {
    }
    try {
      (_d2 = this.embedEl.querySelector(".mk-floweditor")) == null ? void 0 : _d2.remove();
    } catch (e) {
    }
    try {
      this.embedEl.classList.remove("mk-multiline-block");
      this.embedEl.classList.remove("mk-multiline-readonly");
    } catch (e) {
    }
    const nativeContent = this.embedEl.querySelector(".markdown-embed-content");
    if (nativeContent) {
      try {
        nativeContent.style.display = "";
      } catch (e) {
      }
    }
    const nativeLink = this.embedEl.querySelector(".markdown-embed-link");
    if (nativeLink) {
      try {
        nativeLink.style.display = "";
      } catch (e) {
      }
    }
    this.showNativeEmbed();
  }
  async render() {
    var _a2, _b2;
    if (!this.mounted)
      return;
    if (!this.embedEl.isConnected) {
      this.scheduleRetry(50);
      return;
    }
    if (!this.embedEl.closest(".markdown-source-view")) {
      return;
    }
    if (this.embedEl.classList.contains(INLINE_EDIT_ACTIVE_CLASS) || this.embedEl.querySelector(`.${INLINE_EDIT_HOST_CLASS}`) || this.embedEl.querySelector(`.${EmbedLeafManager.INLINE_EDIT_ROOT_CLASS}`)) {
      return;
    }
    if (!this.activated) {
      this.activated = true;
      try {
        this.embedEl.classList.add(LIVE_PREVIEW_RANGE_ACTIVE_CLASS);
      } catch (e) {
      }
      this.cleanupLegacyMultilineShell();
      this.registerEmbed(this.file.path, this);
    }
    if (!this.embedEl.classList.contains("is-loaded")) {
      this.scheduleRetry(50);
      return;
    }
    const currentSeq = this.renderSeq += 1;
    if (typeof ((_a2 = import_obsidian7.MarkdownRenderer) == null ? void 0 : _a2.renderMarkdown) !== "function") {
      this.showNativeEmbed();
      return;
    }
    const contentEl = this.getNativeContentEl();
    if (!contentEl) {
      this.scheduleRetry(50);
      return;
    }
    const hostEl = this.getOrCreateHostEl();
    if (!hostEl) {
      this.showNativeEmbed();
      this.scheduleRetry(50);
      return;
    }
    const [start, end] = getLineRangeFromRef(this.file.path, this.subpath, this.plugin.app);
    if (!start || !end) {
      this.showNativeEmbed();
      this.scheduleRetry(100);
      return;
    }
    let raw = "";
    try {
      raw = await this.plugin.app.vault.cachedRead(this.file);
    } catch (e) {
      this.showNativeEmbed();
      this.scheduleRetry(200);
      return;
    }
    if (!this.mounted)
      return;
    if (currentSeq !== this.renderSeq)
      return;
    if (this.embedEl.classList.contains(INLINE_EDIT_ACTIVE_CLASS) || this.embedEl.querySelector(`.${INLINE_EDIT_HOST_CLASS}`) || this.embedEl.querySelector(`.${EmbedLeafManager.INLINE_EDIT_ROOT_CLASS}`)) {
      return;
    }
    const lines = raw.split(/\r?\n/);
    const clamp3 = (line) => Math.min(Math.max(1, line), Math.max(1, lines.length));
    const from = clamp3(Math.min(start, end));
    const to = clamp3(Math.max(start, end));
    const fragment = lines.slice(from - 1, to).join("\n");
    const wrapper = document.createElement("div");
    wrapper.className = "markdown-preview-view markdown-rendered";
    wrapper.style.display = "none";
    const sizer = document.createElement("div");
    sizer.className = "markdown-preview-sizer markdown-preview-section";
    wrapper.appendChild(sizer);
    try {
      hostEl.appendChild(wrapper);
    } catch (e) {
      this.showNativeEmbed();
      this.scheduleRetry(100);
      return;
    }
    const nextChild = new import_obsidian7.MarkdownRenderChild(sizer);
    this.addChild(nextChild);
    nextChild.load();
    try {
      await import_obsidian7.MarkdownRenderer.renderMarkdown(fragment, sizer, this.file.path, nextChild);
    } catch (error) {
      console.error("InlineEditEngine: failed to render live preview range embed", error);
      try {
        nextChild.unload();
      } catch (e) {
      }
      try {
        wrapper.remove();
      } catch (e) {
      }
      this.showNativeEmbed();
      this.scheduleRetry(500);
      return;
    }
    if (!this.mounted) {
      try {
        nextChild.unload();
      } catch (e) {
      }
      return;
    }
    if (currentSeq !== this.renderSeq) {
      try {
        nextChild.unload();
      } catch (e) {
      }
      return;
    }
    try {
      (_b2 = this.renderChild) == null ? void 0 : _b2.unload();
    } catch (e) {
    }
    this.renderChild = nextChild;
    this.retryCount = 0;
    try {
      for (const child of Array.from(hostEl.children)) {
        if (child === wrapper)
          continue;
        child.remove();
      }
    } catch (e) {
    }
    try {
      wrapper.style.display = "";
    } catch (e) {
    }
    this.showRangeEmbed();
  }
};
var ReadingRangeEmbedChild = class extends import_obsidian7.MarkdownRenderChild {
  constructor(args) {
    super(args.embedEl);
    this.renderSeq = 0;
    this.mounted = false;
    this.activated = false;
    this.renderChild = null;
    this.retryTimer = null;
    this.retryCount = 0;
    this.nativeContentEl = null;
    this.hostEl = null;
    this.plugin = args.plugin;
    this.embedEl = args.embedEl;
    this.file = args.file;
    this.subpath = args.subpath;
    this.registerEmbed = args.registerEmbed;
    this.unregisterEmbed = args.unregisterEmbed;
  }
  onload() {
    this.mounted = true;
    void this.render();
  }
  onunload() {
    var _a2;
    this.mounted = false;
    if (this.retryTimer !== null) {
      try {
        window.clearTimeout(this.retryTimer);
      } catch (e) {
      }
      this.retryTimer = null;
    }
    if (this.activated) {
      try {
        this.embedEl.classList.remove(READING_RANGE_ACTIVE_CLASS);
      } catch (e) {
      }
      try {
        this.unregisterEmbed(this.file.path, this);
      } catch (e) {
      }
    }
    try {
      (_a2 = this.renderChild) == null ? void 0 : _a2.unload();
    } catch (e) {
    }
    this.renderChild = null;
    this.showNativeEmbed();
    this.removeHostEl();
    this.nativeContentEl = null;
  }
  scheduleRetry(delayMs) {
    if (!this.mounted)
      return;
    if (this.retryTimer !== null)
      return;
    if (this.retryCount >= 60)
      return;
    this.retryCount += 1;
    this.retryTimer = window.setTimeout(() => {
      this.retryTimer = null;
      void this.render();
    }, delayMs);
  }
  getNativeContentEl() {
    var _a2;
    if ((_a2 = this.nativeContentEl) == null ? void 0 : _a2.isConnected)
      return this.nativeContentEl;
    const el = this.embedEl.querySelector(".markdown-embed-content");
    this.nativeContentEl = el;
    return el;
  }
  getOrCreateHostEl() {
    var _a2, _b2;
    if ((_a2 = this.hostEl) == null ? void 0 : _a2.isConnected)
      return this.hostEl;
    const existing = this.embedEl.querySelector(`.${READING_RANGE_HOST_CLASS}`);
    if (existing) {
      this.hostEl = existing;
      return existing;
    }
    const host = document.createElement("div");
    host.className = READING_RANGE_HOST_CLASS;
    host.style.display = "none";
    const nativeContent = this.getNativeContentEl();
    const parent = (_b2 = nativeContent == null ? void 0 : nativeContent.parentElement) != null ? _b2 : this.embedEl;
    try {
      parent.insertBefore(host, nativeContent != null ? nativeContent : null);
    } catch (e) {
      try {
        parent.appendChild(host);
      } catch (e2) {
      }
    }
    this.hostEl = host;
    return host;
  }
  showNativeEmbed() {
    const nativeContent = this.getNativeContentEl();
    if (nativeContent) {
      try {
        nativeContent.style.display = "";
      } catch (e) {
      }
    }
    if (this.hostEl) {
      try {
        this.hostEl.style.display = "none";
      } catch (e) {
      }
    }
  }
  showRangeEmbed() {
    const nativeContent = this.getNativeContentEl();
    if (nativeContent) {
      try {
        nativeContent.style.display = "none";
      } catch (e) {
      }
    }
    const host = this.getOrCreateHostEl();
    if (host) {
      try {
        host.style.display = "";
      } catch (e) {
      }
    }
  }
  removeHostEl() {
    if (!this.hostEl)
      return;
    try {
      this.hostEl.remove();
    } catch (e) {
    }
    this.hostEl = null;
  }
  cleanupLegacyMultilineShell() {
    var _a2, _b2, _c2, _d2;
    try {
      (_a2 = this.embedEl.querySelector(".mk-multiline-react-container")) == null ? void 0 : _a2.remove();
    } catch (e) {
    }
    try {
      (_b2 = this.embedEl.querySelector(".mk-multiline-jump-link")) == null ? void 0 : _b2.remove();
    } catch (e) {
    }
    try {
      (_c2 = this.embedEl.querySelector(".mk-multiline-external-edit")) == null ? void 0 : _c2.remove();
    } catch (e) {
    }
    try {
      (_d2 = this.embedEl.querySelector(".mk-floweditor")) == null ? void 0 : _d2.remove();
    } catch (e) {
    }
    try {
      this.embedEl.classList.remove("mk-multiline-block");
      this.embedEl.classList.remove("mk-multiline-readonly");
    } catch (e) {
    }
    const nativeContent = this.embedEl.querySelector(".markdown-embed-content");
    if (nativeContent) {
      try {
        nativeContent.style.display = "";
      } catch (e) {
      }
    }
    const nativeLink = this.embedEl.querySelector(".markdown-embed-link");
    if (nativeLink) {
      try {
        nativeLink.style.display = "";
      } catch (e) {
      }
    }
    this.showNativeEmbed();
  }
  async render() {
    var _a2, _b2;
    if (!this.mounted)
      return;
    if (!this.embedEl.isConnected) {
      this.scheduleRetry(50);
      return;
    }
    if (this.embedEl.closest(".markdown-source-view")) {
      return;
    }
    if (!this.activated) {
      this.activated = true;
      try {
        this.embedEl.classList.add(READING_RANGE_ACTIVE_CLASS);
      } catch (e) {
      }
      this.cleanupLegacyMultilineShell();
      this.registerEmbed(this.file.path, this);
    }
    if (!this.embedEl.classList.contains("is-loaded")) {
      this.scheduleRetry(50);
      return;
    }
    const currentSeq = this.renderSeq += 1;
    if (typeof ((_a2 = import_obsidian7.MarkdownRenderer) == null ? void 0 : _a2.renderMarkdown) !== "function") {
      this.showNativeEmbed();
      return;
    }
    const contentEl = this.getNativeContentEl();
    if (!contentEl) {
      this.scheduleRetry(50);
      return;
    }
    const hostEl = this.getOrCreateHostEl();
    if (!hostEl) {
      this.showNativeEmbed();
      this.scheduleRetry(50);
      return;
    }
    const [start, end] = getLineRangeFromRef(this.file.path, this.subpath, this.plugin.app);
    if (!start || !end) {
      this.showNativeEmbed();
      this.scheduleRetry(100);
      return;
    }
    let raw = "";
    try {
      raw = await this.plugin.app.vault.cachedRead(this.file);
    } catch (e) {
      this.showNativeEmbed();
      this.scheduleRetry(200);
      return;
    }
    if (!this.mounted)
      return;
    if (currentSeq !== this.renderSeq)
      return;
    const lines = raw.split(/\r?\n/);
    const clamp3 = (line) => Math.min(Math.max(1, line), Math.max(1, lines.length));
    const from = clamp3(Math.min(start, end));
    const to = clamp3(Math.max(start, end));
    const fragment = lines.slice(from - 1, to).join("\n");
    const wrapper = document.createElement("div");
    wrapper.className = "markdown-preview-view markdown-rendered";
    wrapper.style.display = "none";
    const sizer = document.createElement("div");
    sizer.className = "markdown-preview-sizer markdown-preview-section";
    wrapper.appendChild(sizer);
    try {
      hostEl.appendChild(wrapper);
    } catch (e) {
      this.showNativeEmbed();
      this.scheduleRetry(100);
      return;
    }
    const nextChild = new import_obsidian7.MarkdownRenderChild(sizer);
    this.addChild(nextChild);
    nextChild.load();
    try {
      await import_obsidian7.MarkdownRenderer.renderMarkdown(fragment, sizer, this.file.path, nextChild);
    } catch (error) {
      console.error("InlineEditEngine: failed to render reading range embed", error);
      try {
        nextChild.unload();
      } catch (e) {
      }
      try {
        wrapper.remove();
      } catch (e) {
      }
      this.showNativeEmbed();
      this.scheduleRetry(500);
      return;
    }
    if (!this.mounted) {
      try {
        nextChild.unload();
      } catch (e) {
      }
      return;
    }
    if (currentSeq !== this.renderSeq) {
      try {
        nextChild.unload();
      } catch (e) {
      }
      return;
    }
    try {
      (_b2 = this.renderChild) == null ? void 0 : _b2.unload();
    } catch (e) {
    }
    this.renderChild = nextChild;
    this.retryCount = 0;
    try {
      for (const child of Array.from(hostEl.children)) {
        if (child === wrapper)
          continue;
        child.remove();
      }
    } catch (e) {
    }
    try {
      wrapper.style.display = "";
    } catch (e) {
    }
    this.showRangeEmbed();
  }
};

// src/ui/SettingsTab.ts
var import_obsidian10 = require("obsidian");

// src/shared/i18n.ts
var import_moment = __toESM(require_moment());
var T = class {
  constructor() {
    this.lang = "en";
    this.all = {
      en: {
        // Flow Editor buttons - 
        buttons: {
          openFlow: "Open Flow",
          hideFlow: "Hide Flow",
          toggleFlow: "Toggle Flow",
          //  - FlowEditorHover 
          cutTable: "Cut Table",
          deleteTable: "Delete Table"
        },
        //  - 
        labels: {
          noFile: "not found",
          placeholder: "Type ${1} to open the Flow Menu",
          notePlaceholder: "Click to create a new note"
        },
        //  - flowCommands 
        commandPalette: {
          openFlow: "Open Flow Editor",
          closeFlow: "Close Flow Editor"
        },
        //  - FlowEditorHover 
        notice: {
          tableDeleted: "Table deleted"
        },
        // Settings used in SettingsPanel.ts and SettingsTab.ts
        settings: {
          // Plugin title
          pluginTitle: "Block Link Plus",
          // Multi-line behavior
          multiLineHandle: {
            name: "Multi-line block behavior",
            desc: "Define how multi-line selections generate block ids.",
            options: {
              default: "Default",
              addHeading: "Add new heading",
              addMultiBlock: "Add multi block",
              addMultilineBlock: "Add multiline block"
            },
            descriptions: {
              default: "Treats multi-line selections as a single block. Creates one block ID ^abc123 at the end of the selection.",
              addHeading: "Adds a new heading above the selection. Creates a heading with block ID for organization.",
              addMultiBlock: "Creates separate block IDs for each block (paragraph, list item, etc.). Each block gets its own ^abc123 identifier.",
              addMultilineBlock: "Creates a range block with ^abc123-abc123 format. Marks the first line with ^abc123 and marks the range end with ^abc123-abc123 (inline when safe; otherwise inserted on its own line)."
            }
          },
          // Block link section
          blockLink: {
            title: "Block link",
            desc: "Link: [[file#block_id]]",
            enableRightClick: {
              name: "Enable block link in right click menu",
              desc: ""
            },
            enableNotification: {
              name: "Show notification when block link is copied",
              desc: ""
            },
            aliasStyle: {
              name: "Alias style",
              desc: "Choose how to generate aliases for block links. For heading blocks, alias will always be the heading text unless 'No alias' is selected.",
              options: {
                noAlias: "No alias",
                firstChars: "First X chars",
                parentHeading: "Parent heading",
                selectedText: "Selected text"
              },
              descriptions: {
                noAlias: "Links will appear as [[file#^abc123]] without any alias text.",
                firstChars: "Links will use the first X characters of the block content as alias: [[file#^abc123|First few words...]]",
                parentHeading: "Links will use the nearest parent heading as alias: [[file#^abc123|Parent Heading]]",
                selectedText: "Links will use the selected text as alias: [[file#^abc123|Your selected text]]"
              }
            },
            aliasLength: {
              name: "Alias length",
              desc: "Set the length of the alias (1-100). Only used when alias style is 'First X chars'."
            },
            headingIdNewline: {
              name: "Experimental: Heading block ID style",
              desc: "Place block ID in new line when selecting a single heading line only"
            }
          },
          // Embed link section
          embedLink: {
            title: "Embed link",
            desc: "Link: ![[file#block_id]]",
            enableRightClick: {
              name: "Enable embed link in right click menu",
              desc: ""
            },
            enableNotification: {
              name: "Show notification when embed link is copied",
              desc: ""
            }
          },
          // Inline edit
          inlineEdit: {
            title: "Inline edit",
            desc: "Control which ![[...]] embeds are editable in Live Preview.",
            enable: {
              name: "Enable inline edit",
              desc: "If enabled, supported ![[...]] embeds may become editable in Live Preview."
            },
            file: {
              name: "Enable file embeds (![[file]])",
              desc: "If enabled, ![[file]] may become editable in Live Preview."
            },
            heading: {
              name: "Enable heading embeds (![[file#Heading]])",
              desc: "If enabled, ![[file#Heading]] may become editable in Live Preview."
            },
            block: {
              name: "Enable block embeds (![[file#^id]] / ![[file#^id-id]])",
              desc: "If enabled, ![[file#^id]] and ![[file#^id-id]] may become editable in Live Preview."
            }
          },
          // Obsidian URI section
          obsidianUri: {
            title: "Obsidian URI link",
            desc: "Link: obsidian://open?vault=${vault}&file=${filePath}${encodedBlockId}",
            enableRightClick: {
              name: "Enable Obsidian URI link in right click menu",
              desc: ""
            },
            enableNotification: {
              name: "Show notification when URI link is copied",
              desc: ""
            }
          },
          // Block ID section
          blockId: {
            title: "Block Id",
            desc: "Custom block_id",
            maxLength: {
              name: "Max block id Length",
              desc: "Set the maximum number of characters for a block id."
            },
            enablePrefix: {
              name: "Custom id prefix",
              desc: ""
            },
            prefix: {
              name: "Block id prefix",
              desc: "Block id will be: prefix-random_str"
            }
          },
          // Outliner
          fileOutliner: {
            title: "Outliner",
            desc: "Outliner view (Logseq-like) for scoped files. Tail lines use Dataview inline fields + `^id` so `[[file#^id]]` works even without the plugin.",
            groups: {
              scope: {
                title: "Scope"
              },
              routing: {
                title: "Routing"
              },
              display: {
                title: "Display & interactions"
              },
              interactions: {
                title: "Interactions"
              },
              editing: {
                title: "Editing"
              },
              integrations: {
                title: "Integrations"
              },
              debug: {
                title: "Debug"
              },
              behavior: {
                title: "Behavior"
              }
            },
            enabledFolders: {
              name: "Enabled folders (vault-relative)",
              desc: "One per row. Files under these folders will open in the outliner view.",
              addButton: "Add enabled folder",
              placeholder: "Daily"
            },
            enabledFiles: {
              name: "Enabled files (vault-relative)",
              desc: "One per row. Use this when you only want specific files.",
              addButton: "Add enabled file",
              placeholder: "Daily/2026-01-09.md"
            },
            frontmatterOverride: {
              name: "Frontmatter override",
              desc: "Per-file: `blp_outliner: true/false`."
            },
            enableRouting: {
              name: "Enable Outliner",
              desc: "When enabled, scoped files open in the outliner view instead of the native Markdown editor."
            },
            hideSystemTailLines: {
              name: "Hide system tail lines",
              desc: "Hide outliner protocol tail lines in Reading mode when `[blp_sys:: 1]` is present."
            },
            dragAndDrop: {
              name: "Enable drag & drop",
              desc: "Drag the bullet to move blocks and their subtrees."
            },
            zoom: {
              name: "Enable zoom",
              desc: "Click the bullet to zoom into a block subtree."
            },
            emphasisLine: {
              name: "Emphasis line (left)",
              desc: "Emphasize the active block's left connector line. When disabled, it stays muted."
            },
            editorContextMenu: {
              enabled: {
                name: "Editor context menu",
                desc: "Replace the outliner editor right-click menu with a BLP-owned menu (supports plugin allowlist injection)."
              },
              allowedPlugins: {
                name: "Editor menu plugin allowlist",
                desc: "One plugin id per row. Only allowlisted plugins may add items to the outliner editor menu. Add `core` to include core items.",
                addButton: "Add allowlisted plugin",
                placeholder: "metadata-menu"
              }
            },
            editorCommands: {
              enabled: {
                name: "Editor command bridge (shortcuts)",
                desc: "Enable core editor shortcuts (Ctrl+B, etc.) and allowlisted plugin editor commands while editing blocks in Outliner. Note: CM6-injection plugins are not supported."
              },
              allowedPlugins: {
                name: "Editor command plugin allowlist",
                desc: "One plugin id per row. Only allowlisted plugins may run editor commands in Outliner. Add `core` to include core editor commands.",
                addButton: "Add allowlisted plugin",
                placeholder: "highlightr-plugin"
              },
              copyFromMenuAllowlist: {
                name: "Sync allowlists",
                desc: "Copy the editor menu allowlist into the editor command allowlist. Tip: include `core` if you want core formatting shortcuts in Outliner.",
                buttonText: "Copy from editor menu allowlist"
              }
            },
            listEditor: {
              moveUp: "Move up",
              moveDown: "Move down",
              remove: "Remove"
            },
            childrenOnSplit: {
              name: "Enter split: children behavior",
              desc: "Choose what happens to children when splitting a block with Enter.",
              options: {
                keep: "Keep children on the original block",
                move: "Move children to the new block"
              }
            },
            pasteMultiline: {
              name: "Paste multiline",
              desc: "When pasting multiple lines into a block, either split into blocks or keep as multiline.",
              options: {
                split: "Split into multiple blocks (default)",
                multiline: "Keep as multiline text in the current block"
              }
            },
            backspaceWithChildren: {
              name: "Backspace at start (block has children)",
              desc: "Choose whether Backspace merges with previous (default) or outdents the block when it has children.",
              options: {
                merge: "Merge with previous (default)",
                outdent: "Prefer outdent"
              }
            },
            tasksHelp: {
              name: "Tasks",
              desc: 'Task blocks use Obsidian-native `- [ ]` / `- [x]` on disk. Commands: "${toggleTaskStatus}" (Mod+Enter) and "${toggleTaskMarker}" (Mod+Shift+Enter). Configure hotkeys in Settings -> Hotkeys.'
            },
            debug: {
              name: "Debug logging",
              desc: "Log internal outliner errors to the DevTools console."
            },
            commands: {
              toggleTaskStatus: "Outliner: Toggle task status",
              toggleTaskMarker: "Outliner: Toggle task marker"
            },
            contextMenu: {
              copyBlockReference: "Copy block reference",
              copyBlockEmbed: "Copy block embed",
              copyBlockUrl: "Copy block URL",
              convertToTask: "Convert to task",
              convertToNormalBlock: "Convert to normal block",
              copy: "Copy",
              cut: "Cut",
              paste: "Paste",
              pasteAsText: "Paste as text",
              delete: "Delete",
              collapse: "Collapse",
              expand: "Expand"
            }
          },
          // Enhanced List Blocks section
          enhancedListBlocks: {
            title: "Enhanced List",
            desc: "Opt-in scope for Enhanced List Blocks features (blp-view, system line hiding, duplicate ^id repair). A file is enabled if it matches any enabled folder/file below, or has frontmatter `blp_enhanced_list: true`.",
            groups: {
              scopeAndBehavior: {
                title: "Scope & Behavior"
              },
              scope: {
                title: "Enable scope"
              },
              behavior: {
                title: "Behavior"
              },
              blockMode: {
                title: "Block mode"
              },
              normalization: {
                title: "Normalization"
              }
            },
            dataviewStatus: {
              available: "\u2705 Dataview plugin is installed and enabled (v${version})",
              unavailable: "\u274C Dataview plugin is not installed or not enabled. blp-view will not work."
            },
            enabledFolders: {
              name: "Enabled folders",
              desc: "One folder path per line (vault-relative). Markdown files under these folders are enabled."
            },
            enabledFiles: {
              name: "Enabled files",
              desc: "One file path per line (vault-relative). These Markdown files are enabled."
            },
            hideSystemLine: {
              name: "Hide system line",
              desc: "Hide the system line (`[date:: ...] ^id`) in Live Preview and Reading mode. Turn off to show it for debugging."
            },
            handleAffordance: {
              name: "Show list handle affordance",
              desc: "Render unordered list markers as a handle in Live Preview (enabled files only) to make drag/fold interactions easier to discover."
            },
            handleActions: {
              name: "Enable list handle actions",
              desc: "Enable click-to-fold and a right-click handle menu for unordered list handles in Live Preview (enabled files only).",
              clickAction: {
                name: "Handle left-click action",
                desc: "Choose what a left-click on the list handle does. Right-click always opens the handle menu.",
                options: {
                  toggleFolding: "Toggle folding",
                  selectBlock: "Select block",
                  menu: "Open handle menu",
                  none: "None"
                }
              },
              menu: {
                toggleFolding: "Toggle folding",
                copyBlockLink: "Copy block link",
                copyBlockEmbed: "Copy block embed",
                zoomIn: "Zoom in",
                zoomOut: "Zoom out"
              }
            },
            indentCodeBlocks: {
              name: "Indent nested fenced code blocks",
              desc: "Visually indent fenced code blocks inside list items in Live Preview (enabled files only), without changing file content."
            },
            deleteSubtreeOnDelete: {
              name: "Delete children when deleting a list item",
              desc: "If enabled, deleting a parent list item will delete its nested children (Logseq/Roam style). If disabled, children stay and only the system line is removed."
            },
            hideNativeFoldIndicator: {
              name: "Hide Obsidian's built-in fold indicator",
              desc: "Hide the built-in fold triangle shown near list bullets in Live Preview (enabled files only). This reduces accidental fold/unfold when using drag-and-drop."
            },
            subtreeClipboard: {
              name: "Enable subtree clipboard (copy/cut/paste block-tree)",
              desc: "When block selection mode is active, Copy/Cut/Paste operates on list-item subtrees (block-tree semantics) instead of plain text."
            },
            doubleParenTrigger: {
              name: "Enable `((` trigger for block reference insertion",
              desc: "When enabled, typing `((` opens the Block Reference picker and replaces `((` with a standard `[[file#^id]]` reference. Recommended to keep off unless you prefer Roam/Logseq-style triggers."
            },
            blockPeek: {
              name: "Enable Block Peek (context)",
              desc: "Enable Block Peek UI affordances (handle menu + blp-view peek button) for `[[file#^id]]` blocks."
            },
            normalizeOnSave: {
              name: "Normalize list format on save",
              desc: "On save only (enabled files). Applies selected normalization rules to the list items you edited since the last save. No changes while typing.",
              rules: {
                tabsToSpaces: {
                  name: "Convert leading tabs to spaces",
                  desc: "Convert leading indentation tabs to spaces (configurable tab width). To avoid changing list nesting, conversion falls back to Markdown tab semantics when needed. Example (tab width = 2): `\\t- a` -> `  - a`.",
                  tabSize: {
                    name: "Tab width (spaces)",
                    desc: "How many spaces a leading tab expands to during normalization. Default: 2."
                  }
                },
                cleanupInvalidSystemLines: {
                  name: "Remove extra / invalid system lines",
                  desc: "Remove extra system lines in an edited list item (keeps the first one), and removes orphan system lines right above a list item. Example: `  [date:: ...] ^a` + `  [date:: ...] ^b` -> keep only one."
                },
                mergeSplitSystemLine: {
                  name: "Merge split system line",
                  desc: "Merge a two-line system line into one line. Example: `  [date:: 2026-01-26T16:01:21]` + `  ^7fp1` -> `  [date:: 2026-01-26T16:01:21] ^7fp1`."
                },
                systemLineIndent: {
                  name: "Fix system line indentation",
                  desc: "Force system line indentation to the list item's continuation indent (aligned to the content column after `- ` / checkbox). Example: `- a` + `[date:: ...] ^id` -> `- a` + `  [date:: ...] ^id`."
                },
                ensureSystemLineForTouchedItems: {
                  name: "Ensure system line for edited list items",
                  desc: "If an edited list item is missing a system line, insert it on save (and move it above child lists when needed)."
                }
              }
            },
            blpView: {
              title: "blp-view (Query/View)",
              desc: "Guardrails for blp-view execution (requires Dataview).",
              allowMaterialize: {
                name: "Allow materialize writeback",
                desc: "If disabled, blp-view blocks with render.mode=materialize will show an error and won't modify the file."
              },
              maxSourceFiles: {
                name: "Max source files per view",
                desc: "0 = unlimited. If the view needs to scan more files, it will stop with an error."
              },
              maxResults: {
                name: "Max rendered results",
                desc: "0 = unlimited. If more items match, the output will be truncated."
              },
              showDiagnostics: {
                name: "Show blp-view diagnostics",
                desc: "Show counts and timing info under the rendered output."
              }
            },
            ops: {
              title: "Enhanced List Blocks Ops",
              desc: "Outliner-like operations and UI enhancements for list-item subtrees (Live Preview only; enabled files only).",
              zoom: {
                name: "Enable zoom (Live Preview)",
                desc: "Zoom in/out to the current list subtree. Conflicts with third-party plugin: obsidian-zoom."
              },
              move: {
                name: "Enable move subtree up/down",
                desc: "Move the current list subtree up/down among siblings (current file only). Conflicts with obsidian-outliner."
              },
              indent: {
                name: "Enable indent/outdent subtree",
                desc: "Indent/outdent the current list subtree (toggleable). Conflicts with obsidian-outliner."
              },
              dragDrop: {
                name: "Enable drag-and-drop subtree",
                desc: "Drag-and-drop list subtrees within the current file (no cross-file). Conflicts with obsidian-outliner."
              },
              verticalLines: {
                name: "Enable vertical indentation lines",
                desc: "Render indentation guides in Live Preview (best-effort across themes). Conflicts with obsidian-outliner."
              },
              bulletThreading: {
                name: "Enable bullet threading",
                desc: "Highlight the active list block path (current block + ancestors). Conflicts with obsidian-outliner."
              }
            }
          }
        },
        // Only used translations - Commands
        commands: {
          // Flow commands
          h1: "Heading 1",
          h2: "Heading 2",
          h3: "Heading 3",
          h4: "Heading 4",
          h5: "Heading 5",
          h6: "Heading 6",
          bold: "Bold",
          italic: "Italic",
          strikethrough: "Strikethrough",
          highlight: "Highlight",
          code: "Code",
          codeblock: "Code Block",
          quote: "Quote",
          link: "Link",
          image: "Image",
          table: "Table",
          divider: "Divider",
          embed: "Embed",
          tag: "Tag",
          callout: "Callout",
          list: "List",
          numberList: "Number List",
          task: "Task",
          toggleList: "Toggle List",
          space: "Space",
          newNote: "New Note",
          newFolder: "New Folder"
        },
        // Commands suggest
        commandsSuggest: {
          noResult: "No results found"
        },
        // Metadata types used in metadata.ts
        metadataTypes: {
          fileName: "File Name",
          path: "Path",
          folder: "Folder",
          created: "Created",
          lastModified: "Last Modified",
          extension: "Extension",
          size: "Size",
          tags: "Tags",
          inlinks: "Inlinks",
          outlinks: "Outlinks",
          color: "Color"
        },
        // What's New modal (shown after upgrade)
        whatsNew: {
          titleWithVersion: "Block Link Plus \u2014 What's new in v${1}",
          updatedFromTo: "Updated from v${1} to v${2}",
          viewChangelog: "View full changelog",
          close: "Close",
          v1_8_0: [
            "Inline Edit: migrated to a native leaf-based engine (ported from sync-embeds; more reliable in Live Preview).",
            "Removed legacy `!![[...]]` syntax; use `![[...]]`.",
            "Multi-line blocks: improved `^id-id` range creation (inline when safe; otherwise standalone after the block).",
            "Fix: when selection stays within a single list item, range markers stay scoped to that item (no accidental expansion to the whole list).",
            "Fix: multi-block mode targets blocks (paragraphs/list items); list item IDs are inserted at the end of the item when needed (#22/#27).",
            "`^id-id` range embeds render consistently (including when Inline Edit is disabled).",
            "Fix: reading-mode postprocessor no longer blanks notes (#29).",
            "New: show a What's New modal once after upgrade."
          ],
          fallback: [
            "See the full changelog for details."
          ]
        },
        // Notices
        notices: {
          fileOutlinerUnsupportedBlockMarkdown: "Block contains list/heading syntax. Rendered as plain text to preserve outliner structure."
        }
      },
      zh: {
        // Flow Editor buttons - 
        buttons: {
          openFlow: "\u6253\u5F00\u6D41\u7A0B",
          hideFlow: "\u9690\u85CF\u6D41\u7A0B",
          toggleFlow: "\u5207\u6362\u6D41\u7A0B",
          // 
          cutTable: "\u526A\u5207\u8868\u683C",
          deleteTable: "\u5220\u9664\u8868\u683C"
        },
        // 
        labels: {
          noFile: "\u672A\u627E\u5230",
          placeholder: "\u8F93\u5165 ${1} \u6253\u5F00\u6D41\u7A0B\u83DC\u5355",
          notePlaceholder: "\u70B9\u51FB\u521B\u5EFA\u65B0\u7B14\u8BB0"
        },
        // 
        commandPalette: {
          openFlow: "\u6253\u5F00\u6D41\u7A0B\u7F16\u8F91\u5668",
          closeFlow: "\u5173\u95ED\u6D41\u7A0B\u7F16\u8F91\u5668"
        },
        // 
        notice: {
          tableDeleted: "\u8868\u683C\u5DF2\u5220\u9664"
        },
        // 
        settings: {
          // 
          pluginTitle: "Block Link Plus",
          // 
          multiLineHandle: {
            name: "\u591A\u884C\u5757\u884C\u4E3A",
            desc: "\u5B9A\u4E49\u591A\u884C\u9009\u62E9\u5982\u4F55\u751F\u6210\u5757 ID\u3002'\u9ED8\u8BA4' \u5C06\u5B83\u4EEC\u89C6\u4E3A\u5355\u884C\u5904\u7406\u3002",
            options: {
              default: "\u9ED8\u8BA4",
              addHeading: "\u6DFB\u52A0\u65B0\u6807\u9898",
              addMultiBlock: "\u6DFB\u52A0\u591A\u5757",
              addMultilineBlock: "\u6DFB\u52A0\u591A\u884C\u5757"
            },
            descriptions: {
              default: "\u5C06\u591A\u884C\u9009\u62E9\u89C6\u4E3A\u5355\u4E2A\u5757\u3002\u5728\u9009\u62E9\u672B\u5C3E\u521B\u5EFA\u4E00\u4E2A\u5757 ID ^abc123\u3002",
              addHeading: "\u5728\u9009\u62E9\u4E0A\u65B9\u6DFB\u52A0\u4E00\u4E2A\u65B0\u6807\u9898\u3002\u4E3A\u7EC4\u7EC7\u521B\u5EFA\u4E00\u4E2A\u5E26\u5757 ID \u7684\u6807\u9898\u3002",
              addMultiBlock: "\u4E3A\u6BCF\u4E2A\u5757\uFF08\u6BB5\u843D\u3001\u5217\u8868\u9879\u7B49\uFF09\u521B\u5EFA\u5355\u72EC\u7684\u5757 ID\u3002\u6BCF\u4E2A\u5757\u83B7\u5F97\u81EA\u5DF1\u7684 ^abc123 \u6807\u8BC6\u7B26\u3002",
              addMultilineBlock: "\u521B\u5EFA\u4E00\u4E2A ^abc123-abc123 \u683C\u5F0F\u7684\u8303\u56F4\u5757\u3002\u7528 ^abc123 \u6807\u8BB0\u7B2C\u4E00\u884C\uFF0C\u5E76\u5728\u6700\u540E\u4E00\u884C\u540E\u6DFB\u52A0 ^abc123-abc123 \u4EE5\u7CBE\u786E\u5F15\u7528\u591A\u884C\u3002"
            }
          },
          // 
          blockLink: {
            title: "\u5757\u94FE\u63A5",
            desc: "\u94FE\u63A5\u683C\u5F0F\uFF1A[[\u6587\u4EF6#\u5757id]]",
            enableRightClick: {
              name: "\u5728\u53F3\u952E\u83DC\u5355\u4E2D\u542F\u7528\u5757\u94FE\u63A5",
              desc: ""
            },
            enableNotification: {
              name: "\u590D\u5236\u5757\u94FE\u63A5\u65F6\u663E\u793A\u901A\u77E5",
              desc: ""
            },
            aliasStyle: {
              name: "\u522B\u540D\u6837\u5F0F",
              desc: "\u9009\u62E9\u5982\u4F55\u4E3A\u5757\u94FE\u63A5\u751F\u6210\u522B\u540D\u3002\u5BF9\u4E8E\u6807\u9898\u5757\uFF0C\u9664\u975E\u9009\u62E9'\u65E0\u522B\u540D'\uFF0C\u5426\u5219\u522B\u540D\u59CB\u7EC8\u662F\u6807\u9898\u6587\u672C\u3002",
              options: {
                noAlias: "\u65E0\u522B\u540D",
                firstChars: "\u524D X \u4E2A\u5B57\u7B26",
                parentHeading: "\u7236\u6807\u9898",
                selectedText: "\u9009\u4E2D\u6587\u672C"
              },
              descriptions: {
                noAlias: "\u94FE\u63A5\u5C06\u663E\u793A\u4E3A [[\u6587\u4EF6#^abc123]] \u6CA1\u6709\u522B\u540D\u6587\u672C\u3002",
                firstChars: "\u94FE\u63A5\u5C06\u4F7F\u7528\u5757\u5185\u5BB9\u7684\u7B2C\u4E00\u4E2A X \u4E2A\u5B57\u7B26\u4F5C\u4E3A\u522B\u540D\uFF1A[[\u6587\u4EF6#^abc123|\u524D\u51E0\u4E2A\u8BCD...]]",
                parentHeading: "\u94FE\u63A5\u5C06\u4F7F\u7528\u6700\u8FD1\u7684\u7236\u6807\u9898\u4F5C\u4E3A\u522B\u540D\uFF1A[[\u6587\u4EF6#^abc123|\u7236\u6807\u9898]]",
                selectedText: "\u94FE\u63A5\u5C06\u4F7F\u7528\u9009\u4E2D\u7684\u6587\u672C\u4F5C\u4E3A\u522B\u540D\uFF1A[[\u6587\u4EF6#^abc123|\u60A8\u9009\u4E2D\u7684\u6587\u672C]]"
              }
            },
            aliasLength: {
              name: "\u522B\u540D\u957F\u5EA6",
              desc: "\u8BBE\u7F6E\u522B\u540D\u7684\u957F\u5EA6(1-100) \u4EC5\u5728\u522B\u540D\u6837\u5F0F\u4E3A'\u524D X \u4E2A\u5B57\u7B26'\u65F6\u4F7F\u7528\u3002"
            },
            headingIdNewline: {
              name: "\u5B9E\u9A8C\u6027\uFF1A\u6807\u9898\u5757 ID \u6837\u5F0F",
              desc: "\u4EC5\u9009\u62E9\u5355\u4E2A\u6807\u9898\u884C\u65F6\uFF0C\u5C06\u5757 ID \u653E\u5728\u65B0\u884C\u4E2D"
            }
          },
          // 
          embedLink: {
            title: "\u5D4C\u5165\u94FE\u63A5",
            desc: "\u94FE\u63A5\u683C\u5F0F\uFF1A![[\u6587\u4EF6#\u5757id]]",
            enableRightClick: {
              name: "\u5728\u53F3\u952E\u83DC\u5355\u4E2D\u542F\u7528\u5D4C\u5165\u94FE\u63A5",
              desc: ""
            },
            enableNotification: {
              name: "\u590D\u5236\u5D4C\u5165\u94FE\u63A5\u65F6\u663E\u793A\u901A\u77E5",
              desc: ""
            }
          },
          // Inline edit
          inlineEdit: {
            title: "\u5185\u8054\u7F16\u8F91",
            desc: "\u63A7\u5236 Live Preview \u4E0B\u54EA\u4E9B ![[...]] \u5D4C\u5165\u5141\u8BB8\u5C31\u5730\u7F16\u8F91\u3002",
            enable: {
              name: "\u542F\u7528\u5185\u8054\u7F16\u8F91",
              desc: "\u542F\u7528\u540E\uFF0C\u652F\u6301\u7684 ![[...]] \u5D4C\u5165\u5728 Live Preview \u4E2D\u53EF\u80FD\u53EF\u7F16\u8F91\u3002"
            },
            file: {
              name: "\u5141\u8BB8\u6587\u4EF6\u5D4C\u5165 (![[file]])",
              desc: "\u542F\u7528\u540E\uFF0C![[file]] \u5728 Live Preview \u4E2D\u53EF\u80FD\u53EF\u7F16\u8F91\u3002"
            },
            heading: {
              name: "\u5141\u8BB8\u6807\u9898\u5D4C\u5165 (![[file#Heading]])",
              desc: "\u542F\u7528\u540E\uFF0C![[file#Heading]] \u5728 Live Preview \u4E2D\u53EF\u80FD\u53EF\u7F16\u8F91\u3002"
            },
            block: {
              name: "\u5141\u8BB8\u5757\u5D4C\u5165 (![[file#^id]] / ![[file#^id-id]])",
              desc: "\u542F\u7528\u540E\uFF0C![[file#^id]] \u4E0E ![[file#^id-id]] \u5728 Live Preview \u4E2D\u53EF\u80FD\u53EF\u7F16\u8F91\u3002"
            }
          },
          // Obsidian URI 
          obsidianUri: {
            title: "Obsidian URI \u94FE\u63A5",
            desc: "\u94FE\u63A5\u683C\u5F0F: obsidian://open?vault=${vault}&file=${filePath}${encodedBlockId}",
            enableRightClick: {
              name: "\u5728\u53F3\u952E\u83DC\u5355\u4E2D\u542F\u7528 Obsidian URI \u94FE\u63A5",
              desc: ""
            },
            enableNotification: {
              name: "\u590D\u5236 URI \u94FE\u63A5\u65F6\u663E\u793A\u901A\u77E5",
              desc: ""
            }
          },
          //  ID 
          blockId: {
            title: "\u5757 ID",
            desc: "\u81EA\u5B9A\u4E49\u5757id",
            maxLength: {
              name: "\u6700\u5927\u5757 ID \u957F\u5EA6",
              desc: "\u8BBE\u7F6E\u5757 ID \u7684\u6700\u5927\u5B57\u7B26\u6570\u3002"
            },
            enablePrefix: {
              name: "\u81EA\u5B9A\u4E49 ID \u524D\u7F00",
              desc: ""
            },
            prefix: {
              name: "\u5757 ID \u524D\u7F00",
              desc: "\u5757 ID \u5C06\u662F\uFF1A\u524D\u7F00-\u968F\u673A\u5B57\u7B26\u4E32"
            }
          },
          // Outliner
          fileOutliner: {
            title: "Outliner",
            desc: "Outliner \u89C6\u56FE\uFF08\u7C7B Logseq\uFF09\u3002\u534F\u8BAE\u5C3E\u884C\u4F7F\u7528 Dataview inline fields + `^id`\uFF0C\u4FDD\u8BC1\u5373\u4F7F\u4E0D\u5B89\u88C5\u63D2\u4EF6\uFF0C`[[file#^id]]` \u4E5F\u80FD\u8DF3\u8F6C\u3002",
            groups: {
              scope: {
                title: "\u8303\u56F4"
              },
              routing: {
                title: "\u8DEF\u7531"
              },
              display: {
                title: "\u663E\u793A\u4E0E\u4EA4\u4E92"
              },
              interactions: {
                title: "\u4EA4\u4E92"
              },
              editing: {
                title: "\u7F16\u8F91"
              },
              integrations: {
                title: "\u96C6\u6210"
              },
              debug: {
                title: "\u8C03\u8BD5"
              },
              behavior: {
                title: "\u884C\u4E3A"
              }
            },
            enabledFolders: {
              name: "\u542F\u7528\u6587\u4EF6\u5939\uFF08vault \u76F8\u5BF9\u8DEF\u5F84\uFF09",
              desc: "\u6BCF\u9879\u4E00\u4E2A\u8DEF\u5F84\u3002\u4F4D\u4E8E\u8FD9\u4E9B\u6587\u4EF6\u5939\u4E0B\u7684\u6587\u4EF6\u5C06\u4F7F\u7528 Outliner \u89C6\u56FE\u6253\u5F00\u3002",
              addButton: "\u6DFB\u52A0\u6587\u4EF6\u5939",
              placeholder: "Daily"
            },
            enabledFiles: {
              name: "\u542F\u7528\u6587\u4EF6\uFF08vault \u76F8\u5BF9\u8DEF\u5F84\uFF09",
              desc: "\u6BCF\u9879\u4E00\u4E2A\u8DEF\u5F84\u3002\u7528\u4E8E\u53EA\u5BF9\u5C11\u91CF\u6307\u5B9A\u6587\u4EF6\u542F\u7528\u3002",
              addButton: "\u6DFB\u52A0\u6587\u4EF6",
              placeholder: "Daily/2026-01-09.md"
            },
            frontmatterOverride: {
              name: "Frontmatter \u8986\u76D6",
              desc: "\u6BCF\u6587\u4EF6\uFF1A`blp_outliner: true/false`\u3002"
            },
            enableRouting: {
              name: "\u542F\u7528 Outliner",
              desc: "\u542F\u7528\u540E\uFF0C\u8303\u56F4\u5185\u7684\u6587\u4EF6\u5C06\u6253\u5F00 Outliner \u89C6\u56FE\uFF0C\u800C\u4E0D\u662F\u539F\u751F Markdown \u7F16\u8F91\u5668\u3002"
            },
            hideSystemTailLines: {
              name: "\u9690\u85CF\u7CFB\u7EDF\u5C3E\u884C",
              desc: "\u5F53\u5B58\u5728 `[blp_sys:: 1]` \u65F6\uFF0C\u5728\u9605\u8BFB\u6A21\u5F0F\u9690\u85CF Outliner \u534F\u8BAE\u5C3E\u884C\u3002"
            },
            dragAndDrop: {
              name: "\u542F\u7528\u62D6\u62FD\u79FB\u52A8",
              desc: "\u62D6\u62FD\u5706\u70B9\u4EE5\u79FB\u52A8\u5757\u53CA\u5176\u5B50\u6811\u3002"
            },
            zoom: {
              name: "\u542F\u7528 Zoom",
              desc: "\u70B9\u51FB\u5706\u70B9\u4EE5 Zoom \u8FDB\u5165\u5757\u7684\u5B50\u6811\u89C6\u56FE\u3002"
            },
            emphasisLine: {
              name: "\u542F\u7528\u5F3A\u8C03\u7EBF\uFF08\u5DE6\u4FA7\uFF09",
              desc: "\u5F3A\u8C03\u5F53\u524D\u5757\u5DE6\u4FA7\u7684\u8FDE\u63A5\u7EBF\u3002\u5173\u95ED\u540E\u4FDD\u6301\u4E3A\u5F31\u5316\u989C\u8272\u3002"
            },
            editorContextMenu: {
              enabled: {
                name: "\u7F16\u8F91\u5668\u53F3\u952E\u83DC\u5355",
                desc: "\u5728 Outliner \u7F16\u8F91\u6A21\u5F0F\u4E2D\u4F7F\u7528 BLP \u7684\u53F3\u952E\u83DC\u5355\uFF08\u652F\u6301\u6309\u63D2\u4EF6 ID \u767D\u540D\u5355\u6CE8\u5165\uFF09\u3002"
              },
              allowedPlugins: {
                name: "\u5141\u8BB8\u6CE8\u5165\u7684\u63D2\u4EF6 ID",
                desc: "\u6BCF\u9879\u4E00\u4E2A\u63D2\u4EF6 ID\u3002\u53EA\u6709\u767D\u540D\u5355\u5185\u63D2\u4EF6\u53EF\u5411 Outliner \u7F16\u8F91\u83DC\u5355\u6DFB\u52A0\u9879\u3002\u6DFB\u52A0 `core` \u4EE5\u5305\u542B\u6838\u5FC3\u83DC\u5355\u9879\u3002",
                addButton: "\u6DFB\u52A0\u63D2\u4EF6",
                placeholder: "metadata-menu"
              }
            },
            editorCommands: {
              enabled: {
                name: "\u7F16\u8F91\u5668\u547D\u4EE4\u6865\u63A5\uFF08\u5FEB\u6377\u952E\uFF09",
                desc: "\u5728 Outliner \u7F16\u8F91\u5757\u65F6\u542F\u7528 core \u7F16\u8F91\u5668\u5FEB\u6377\u952E\uFF08Ctrl+B \u7B49\uFF09\u548C\u767D\u540D\u5355\u63D2\u4EF6\u7684\u7F16\u8F91\u5668\u547D\u4EE4\u3002\u6CE8\u610F\uFF1A\u4F9D\u8D56 CM6 \u6CE8\u5165\u7684\u63D2\u4EF6\u4E0D\u652F\u6301\u3002"
              },
              allowedPlugins: {
                name: "\u7F16\u8F91\u5668\u547D\u4EE4\u63D2\u4EF6\u767D\u540D\u5355",
                desc: "\u6BCF\u9879\u4E00\u4E2A\u63D2\u4EF6 ID\u3002\u53EA\u6709\u767D\u540D\u5355\u5185\u63D2\u4EF6\u53EF\u4EE5\u5728 Outliner \u4E2D\u6267\u884C\u7F16\u8F91\u5668\u547D\u4EE4\u3002\u6DFB\u52A0 `core` \u4EE5\u5305\u542B core \u7F16\u8F91\u5668\u547D\u4EE4\u3002",
                addButton: "\u6DFB\u52A0\u63D2\u4EF6",
                placeholder: "highlightr-plugin"
              },
              copyFromMenuAllowlist: {
                name: "\u540C\u6B65\u767D\u540D\u5355",
                desc: "\u5C06\u201C\u7F16\u8F91\u5668\u83DC\u5355\u767D\u540D\u5355\u201D\u590D\u5236\u5230\u201C\u7F16\u8F91\u5668\u547D\u4EE4\u767D\u540D\u5355\u201D\u3002\u63D0\u793A\uFF1A\u60F3\u8981 Ctrl+B \u7B49\u683C\u5F0F\u5316\u5FEB\u6377\u952E\uFF0C\u8BF7\u786E\u4FDD\u5305\u542B `core`\u3002",
                buttonText: "\u4ECE\u7F16\u8F91\u5668\u83DC\u5355\u767D\u540D\u5355\u590D\u5236"
              }
            },
            listEditor: {
              moveUp: "\u4E0A\u79FB",
              moveDown: "\u4E0B\u79FB",
              remove: "\u79FB\u9664"
            },
            childrenOnSplit: {
              name: "Enter \u62C6\u5206\uFF1A\u5B50\u5757\u5904\u7406",
              desc: "\u4F7F\u7528 Enter \u62C6\u5206\u5757\u65F6\uFF0C\u9009\u62E9\u5B50\u5757\u4FDD\u7559\u5728\u539F\u5757\u6216\u79FB\u52A8\u5230\u65B0\u5757\u3002",
              options: {
                keep: "\u5B50\u5757\u4FDD\u7559\u5728\u539F\u5757",
                move: "\u5B50\u5757\u79FB\u52A8\u5230\u65B0\u5757"
              }
            },
            pasteMultiline: {
              name: "\u7C98\u8D34\u591A\u884C\u6587\u672C",
              desc: "\u5728\u5757\u5185\u7C98\u8D34\u591A\u884C\u6587\u672C\u65F6\uFF0C\u9009\u62E9\u62C6\u5206\u4E3A\u591A\u4E2A\u5757\u8FD8\u662F\u4FDD\u7559\u4E3A\u5355\u5757\u591A\u884C\u6587\u672C\u3002",
              options: {
                split: "\u62C6\u5206\u4E3A\u591A\u4E2A\u5757\uFF08\u9ED8\u8BA4\uFF09",
                multiline: "\u4FDD\u7559\u4E3A\u5F53\u524D\u5757\u5185\u591A\u884C\u6587\u672C"
              }
            },
            backspaceWithChildren: {
              name: "\u884C\u9996 Backspace\uFF08\u6709\u5B50\u5757\uFF09",
              desc: "\u5F53\u5757\u6709\u5B50\u5757\u65F6\uFF0C\u9009\u62E9 Backspace \u4E0E\u4E0A\u4E00\u5757\u5408\u5E76\uFF08\u9ED8\u8BA4\uFF09\u6216\u4F18\u5148 Outdent\u3002",
              options: {
                merge: "\u4E0E\u4E0A\u4E00\u5757\u5408\u5E76\uFF08\u9ED8\u8BA4\uFF09",
                outdent: "\u4F18\u5148 Outdent"
              }
            },
            tasksHelp: {
              name: "\u4EFB\u52A1",
              desc: '\u4EFB\u52A1\u5757\u5728\u78C1\u76D8\u4E0A\u4F7F\u7528 Obsidian \u539F\u751F\u7684 `- [ ]` / `- [x]` \u8BED\u6CD5\u3002\u547D\u4EE4\uFF1A"${toggleTaskStatus}"\uFF08Mod+Enter\uFF09\u4E0E "${toggleTaskMarker}"\uFF08Mod+Shift+Enter\uFF09\u3002\u53EF\u5728 \u8BBE\u7F6E -> \u5FEB\u6377\u952E \u4E2D\u914D\u7F6E\u3002'
            },
            debug: {
              name: "\u8C03\u8BD5\u65E5\u5FD7",
              desc: "\u5C06 Outliner \u5185\u90E8\u9519\u8BEF\u8F93\u51FA\u5230 DevTools \u63A7\u5236\u53F0\u3002"
            },
            commands: {
              toggleTaskStatus: "Outliner\uFF1A\u5207\u6362\u4EFB\u52A1\u72B6\u6001",
              toggleTaskMarker: "Outliner\uFF1A\u5207\u6362\u4EFB\u52A1\u6807\u8BB0"
            },
            contextMenu: {
              copyBlockReference: "\u590D\u5236\u5757\u5F15\u7528",
              copyBlockEmbed: "\u590D\u5236\u5757\u5D4C\u5165",
              copyBlockUrl: "\u590D\u5236\u5757 URL",
              convertToTask: "\u8F6C\u4E3A\u4EFB\u52A1",
              convertToNormalBlock: "\u8F6C\u4E3A\u666E\u901A\u5757",
              copy: "\u590D\u5236",
              cut: "\u526A\u5207",
              paste: "\u7C98\u8D34",
              pasteAsText: "\u4EE5\u7EAF\u6587\u672C\u5F62\u5F0F\u7C98\u8D34",
              delete: "\u5220\u9664",
              collapse: "\u6298\u53E0",
              expand: "\u5C55\u5F00"
            }
          },
          //  List Blocks
          enhancedListBlocks: {
            title: "\u589E\u5F3A List Blocks",
            desc: "\u914D\u7F6E\u589E\u5F3A List Blocks \u7684\u542F\u7528\u8303\u56F4\uFF08blp-view\u3001\u7CFB\u7EDF\u884C\u9690\u85CF\u3001\u91CD\u590D ^id \u4FEE\u590D\u4EC5\u5728\u542F\u7528\u6587\u4EF6\u5185\u751F\u6548\uFF09\u3002\u6EE1\u8DB3\u4EFB\u4E00\u6761\u4EF6\u5373\u542F\u7528\uFF1A\u4F4D\u4E8E\u542F\u7528\u6587\u4EF6\u5939/\u542F\u7528\u6587\u4EF6\u5217\u8868\uFF0C\u6216\u6587\u4EF6 frontmatter \u542B `blp_enhanced_list: true`\u3002",
            groups: {
              scopeAndBehavior: {
                title: "\u542F\u7528\u8303\u56F4\u4E0E\u884C\u4E3A"
              },
              scope: {
                title: "\u542F\u7528\u8303\u56F4"
              },
              behavior: {
                title: "\u884C\u4E3A"
              },
              blockMode: {
                title: "\u5757\u6A21\u5F0F"
              },
              normalization: {
                title: "\u6807\u51C6\u5316"
              }
            },
            dataviewStatus: {
              available: "\u2705 Dataview \u63D2\u4EF6\u5DF2\u5B89\u88C5\u5E76\u542F\u7528 (v${version})",
              unavailable: "\u274C Dataview \u63D2\u4EF6\u672A\u5B89\u88C5\u6216\u672A\u542F\u7528\uFF0Cblp-view \u5C06\u65E0\u6CD5\u5DE5\u4F5C\u3002"
            },
            enabledFolders: {
              name: "\u542F\u7528\u6587\u4EF6\u5939",
              desc: "\u6BCF\u884C\u4E00\u4E2A\u6587\u4EF6\u5939\u8DEF\u5F84\uFF08\u76F8\u5BF9 vault \u6839\u76EE\u5F55\uFF09\u3002\u8BE5\u6587\u4EF6\u5939\u4E0B\u7684 Markdown \u6587\u4EF6\u542F\u7528\u3002"
            },
            enabledFiles: {
              name: "\u542F\u7528\u6587\u4EF6",
              desc: "\u6BCF\u884C\u4E00\u4E2A\u6587\u4EF6\u8DEF\u5F84\uFF08\u76F8\u5BF9 vault \u6839\u76EE\u5F55\uFF09\u3002\u8FD9\u4E9B Markdown \u6587\u4EF6\u542F\u7528\u3002"
            },
            hideSystemLine: {
              name: "\u9690\u85CF\u7CFB\u7EDF\u884C",
              desc: "\u5728 Live Preview \u4E0E Reading mode \u4E0B\u9690\u85CF\u7CFB\u7EDF\u884C\uFF08`[date:: ...] ^id`\uFF09\u3002\u5173\u95ED\u540E\u663E\u793A\u7CFB\u7EDF\u884C\uFF08\u7528\u4E8E\u8C03\u8BD5\uFF09\u3002"
            },
            hideNativeFoldIndicator: {
              name: "\u9690\u85CF Obsidian \u81EA\u5E26\u6298\u53E0\u6307\u793A\u5668",
              desc: "\u5728 Live Preview\uFF08\u4EC5\u542F\u7528\u6587\u4EF6\uFF09\u4E2D\u9690\u85CF\u5217\u8868\u9879\u76EE\u65C1\u8FB9\u7684\u6298\u53E0\u5C0F\u4E09\u89D2\uFF0C\u51CF\u5C11\u62D6\u62FD\u65F6\u8BEF\u89E6\u6298\u53E0/\u5C55\u5F00\u3002"
            },
            subtreeClipboard: {
              name: "\u542F\u7528\u5B50\u6811\u526A\u8D34\u677F\uFF08\u6309\u5757\u6811 copy/cut/paste\uFF09",
              desc: "\u5F53\u5757\u9009\u62E9\u6A21\u5F0F\u6FC0\u6D3B\u65F6\uFF0CCopy/Cut/Paste \u4EE5\u5217\u8868\u9879\u5B50\u6811\uFF08\u5757\u6811\uFF09\u4E3A\u5355\u4F4D\uFF0C\u800C\u4E0D\u662F\u7EAF\u6587\u672C\u3002"
            },
            doubleParenTrigger: {
              name: "\u542F\u7528 `((` \u89E6\u53D1\u5757\u5F15\u7528\u63D2\u5165",
              desc: "\u5F00\u542F\u540E\uFF0C\u8F93\u5165 `((` \u4F1A\u6253\u5F00\u5757\u5F15\u7528\u9009\u62E9\u5668\uFF0C\u5E76\u5C06 `((` \u66FF\u6362\u4E3A\u6807\u51C6 `[[file#^id]]` \u5F15\u7528\u3002\u4E0D\u4E60\u60EF Roam/Logseq \u98CE\u683C\u53EF\u4FDD\u6301\u5173\u95ED\u3002"
            },
            blockPeek: {
              name: "\u542F\u7528 Block Peek\uFF08\u4E0A\u4E0B\u6587\uFF09",
              desc: "\u4E3A `[[file#^id]]` \u5757\u63D0\u4F9B Block Peek \u5165\u53E3\uFF08\u624B\u67C4\u83DC\u5355 + blp-view peek \u6309\u94AE\uFF09\u3002"
            },
            handleAffordance: {
              name: "\u663E\u793A\u5217\u8868\u624B\u67C4",
              desc: "\u5728 Live Preview \u4E2D\u5C06\u65E0\u5E8F\u5217\u8868\u7B26\u53F7\u6E32\u67D3\u4E3A\u624B\u67C4\uFF08\u4EC5\u5BF9\u542F\u7528\u6587\u4EF6\u751F\u6548\uFF09\uFF0C\u4FBF\u4E8E\u53D1\u73B0\u62D6\u62FD/\u6298\u53E0\u7B49\u4EA4\u4E92\u3002"
            },
            handleActions: {
              name: "\u542F\u7528\u5217\u8868\u624B\u67C4\u52A8\u4F5C",
              desc: "\u5728 Live Preview \u4E2D\u542F\u7528\u65E0\u5E8F\u5217\u8868\u624B\u67C4\u7684\u70B9\u51FB\u6298\u53E0\u4E0E\u53F3\u952E\u624B\u67C4\u83DC\u5355\uFF08\u4EC5\u5BF9\u542F\u7528\u6587\u4EF6\u751F\u6548\uFF09\u3002",
              clickAction: {
                name: "\u624B\u67C4\u5DE6\u952E\u52A8\u4F5C",
                desc: "\u9009\u62E9\u5DE6\u952E\u70B9\u51FB\u5217\u8868\u624B\u67C4\u65F6\u6267\u884C\u7684\u52A8\u4F5C\u3002\u53F3\u952E\u59CB\u7EC8\u6253\u5F00\u624B\u67C4\u83DC\u5355\u3002",
                options: {
                  toggleFolding: "\u5207\u6362\u6298\u53E0",
                  selectBlock: "\u9009\u62E9\u5757",
                  menu: "\u6253\u5F00\u624B\u67C4\u83DC\u5355",
                  none: "\u65E0"
                }
              },
              menu: {
                toggleFolding: "\u5207\u6362\u6298\u53E0",
                copyBlockLink: "\u590D\u5236\u5757\u94FE\u63A5",
                copyBlockEmbed: "\u590D\u5236\u5757\u5D4C\u5165",
                zoomIn: "\u653E\u5927\uFF08Zoom in\uFF09",
                zoomOut: "\u7F29\u5C0F\uFF08Zoom out\uFF09"
              }
            },
            indentCodeBlocks: {
              name: "\u7F29\u8FDB\u5D4C\u5957\u4EE3\u7801\u5757",
              desc: "\u5728 Live Preview \u4E2D\u5C06\u5217\u8868\u9879\u5185\u7684\u56F4\u680F\u4EE3\u7801\u5757\u6309\u5C42\u7EA7\u7F29\u8FDB\u663E\u793A\uFF08\u4EC5\u5BF9\u542F\u7528\u6587\u4EF6\u751F\u6548\uFF09\uFF0C\u4E0D\u4FEE\u6539\u6587\u4EF6\u5185\u5BB9\u3002"
            },
            deleteSubtreeOnDelete: {
              name: "\u5220\u9664\u5217\u8868\u9879\u65F6\u5220\u9664\u5B50\u9879",
              desc: "\u5F00\u542F\u540E\uFF1A\u5220\u9664\u7236\u5217\u8868\u9879\u4F1A\u4E00\u5E76\u5220\u9664\u5176\u5B50\u5217\u8868\uFF08Logseq/Roam \u98CE\u683C\uFF09\u3002\u5173\u95ED\u540E\uFF1A\u5B50\u9879\u4FDD\u7559\uFF0C\u4EC5\u5220\u9664\u7CFB\u7EDF\u884C\u3002"
            },
            normalizeOnSave: {
              name: "\u4FDD\u5B58\u65F6\u6807\u51C6\u5316\u5217\u8868\u683C\u5F0F",
              desc: "\u4EC5\u5728\u4FDD\u5B58\u65F6\u751F\u6548\uFF08\u4EC5\u5BF9\u542F\u7528\u6587\u4EF6\uFF09\u3002\u53EA\u5BF9\u4E0A\u6B21\u4FDD\u5B58\u540E\u4F60\u7F16\u8F91\u8FC7\u7684\u5217\u8868\u9879\u5E94\u7528\u89C4\u5219\uFF1B\u8F93\u5165\u65F6\u4E0D\u6539\u52A8\u3002",
              rules: {
                tabsToSpaces: {
                  name: "\u5C06\u884C\u9996 Tab \u8F6C\u4E3A\u7A7A\u683C",
                  desc: "\u5C06\u884C\u9996\u7F29\u8FDB\u7684 Tab \u8F6C\u4E3A\u7A7A\u683C\uFF08tab \u5BBD\u5EA6\u53EF\u914D\u7F6E\uFF09\u3002\u4E3A\u907F\u514D\u6539\u53D8\u5217\u8868\u5C42\u7EA7\uFF0C\u5F53\u9700\u8981\u65F6\u4F1A\u56DE\u9000\u5230 Markdown \u7684 tab \u7F29\u8FDB\u8BED\u4E49\u3002\u4F8B\uFF08tab=2\uFF09\uFF1A`\\t- a` -> `  - a`\u3002",
                  tabSize: {
                    name: "Tab \u5BBD\u5EA6\uFF08\u7A7A\u683C\uFF09",
                    desc: "\u6807\u51C6\u5316\u65F6\uFF0C\u628A\u884C\u9996 Tab \u5C55\u5F00\u4E3A\u591A\u5C11\u4E2A\u7A7A\u683C\u3002\u9ED8\u8BA4\uFF1A2\u3002"
                  }
                },
                cleanupInvalidSystemLines: {
                  name: "\u6E05\u7406\u65E0\u6548/\u591A\u4F59\u7CFB\u7EDF\u884C",
                  desc: "\u5220\u9664\u5DF2\u7F16\u8F91\u5217\u8868\u9879\u4E2D\u7684\u591A\u4F59\u7CFB\u7EDF\u884C\uFF08\u4FDD\u7559\u7B2C\u4E00\u6761\uFF09\uFF0C\u5E76\u5220\u9664\u5217\u8868\u9879\u6B63\u4E0A\u65B9\u7684\u5B64\u513F\u7CFB\u7EDF\u884C\u3002\u4F8B\uFF1A`  [date:: ...] ^a` + `  [date:: ...] ^b` -> \u4EC5\u4FDD\u7559\u4E00\u6761\u3002"
                },
                mergeSplitSystemLine: {
                  name: "\u5408\u5E76\u62C6\u5206\u7684\u7CFB\u7EDF\u884C",
                  desc: "\u628A\u4E24\u884C\u7CFB\u7EDF\u884C\u5408\u5E76\u4E3A\u4E00\u884C\u3002\u4F8B\uFF1A`  [date:: 2026-01-26T16:01:21]` + `  ^7fp1` -> `  [date:: 2026-01-26T16:01:21] ^7fp1`\u3002"
                },
                systemLineIndent: {
                  name: "\u4FEE\u6B63\u7CFB\u7EDF\u884C\u7F29\u8FDB",
                  desc: "\u628A\u7CFB\u7EDF\u884C\u7F29\u8FDB\u5F3A\u5236\u4FEE\u6B63\u4E3A continuation indent\uFF08\u4E0E `- ` / \u590D\u9009\u6846\u540E\u7684\u5185\u5BB9\u5217\u5BF9\u9F50\uFF09\u3002\u4F8B\uFF1A`- a` + `[date:: ...] ^id` -> `- a` + `  [date:: ...] ^id`\u3002"
                },
                ensureSystemLineForTouchedItems: {
                  name: "\u4E3A\u5DF2\u7F16\u8F91\u7684\u5217\u8868\u9879\u8865\u9F50\u7CFB\u7EDF\u884C",
                  desc: "\u5982\u679C\u5DF2\u7F16\u8F91\u7684\u5217\u8868\u9879\u7F3A\u5C11\u7CFB\u7EDF\u884C\uFF0C\u4FDD\u5B58\u65F6\u81EA\u52A8\u63D2\u5165\uFF08\u5FC5\u8981\u65F6\u79FB\u52A8\u5230\u5B50\u5217\u8868\u4E4B\u524D\uFF09\u3002"
                }
              }
            },
            blpView: {
              title: "blp-view\uFF08Query/View\uFF09",
              desc: "blp-view \u6267\u884C\u62A4\u680F\u8BBE\u7F6E\uFF08\u9700\u8981 Dataview\uFF09\u3002",
              allowMaterialize: {
                name: "\u5141\u8BB8 materialize \u5199\u56DE",
                desc: "\u5173\u95ED\u540E\uFF0C\u5305\u542B `render.mode: materialize` \u7684 blp-view \u5C06\u62A5\u9519\u5E76\u4E14\u4E0D\u4F1A\u4FEE\u6539\u6587\u4EF6\u3002"
              },
              maxSourceFiles: {
                name: "\u6700\u5927\u626B\u63CF\u6587\u4EF6\u6570",
                desc: "0 \u8868\u793A\u4E0D\u9650\u5236\uFF1B\u5982\u679C\u4E00\u6B21 view \u9700\u8981\u626B\u63CF\u8D85\u8FC7\u8BE5\u6570\u91CF\u7684\u6587\u4EF6\uFF0C\u5C06\u505C\u6B62\u6267\u884C\u5E76\u63D0\u793A\u62A5\u9519\u3002"
              },
              maxResults: {
                name: "\u6700\u5927\u8F93\u51FA\u7ED3\u679C\u6570",
                desc: "0 \u8868\u793A\u4E0D\u9650\u5236\uFF1B\u5982\u679C\u5339\u914D\u7ED3\u679C\u8D85\u8FC7\u8BE5\u6570\u91CF\uFF0C\u5C06\u622A\u65AD\u8F93\u51FA\u5E76\u63D0\u793A\u201C\u5DF2\u622A\u65AD\u201D\u3002"
              },
              showDiagnostics: {
                name: "\u663E\u793A blp-view \u8BCA\u65AD\u4FE1\u606F",
                desc: "\u5728\u8F93\u51FA\u4E0B\u65B9\u663E\u793A\u626B\u63CF\u6570\u91CF\u3001\u5339\u914D\u6570\u91CF\u4E0E\u8017\u65F6\u7B49\u4FE1\u606F\u3002"
              }
            },
            ops: {
              title: "\u589E\u5F3A List Blocks \u64CD\u4F5C",
              desc: "\u4E3A list item \u5B50\u6811\u63D0\u4F9B\u7C7B\u4F3C outliner \u7684\u64CD\u4F5C\u4E0E UI \u589E\u5F3A\uFF08\u4EC5 Live Preview\uFF0C\u4EC5\u542F\u7528\u6587\u4EF6\u751F\u6548\uFF09\u3002",
              zoom: {
                name: "\u542F\u7528 Zoom\uFF08Live Preview\uFF09",
                desc: "Zoom in/out \u5230\u5F53\u524D list \u5B50\u6811\u3002\u4E0E\u7B2C\u4E09\u65B9\u63D2\u4EF6 `obsidian-zoom` \u51B2\u7A81\uFF0C\u4E0D\u53EF\u540C\u65F6\u542F\u7528\u3002"
              },
              move: {
                name: "\u542F\u7528\u5B50\u6811\u4E0A\u79FB/\u4E0B\u79FB",
                desc: "\u5728\u5F53\u524D\u6587\u4EF6\u5185\uFF0C\u5C06\u5F53\u524D list \u5B50\u6811\u5728\u5144\u5F1F\u8282\u70B9\u4E4B\u95F4\u4E0A\u79FB/\u4E0B\u79FB\u3002\u4E0E `obsidian-outliner` \u51B2\u7A81\u3002"
              },
              indent: {
                name: "\u542F\u7528\u5B50\u6811\u7F29\u8FDB/\u53CD\u7F29\u8FDB",
                desc: "\u7F29\u8FDB/\u53CD\u7F29\u8FDB\u5F53\u524D list \u5B50\u6811\uFF08\u53EF\u5F00\u5173\uFF09\u3002\u4E0E `obsidian-outliner` \u51B2\u7A81\u3002"
              },
              dragDrop: {
                name: "\u542F\u7528\u62D6\u62FD\uFF08Drag & Drop\uFF09",
                desc: "\u5728\u5F53\u524D\u6587\u4EF6\u5185\u62D6\u62FD list \u5B50\u6811\u8FDB\u884C\u6392\u5E8F/\u6539\u53D8\u5C42\u7EA7\uFF08\u4E0D\u652F\u6301\u8DE8\u6587\u4EF6\uFF09\u3002\u4E0E `obsidian-outliner` \u51B2\u7A81\u3002"
              },
              verticalLines: {
                name: "\u542F\u7528\u5782\u76F4\u7F29\u8FDB\u7EBF",
                desc: "\u5728 Live Preview \u4E0B\u6E32\u67D3\u7F29\u8FDB\u5BFC\u5F15\u7EBF\uFF08\u53D7\u4E3B\u9898\u5F71\u54CD\uFF0Cbest-effort\uFF09\u3002\u4E0E `obsidian-outliner` \u51B2\u7A81\u3002"
              },
              bulletThreading: {
                name: "\u542F\u7528 Bullet Threading",
                desc: "\u9AD8\u4EAE\u5F53\u524D list block \u53CA\u5176\u7956\u5148\u8DEF\u5F84\uFF08active path\uFF09\u3002\u4E0E `obsidian-outliner` \u51B2\u7A81\u3002"
              }
            }
          }
        },
        // 
        commands: {
          // Flow 
          h1: "\u6807\u9898 1",
          h2: "\u6807\u9898 2",
          h3: "\u6807\u9898 3",
          h4: "\u6807\u9898 4",
          h5: "\u6807\u9898 5",
          h6: "\u6807\u9898 6",
          bold: "\u7C97\u4F53",
          italic: "\u659C\u4F53",
          strikethrough: "\u5220\u9664\u7EBF",
          highlight: "\u9AD8\u4EAE",
          code: "\u4EE3\u7801",
          codeblock: "\u4EE3\u7801\u5757",
          quote: "\u5F15\u7528",
          link: "\u94FE\u63A5",
          image: "\u56FE\u7247",
          table: "\u8868\u683C",
          divider: "\u5206\u9694\u7EBF",
          embed: "\u5D4C\u5165",
          tag: "\u6807\u7B7E",
          callout: "\u6807\u6CE8",
          list: "\u5217\u8868",
          numberList: "\u6570\u5B57\u5217\u8868",
          task: "\u4EFB\u52A1",
          toggleList: "\u6298\u53E0\u5217\u8868",
          space: "\u7A7A\u683C",
          newNote: "\u65B0\u5EFA\u7B14\u8BB0",
          newFolder: "\u65B0\u5EFA\u6587\u4EF6\u5939"
        },
        // 
        commandsSuggest: {
          noResult: "\u672A\u627E\u5230\u7ED3\u679C"
        },
        // 
        metadataTypes: {
          fileName: "\u6587\u4EF6\u540D",
          path: "\u8DEF\u5F84",
          folder: "\u6587\u4EF6\u5939",
          created: "\u521B\u5EFA\u65F6\u95F4",
          lastModified: "\u6700\u540E\u4FEE\u6539",
          extension: "\u6269\u5C55\u540D",
          size: "\u5927\u5C0F",
          tags: "\u6807\u7B7E",
          inlinks: "\u53CD\u5411\u94FE\u63A5",
          outlinks: "\u6B63\u5411\u94FE\u63A5",
          color: "\u989C\u8272"
        },
        // 
        whatsNew: {
          titleWithVersion: "Block Link Plus \u2014 v${1} \u66F4\u65B0\u5185\u5BB9",
          updatedFromTo: "\u5DF2\u4ECE v${1} \u66F4\u65B0\u5230 v${2}",
          viewChangelog: "\u67E5\u770B\u5B8C\u6574\u66F4\u65B0\u65E5\u5FD7",
          close: "\u5173\u95ED",
          v1_8_0: [
            "\u5185\u8054\u7F16\u8F91\uFF1A\u8FC1\u79FB\u5230\u539F\u751F leaf \u5F15\u64CE\uFF08\u79FB\u690D\u81EA sync-embeds\uFF0CLive Preview \u66F4\u7A33\u5B9A\uFF09\u3002",
            "\u79FB\u9664\u65E7\u7248 `!![[...]]` \u8BED\u6CD5\uFF0C\u8BF7\u6539\u7528 `![[...]]`\u3002",
            "\u591A\u884C\u5757\uFF1A\u6539\u8FDB `^id-id` \u8303\u56F4\u521B\u5EFA\uFF08\u5B89\u5168\u65F6\u884C\u5C3E\u63D2\u5165\uFF1B\u5426\u5219\u5728\u5757\u7ED3\u675F\u540E\u72EC\u5360\u884C\u63D2\u5165\uFF09\u3002",
            "\u4FEE\u590D\uFF1A\u9009\u533A\u5728\u5355\u4E2A\u5217\u8868\u9879\u5185\u65F6\uFF0C\u8303\u56F4 marker \u4E0D\u518D\u6269\u5230\u6574\u4E2A list\u3002",
            "\u4FEE\u590D\uFF1A\u591A\u5757\u6A21\u5F0F\u6309\u201C\u5757\u201D\uFF08\u6BB5\u843D/\u5217\u8868\u9879\uFF09\u5DE5\u4F5C\uFF1B\u5217\u8868\u9879\u6709\u7EED\u884C\u65F6\uFF0CID \u63D2\u5165\u5230\u8BE5\u9879\u6700\u540E\u4E00\u884C\uFF08#22/#27\uFF09\u3002",
            "`^id-id` \u8303\u56F4\u5D4C\u5165\u6E32\u67D3\u4E00\u81F4\uFF08\u5373\u4F7F\u5173\u95ED\u5185\u8054\u7F16\u8F91\uFF09\u3002",
            "\u4FEE\u590D\uFF1A\u9605\u8BFB\u6A21\u5F0F\u540E\u5904\u7406\u4E0D\u518D\u5BFC\u81F4\u5185\u5BB9\u88AB\u6E05\u7A7A\uFF08#29\uFF09\u3002",
            "\u65B0\u589E\uFF1A\u5347\u7EA7\u540E\u5F39\u51FA\u4E00\u6B21\u66F4\u65B0\u8BF4\u660E\uFF08What's New\uFF09\u3002"
          ],
          fallback: [
            "\u8BF7\u67E5\u770B\u5B8C\u6574\u66F4\u65B0\u65E5\u5FD7\u4E86\u89E3\u8BE6\u60C5\u3002"
          ]
        },
        // Notices
        notices: {
          fileOutlinerUnsupportedBlockMarkdown: "\u6B64\u5757\u5305\u542B\u5217\u8868/\u6807\u9898\u8BED\u6CD5\u3002\u4E3A\u4FDD\u6301 Outliner \u7ED3\u6784\uFF0C\u5C06\u5176\u6309\u7EAF\u6587\u672C\u6E32\u67D3\u3002"
        }
      },
      "zh-TW": {
        // Flow Editor buttons - 
        buttons: {
          openFlow: "\u958B\u555F\u6D41\u7A0B",
          hideFlow: "\u96B1\u85CF\u6D41\u7A0B",
          toggleFlow: "\u5207\u63DB\u6D41\u7A0B",
          // 
          cutTable: "\u526A\u4E0B\u8868\u683C",
          deleteTable: "\u522A\u9664\u8868\u683C"
        },
        // 
        labels: {
          noFile: "\u672A\u627E\u5230",
          placeholder: "\u8F38\u5165 ${1} \u958B\u555F\u6D41\u7A0B\u9078\u55AE",
          notePlaceholder: "\u9EDE\u64CA\u5EFA\u7ACB\u65B0\u7B46\u8A18"
        },
        // 
        commandPalette: {
          openFlow: "\u958B\u555F\u6D41\u7A0B\u7DE8\u8F2F\u5668",
          closeFlow: "\u95DC\u9589\u6D41\u7A0B\u7DE8\u8F2F\u5668"
        },
        // 
        notice: {
          tableDeleted: "\u8868\u683C\u5DF2\u522A\u9664"
        },
        // 
        settings: {
          // 
          pluginTitle: "Block Link Plus",
          // 
          multiLineHandle: {
            name: "\u591A\u884C\u584A\u884C\u70BA",
            desc: "\u5B9A\u7FA9\u591A\u884C\u9078\u64C7\u5982\u4F55\u7522\u751F\u5340\u584A ID\u3002'\u9810\u8A2D' \u5C07\u5B83\u5011\u8996\u70BA\u55AE\u884C\u8655\u7406\u3002",
            options: {
              default: "\u9810\u8A2D",
              addHeading: "\u65B0\u589E\u65B0\u6A19\u984C",
              addMultiBlock: "\u65B0\u589E\u591A\u5340\u584A",
              addMultilineBlock: "\u65B0\u589E\u591A\u884C\u584A"
            },
            descriptions: {
              default: "\u5C07\u591A\u884C\u9078\u64C7\u8996\u70BA\u55AE\u4E00\u5340\u584A\u3002\u5728\u9078\u64C7\u7D50\u5C3E\u8655\u5275\u5EFA\u4E00\u500B\u5340\u584A ID ^abc123\u3002",
              addHeading: "\u5728\u9078\u64C7\u4E0A\u65B9\u65B0\u589E\u4E00\u500B\u65B0\u6A19\u984C\u3002\u70BA\u7D44\u7E54\u5275\u5EFA\u4E00\u500B\u5E36\u5340\u584A ID \u7684\u6A19\u984C\u3002",
              addMultiBlock: "\u70BA\u6BCF\u500B\u5340\u584A\uFF08\u6BB5\u843D\u3001\u6E05\u55AE\u9805\u7B49\uFF09\u5275\u5EFA\u55AE\u7368\u7684\u5340\u584A ID\u3002\u6BCF\u500B\u5340\u584A\u7372\u5F97\u81EA\u5DF1\u7684 ^abc123 \u8B58\u5225\u7B26\u3002",
              addMultilineBlock: "\u5275\u5EFA\u4E00\u500B ^abc123-abc123 \u683C\u5F0F\u7684\u7BC4\u570D\u5340\u584A\u3002\u7528 ^abc123 \u6A19\u8A18\u7B2C\u4E00\u884C\uFF0C\u4E26\u5728\u6700\u540E\u4E00\u884C\u5F8C\u6DFB\u52A0 ^abc123-abc123 \u4EE5\u7CBE\u78BA\u5F15\u7528\u591A\u884C\u3002"
            }
          },
          // 
          blockLink: {
            title: "\u584A\u9023\u7D50",
            desc: "\u9023\u7D50\u683C\u5F0F\uFF1A[[\u6A94\u6848#\u5340\u584A_id]]",
            enableRightClick: {
              name: "\u5728\u53F3\u9375\u9078\u55AE\u4E2D\u555F\u7528\u584A\u9023\u7D50",
              desc: ""
            },
            enableNotification: {
              name: "\u8907\u88FD\u584A\u9023\u7D50\u6642\u986F\u793A\u901A\u77E5",
              desc: ""
            },
            aliasStyle: {
              name: "\u5225\u540D\u6A23\u5F0F",
              desc: "\u9078\u64C7\u5982\u4F55\u70BA\u584A\u9023\u7D50\u7522\u751F\u5225\u540D. \u5C0D\u65BC\u6A19\u984C\u584A, \u9664\u975E\u9078\u64C7'\u7121\u5225\u540D', \u5426\u5247\u5225\u540D\u59CB\u7D42\u662F\u6A19\u984C\u6587\u5B57.",
              options: {
                noAlias: "\u7121\u5225\u540D",
                firstChars: "\u524D X \u500B\u5B57\u5143",
                parentHeading: "\u7236\u6A19\u984C",
                selectedText: "\u9078\u4E2D\u6587\u5B57"
              },
              descriptions: {
                noAlias: "\u9023\u7D50\u5C07\u986F\u793A\u70BA [[\u6A94\u6848#^abc123]] \u6C92\u6709\u5225\u540D\u6587\u5B57\u3002",
                firstChars: "\u9023\u7D50\u5C07\u4F7F\u7528\u584A\u5167\u5BB9\u7684\u7B2C\u4E00\u500B X \u500B\u5B57\u5143\u4F5C\u70BA\u5225\u540D\uFF1A[[\u6A94\u6848#^abc123|\u524D\u5E7E\u500B\u8A5E...]]",
                parentHeading: "\u9023\u7D50\u5C07\u4F7F\u7528\u6700\u8FD1\u7684\u7236\u6A19\u984C\u4F5C\u70BA\u5225\u540D\uFF1A[[\u6A94\u6848#^abc123|\u7236\u6A19\u984C]]",
                selectedText: "\u9023\u7D50\u5C07\u4F7F\u7528\u9078\u4E2D\u7684\u6587\u5B57\u4F5C\u70BA\u5225\u540D\uFF1A[[\u6A94\u6848#^abc123|\u60A8\u9078\u4E2D\u7684\u6587\u5B57]]"
              }
            },
            aliasLength: {
              name: "\u5225\u540D\u9577\u5EA6",
              desc: "\u8A2D\u5B9A\u5225\u540D\u7684\u9577\u5EA6(1-100). \u50C5\u5728\u5225\u540D\u6A23\u5F0F\u70BA'\u524D X \u500B\u5B57\u5143'\u6642\u4F7F\u7528."
            },
            headingIdNewline: {
              name: "\u5BE6\u9A57\u6027\uFF1A\u6A19\u984C\u5340\u584A ID \u6A23\u5F0F",
              desc: "\u50C5\u9078\u64C7\u55AE\u500B\u6A19\u984C\u884C\u6642\uFF0C\u5C07\u5340\u584A ID \u653E\u5728\u65B0\u884C\u4E2D"
            }
          },
          // 
          embedLink: {
            title: "\u5D4C\u5165\u9023\u7D50",
            desc: "\u9023\u7D50\u683C\u5F0F\uFF1A![[\u6A94\u6848#\u5340\u584A_id]]",
            enableRightClick: {
              name: "\u5728\u53F3\u9375\u9078\u55AE\u4E2D\u555F\u7528\u5D4C\u5165\u9023\u7D50",
              desc: ""
            },
            enableNotification: {
              name: "\u8907\u88FD\u5D4C\u5165\u9023\u7D50\u6642\u986F\u793A\u901A\u77E5",
              desc: ""
            }
          },
          // Inline edit
          inlineEdit: {
            title: "\u5167\u806F\u7DE8\u8F2F",
            desc: "\u63A7\u5236 Live Preview \u4E0B\u54EA\u4E9B ![[...]] \u5D4C\u5165\u5141\u8A31\u5C31\u5730\u7DE8\u8F2F\u3002",
            enable: {
              name: "\u555F\u7528\u5167\u806F\u7DE8\u8F2F",
              desc: "\u555F\u7528\u5F8C\uFF0C\u652F\u63F4\u7684 ![[...]] \u5D4C\u5165\u5728 Live Preview \u4E2D\u53EF\u80FD\u53EF\u7DE8\u8F2F\u3002"
            },
            file: {
              name: "\u5141\u8A31\u6A94\u6848\u5D4C\u5165 (![[file]])",
              desc: "\u555F\u7528\u5F8C\uFF0C![[file]] \u5728 Live Preview \u4E2D\u53EF\u80FD\u53EF\u7DE8\u8F2F\u3002"
            },
            heading: {
              name: "\u5141\u8A31\u6A19\u984C\u5D4C\u5165 (![[file#Heading]])",
              desc: "\u555F\u7528\u5F8C\uFF0C![[file#Heading]] \u5728 Live Preview \u4E2D\u53EF\u80FD\u53EF\u7DE8\u8F2F\u3002"
            },
            block: {
              name: "\u5141\u8A31\u5340\u584A\u5D4C\u5165 (![[file#^id]] / ![[file#^id-id]])",
              desc: "\u555F\u7528\u5F8C\uFF0C![[file#^id]] \u8207 ![[file#^id-id]] \u5728 Live Preview \u4E2D\u53EF\u80FD\u53EF\u7DE8\u8F2F\u3002"
            }
          },
          // Obsidian URI 
          obsidianUri: {
            title: "Obsidian URI \u9023\u7D50",
            desc: "\u9023\u7D50\u683C\u5F0F: obsidian://open?vault=${vault}&file=${filePath}${encodedBlockId}",
            enableRightClick: {
              name: "\u5728\u53F3\u9375\u9078\u55AE\u4E2D\u555F\u7528 Obsidian URI \u9023\u7D50",
              desc: ""
            },
            enableNotification: {
              name: "\u8907\u88FD URI \u9023\u7D50\u6642\u986F\u793A\u901A\u77E5",
              desc: ""
            }
          },
          //  ID 
          blockId: {
            title: "\u5340\u584A ID",
            desc: "\u81EA\u8A02\u5340\u584A_id",
            maxLength: {
              name: "\u6700\u5927\u5340\u584A ID \u9577\u5EA6",
              desc: "\u8A2D\u5B9A\u5340\u584A ID \u7684\u6700\u5927\u5B57\u5143\u6578\u3002"
            },
            enablePrefix: {
              name: "\u81EA\u8A02 ID \u524D\u7DB4",
              desc: ""
            },
            prefix: {
              name: "\u5340\u584A ID \u524D\u7DB4",
              desc: "\u5340\u584A ID \u5C07\u662F\uFF1A\u524D\u7DB4-\u96A8\u6A5F\u5B57\u4E32"
            }
          },
          // Outliner
          fileOutliner: {
            title: "Outliner",
            desc: "Outliner \u6AA2\u8996\uFF08\u985E Logseq\uFF09\u3002\u5354\u8B70\u5C3E\u884C\u4F7F\u7528 Dataview inline fields + `^id`\uFF0C\u78BA\u4FDD\u5373\u4F7F\u4E0D\u5B89\u88DD\u63D2\u4EF6\uFF0C`[[file#^id]]` \u4E5F\u80FD\u8DF3\u8F49\u3002",
            groups: {
              scope: {
                title: "\u7BC4\u570D"
              },
              routing: {
                title: "\u8DEF\u7531"
              },
              display: {
                title: "\u986F\u793A\u8207\u4E92\u52D5"
              },
              interactions: {
                title: "\u4E92\u52D5"
              },
              editing: {
                title: "\u7DE8\u8F2F"
              },
              integrations: {
                title: "\u6574\u5408"
              },
              debug: {
                title: "\u9664\u932F"
              },
              behavior: {
                title: "\u884C\u70BA"
              }
            },
            enabledFolders: {
              name: "\u555F\u7528\u8CC7\u6599\u593E\uFF08vault \u76F8\u5C0D\u8DEF\u5F91\uFF09",
              desc: "\u6BCF\u9805\u4E00\u500B\u8DEF\u5F91\u3002\u4F4D\u65BC\u9019\u4E9B\u8CC7\u6599\u593E\u4E0B\u7684\u6A94\u6848\u5C07\u4EE5 Outliner \u6AA2\u8996\u958B\u555F\u3002",
              addButton: "\u65B0\u589E\u8CC7\u6599\u593E",
              placeholder: "Daily"
            },
            enabledFiles: {
              name: "\u555F\u7528\u6A94\u6848\uFF08vault \u76F8\u5C0D\u8DEF\u5F91\uFF09",
              desc: "\u6BCF\u9805\u4E00\u500B\u8DEF\u5F91\u3002\u7528\u65BC\u53EA\u5C0D\u5C11\u91CF\u6307\u5B9A\u6A94\u6848\u555F\u7528\u3002",
              addButton: "\u65B0\u589E\u6A94\u6848",
              placeholder: "Daily/2026-01-09.md"
            },
            frontmatterOverride: {
              name: "Frontmatter \u8986\u84CB",
              desc: "\u6BCF\u6A94\u6848\uFF1A`blp_outliner: true/false`\u3002"
            },
            enableRouting: {
              name: "\u555F\u7528 Outliner",
              desc: "\u555F\u7528\u5F8C\uFF0C\u7BC4\u570D\u5167\u7684\u6A94\u6848\u6703\u958B\u555F Outliner \u6AA2\u8996\uFF0C\u800C\u4E0D\u662F\u539F\u751F Markdown \u7DE8\u8F2F\u5668\u3002"
            },
            hideSystemTailLines: {
              name: "\u96B1\u85CF\u7CFB\u7D71\u5C3E\u884C",
              desc: "\u7576\u5B58\u5728 `[blp_sys:: 1]` \u6642\uFF0C\u5728\u95B1\u8B80\u6A21\u5F0F\u96B1\u85CF Outliner \u5354\u8B70\u5C3E\u884C\u3002"
            },
            dragAndDrop: {
              name: "\u555F\u7528\u62D6\u66F3\u79FB\u52D5",
              desc: "\u62D6\u66F3\u5713\u9EDE\u4EE5\u79FB\u52D5\u5340\u584A\u53CA\u5176\u5B50\u6A39\u3002"
            },
            zoom: {
              name: "\u555F\u7528 Zoom",
              desc: "\u9EDE\u64CA\u5713\u9EDE\u4EE5 Zoom \u9032\u5165\u5340\u584A\u7684\u5B50\u6A39\u6AA2\u8996\u3002"
            },
            emphasisLine: {
              name: "\u555F\u7528\u5F37\u8ABF\u7DDA\uFF08\u5DE6\u5074\uFF09",
              desc: "\u5F37\u8ABF\u76EE\u524D\u5340\u584A\u5DE6\u5074\u7684\u9023\u63A5\u7DDA\u3002\u95DC\u9589\u5F8C\u4FDD\u6301\u70BA\u5F31\u5316\u984F\u8272\u3002"
            },
            editorContextMenu: {
              enabled: {
                name: "\u7DE8\u8F2F\u5668\u53F3\u9375\u9078\u55AE",
                desc: "\u5728 Outliner \u7DE8\u8F2F\u6A21\u5F0F\u4E2D\u4F7F\u7528 BLP \u7684\u53F3\u9375\u9078\u55AE\uFF08\u652F\u63F4\u6309\u5916\u639B ID \u767D\u540D\u55AE\u6CE8\u5165\uFF09\u3002"
              },
              allowedPlugins: {
                name: "\u5141\u8A31\u6CE8\u5165\u7684\u5916\u639B ID",
                desc: "\u6BCF\u9805\u4E00\u500B\u5916\u639B ID\u3002\u53EA\u6709\u767D\u540D\u55AE\u5167\u5916\u639B\u53EF\u5411 Outliner \u7DE8\u8F2F\u9078\u55AE\u65B0\u589E\u9805\u76EE\u3002\u52A0\u5165 `core` \u4EE5\u5305\u542B\u6838\u5FC3\u9078\u55AE\u9805\u76EE\u3002",
                addButton: "\u65B0\u589E\u5916\u639B",
                placeholder: "metadata-menu"
              }
            },
            editorCommands: {
              enabled: {
                name: "\u7DE8\u8F2F\u5668\u547D\u4EE4\u6A4B\u63A5\uFF08\u5FEB\u6377\u9375\uFF09",
                desc: "\u5728 Outliner \u7DE8\u8F2F\u5340\u584A\u6642\u555F\u7528 core \u7DE8\u8F2F\u5668\u5FEB\u6377\u9375\uFF08Ctrl+B \u7B49\uFF09\u548C\u767D\u540D\u55AE\u5916\u639B\u7684\u7DE8\u8F2F\u5668\u547D\u4EE4\u3002\u6CE8\u610F\uFF1A\u4F9D\u8CF4 CM6 \u6CE8\u5165\u7684\u5916\u639B\u4E0D\u652F\u63F4\u3002"
              },
              allowedPlugins: {
                name: "\u7DE8\u8F2F\u5668\u547D\u4EE4\u5916\u639B\u767D\u540D\u55AE",
                desc: "\u6BCF\u9805\u4E00\u500B\u5916\u639B ID\u3002\u53EA\u6709\u767D\u540D\u55AE\u5167\u5916\u639B\u53EF\u4EE5\u5728 Outliner \u4E2D\u57F7\u884C\u7DE8\u8F2F\u5668\u547D\u4EE4\u3002\u52A0\u5165 `core` \u4EE5\u5305\u542B core \u7DE8\u8F2F\u5668\u547D\u4EE4\u3002",
                addButton: "\u65B0\u589E\u5916\u639B",
                placeholder: "highlightr-plugin"
              },
              copyFromMenuAllowlist: {
                name: "\u540C\u6B65\u767D\u540D\u55AE",
                desc: "\u5C07\u300C\u7DE8\u8F2F\u5668\u9078\u55AE\u767D\u540D\u55AE\u300D\u8907\u88FD\u5230\u300C\u7DE8\u8F2F\u5668\u547D\u4EE4\u767D\u540D\u55AE\u300D\u3002\u63D0\u793A\uFF1A\u60F3\u8981 Ctrl+B \u7B49\u683C\u5F0F\u5316\u5FEB\u6377\u9375\uFF0C\u8ACB\u78BA\u4FDD\u5305\u542B `core`\u3002",
                buttonText: "\u5F9E\u7DE8\u8F2F\u5668\u9078\u55AE\u767D\u540D\u55AE\u8907\u88FD"
              }
            },
            listEditor: {
              moveUp: "\u4E0A\u79FB",
              moveDown: "\u4E0B\u79FB",
              remove: "\u79FB\u9664"
            },
            childrenOnSplit: {
              name: "Enter \u62C6\u5206\uFF1A\u5B50\u584A\u8655\u7406",
              desc: "\u4F7F\u7528 Enter \u62C6\u5206\u5340\u584A\u6642\uFF0C\u9078\u64C7\u5B50\u584A\u4FDD\u7559\u5728\u539F\u5340\u584A\u6216\u79FB\u52D5\u5230\u65B0\u5340\u584A\u3002",
              options: {
                keep: "\u5B50\u584A\u4FDD\u7559\u5728\u539F\u5340\u584A",
                move: "\u5B50\u584A\u79FB\u52D5\u5230\u65B0\u5340\u584A"
              }
            },
            pasteMultiline: {
              name: "\u8CBC\u4E0A\u591A\u884C\u6587\u5B57",
              desc: "\u5728\u5340\u584A\u5167\u8CBC\u4E0A\u591A\u884C\u6587\u5B57\u6642\uFF0C\u9078\u64C7\u62C6\u5206\u70BA\u591A\u500B\u5340\u584A\u6216\u4FDD\u7559\u70BA\u55AE\u5340\u584A\u591A\u884C\u6587\u5B57\u3002",
              options: {
                split: "\u62C6\u5206\u70BA\u591A\u500B\u5340\u584A\uFF08\u9810\u8A2D\uFF09",
                multiline: "\u4FDD\u7559\u70BA\u76EE\u524D\u5340\u584A\u5167\u591A\u884C\u6587\u5B57"
              }
            },
            backspaceWithChildren: {
              name: "\u884C\u9996 Backspace\uFF08\u6709\u5B50\u584A\uFF09",
              desc: "\u7576\u5340\u584A\u6709\u5B50\u584A\u6642\uFF0C\u9078\u64C7 Backspace \u8207\u4E0A\u4E00\u5340\u584A\u5408\u4F75\uFF08\u9810\u8A2D\uFF09\u6216\u512A\u5148 Outdent\u3002",
              options: {
                merge: "\u8207\u4E0A\u4E00\u5340\u584A\u5408\u4F75\uFF08\u9810\u8A2D\uFF09",
                outdent: "\u512A\u5148 Outdent"
              }
            },
            tasksHelp: {
              name: "\u4EFB\u52D9",
              desc: '\u4EFB\u52D9\u5340\u584A\u5728\u78C1\u789F\u4E0A\u4F7F\u7528 Obsidian \u539F\u751F\u7684 `- [ ]` / `- [x]` \u8A9E\u6CD5\u3002\u547D\u4EE4\uFF1A"${toggleTaskStatus}"\uFF08Mod+Enter\uFF09\u8207 "${toggleTaskMarker}"\uFF08Mod+Shift+Enter\uFF09\u3002\u53EF\u5728 \u8A2D\u5B9A -> \u5FEB\u6377\u9375 \u4E2D\u8A2D\u5B9A\u3002'
            },
            debug: {
              name: "\u9664\u932F\u8A18\u9304",
              desc: "\u5C07 Outliner \u5167\u90E8\u932F\u8AA4\u8F38\u51FA\u5230 DevTools \u4E3B\u63A7\u53F0\u3002"
            },
            commands: {
              toggleTaskStatus: "Outliner\uFF1A\u5207\u63DB\u4EFB\u52D9\u72C0\u614B",
              toggleTaskMarker: "Outliner\uFF1A\u5207\u63DB\u4EFB\u52D9\u6A19\u8A18"
            },
            contextMenu: {
              copyBlockReference: "\u8907\u88FD\u5340\u584A\u5F15\u7528",
              copyBlockEmbed: "\u8907\u88FD\u5340\u584A\u5D4C\u5165",
              copyBlockUrl: "\u8907\u88FD\u5340\u584A URL",
              convertToTask: "\u8F49\u70BA\u4EFB\u52D9",
              convertToNormalBlock: "\u8F49\u70BA\u4E00\u822C\u5340\u584A",
              copy: "\u8907\u88FD",
              cut: "\u526A\u4E0B",
              paste: "\u8CBC\u4E0A",
              pasteAsText: "\u4EE5\u7D14\u6587\u5B57\u8CBC\u4E0A",
              delete: "\u522A\u9664",
              collapse: "\u647A\u758A",
              expand: "\u5C55\u958B"
            }
          },
          //  List Blocks
          enhancedListBlocks: {
            title: "\u589E\u5F37 List Blocks",
            desc: "\u8A2D\u5B9A\u589E\u5F37 List Blocks \u7684\u555F\u7528\u7BC4\u570D\uFF08blp-view\u3001\u7CFB\u7D71\u884C\u96B1\u85CF\u3001\u91CD\u8907 ^id \u4FEE\u5FA9\u50C5\u5728\u555F\u7528\u6A94\u6848\u5167\u751F\u6548\uFF09\u3002\u6EFF\u8DB3\u4EFB\u4E00\u689D\u4EF6\u5373\u555F\u7528\uFF1A\u4F4D\u65BC\u555F\u7528\u8CC7\u6599\u593E/\u555F\u7528\u6A94\u6848\u6E05\u55AE\uFF0C\u6216\u6A94\u6848 frontmatter \u542B `blp_enhanced_list: true`\u3002",
            groups: {
              scopeAndBehavior: {
                title: "\u555F\u7528\u7BC4\u570D\u8207\u884C\u70BA"
              },
              scope: {
                title: "\u555F\u7528\u7BC4\u570D"
              },
              behavior: {
                title: "\u884C\u70BA"
              },
              blockMode: {
                title: "\u5340\u584A\u6A21\u5F0F"
              },
              normalization: {
                title: "\u6A19\u6E96\u5316"
              }
            },
            dataviewStatus: {
              available: "\u2705 Dataview \u63D2\u4EF6\u5DF2\u5B89\u88DD\u4E26\u555F\u7528(\u7248\u672C ${version})",
              unavailable: "\u274C Dataview \u63D2\u4EF6\u672A\u5B89\u88DD\u6216\u672A\u555F\u7528\uFF0Cblp-view \u5C07\u7121\u6CD5\u904B\u4F5C\u3002"
            },
            enabledFolders: {
              name: "\u555F\u7528\u8CC7\u6599\u593E",
              desc: "\u6BCF\u884C\u4E00\u500B\u8CC7\u6599\u593E\u8DEF\u5F91\uFF08\u76F8\u5C0D vault \u6839\u76EE\u9304\uFF09\u3002\u8A72\u8CC7\u6599\u593E\u4E0B\u7684 Markdown \u6A94\u6848\u555F\u7528\u3002"
            },
            enabledFiles: {
              name: "\u555F\u7528\u6A94\u6848",
              desc: "\u6BCF\u884C\u4E00\u500B\u6A94\u6848\u8DEF\u5F91\uFF08\u76F8\u5C0D vault \u6839\u76EE\u9304\uFF09\u3002\u9019\u4E9B Markdown \u6A94\u6848\u555F\u7528\u3002"
            },
            hideSystemLine: {
              name: "\u96B1\u85CF\u7CFB\u7D71\u884C",
              desc: "\u5728 Live Preview \u8207 Reading mode \u4E0B\u96B1\u85CF\u7CFB\u7D71\u884C\uFF08`[date:: ...] ^id`\uFF09\u3002\u95DC\u9589\u5F8C\u986F\u793A\u7CFB\u7D71\u884C\uFF08\u7528\u65BC\u9664\u932F\uFF09\u3002"
            },
            hideNativeFoldIndicator: {
              name: "\u96B1\u85CF Obsidian \u5167\u5EFA\u6298\u758A\u6307\u793A\u5668",
              desc: "\u5728 Live Preview\uFF08\u50C5\u555F\u7528\u6A94\u6848\uFF09\u4E2D\u96B1\u85CF\u5217\u8868\u9805\u76EE\u65C1\u7684\u6298\u758A\u5C0F\u4E09\u89D2\uFF0C\u964D\u4F4E\u62D6\u66F3\u6642\u8AA4\u89F8\u6298\u758A/\u5C55\u958B\u3002"
            },
            subtreeClipboard: {
              name: "\u555F\u7528\u5B50\u6A39\u526A\u8CBC\u7C3F\uFF08\u4EE5\u5340\u584A\u6A39 copy/cut/paste\uFF09",
              desc: "\u7576\u5340\u584A\u9078\u64C7\u6A21\u5F0F\u555F\u7528\u6642\uFF0CCopy/Cut/Paste \u4EE5\u5217\u8868\u9805\u5B50\u6A39\uFF08\u5340\u584A\u6A39\u8A9E\u610F\uFF09\u70BA\u55AE\u4F4D\uFF0C\u800C\u975E\u7D14\u6587\u5B57\u3002"
            },
            doubleParenTrigger: {
              name: "\u555F\u7528 `((` \u89F8\u767C\u5340\u584A\u5F15\u7528\u63D2\u5165",
              desc: "\u555F\u7528\u5F8C\uFF0C\u8F38\u5165 `((` \u6703\u958B\u555F\u5340\u584A\u5F15\u7528\u9078\u64C7\u5668\uFF0C\u4E26\u5C07 `((` \u66FF\u63DB\u70BA\u6A19\u6E96 `[[file#^id]]` \u5F15\u7528\u3002\u4E0D\u7FD2\u6163 Roam/Logseq \u98A8\u683C\u53EF\u4FDD\u6301\u95DC\u9589\u3002"
            },
            blockPeek: {
              name: "\u555F\u7528 Block Peek\uFF08\u4E0A\u4E0B\u6587\uFF09",
              desc: "\u70BA `[[file#^id]]` \u5340\u584A\u63D0\u4F9B Block Peek \u5165\u53E3\uFF08\u628A\u624B\u9078\u55AE + blp-view peek \u6309\u9215\uFF09\u3002"
            },
            handleAffordance: {
              name: "\u986F\u793A\u5217\u8868\u628A\u624B",
              desc: "\u5728 Live Preview \u4E2D\u5C07\u7121\u5E8F\u5217\u8868\u7B26\u865F\u6E32\u67D3\u70BA\u628A\u624B\uFF08\u50C5\u5C0D\u555F\u7528\u6A94\u6848\u751F\u6548\uFF09\uFF0C\u65B9\u4FBF\u767C\u73FE\u62D6\u66F3/\u6298\u758A\u7B49\u4E92\u52D5\u3002"
            },
            handleActions: {
              name: "\u555F\u7528\u5217\u8868\u628A\u624B\u52D5\u4F5C",
              desc: "\u5728 Live Preview \u4E2D\u555F\u7528\u7121\u5E8F\u6E05\u55AE\u628A\u624B\u7684\u9EDE\u64CA\u6298\u758A\u8207\u53F3\u9375\u628A\u624B\u9078\u55AE\uFF08\u50C5\u5C0D\u555F\u7528\u6A94\u6848\u751F\u6548\uFF09\u3002",
              clickAction: {
                name: "\u628A\u624B\u5DE6\u9375\u52D5\u4F5C",
                desc: "\u9078\u64C7\u5DE6\u9375\u9EDE\u64CA\u5217\u8868\u628A\u624B\u6642\u57F7\u884C\u7684\u52D5\u4F5C\u3002\u53F3\u9375\u4E00\u5F8B\u958B\u555F\u628A\u624B\u9078\u55AE\u3002",
                options: {
                  toggleFolding: "\u5207\u63DB\u6298\u758A",
                  selectBlock: "\u9078\u64C7\u5340\u584A",
                  menu: "\u958B\u555F\u628A\u624B\u9078\u55AE",
                  none: "\u7121"
                }
              },
              menu: {
                toggleFolding: "\u5207\u63DB\u6298\u758A",
                copyBlockLink: "\u8907\u88FD\u5340\u584A\u9023\u7D50",
                copyBlockEmbed: "\u8907\u88FD\u5340\u584A\u5D4C\u5165",
                zoomIn: "\u653E\u5927\uFF08Zoom in\uFF09",
                zoomOut: "\u7E2E\u5C0F\uFF08Zoom out\uFF09"
              }
            },
            indentCodeBlocks: {
              name: "\u7E2E\u9032\u5DE2\u72C0\u7A0B\u5F0F\u78BC\u5340\u584A",
              desc: "\u5728 Live Preview \u4E2D\u5C07\u6E05\u55AE\u9805\u5167\u7684\u570D\u6B04\u7A0B\u5F0F\u78BC\u5340\u584A\u4F9D\u5C64\u7D1A\u7E2E\u9032\u986F\u793A\uFF08\u50C5\u5C0D\u555F\u7528\u6A94\u6848\u751F\u6548\uFF09\uFF0C\u4E0D\u4FEE\u6539\u6A94\u6848\u5167\u5BB9\u3002"
            },
            deleteSubtreeOnDelete: {
              name: "\u522A\u9664\u5217\u8868\u9805\u6642\u522A\u9664\u5B50\u9805",
              desc: "\u958B\u555F\u5F8C\uFF1A\u522A\u9664\u7236\u5217\u8868\u9805\u6703\u4E00\u4F75\u522A\u9664\u5176\u5B50\u5217\u8868\uFF08Logseq/Roam \u98A8\u683C\uFF09\u3002\u95DC\u9589\u5F8C\uFF1A\u5B50\u9805\u4FDD\u7559\uFF0C\u50C5\u522A\u9664\u7CFB\u7D71\u884C\u3002"
            },
            normalizeOnSave: {
              name: "\u5132\u5B58\u6642\u6A19\u6E96\u5316\u6E05\u55AE\u683C\u5F0F",
              desc: "\u50C5\u5728\u5132\u5B58\u6642\u751F\u6548\uFF08\u50C5\u5C0D\u555F\u7528\u6A94\u6848\uFF09\u3002\u53EA\u5C0D\u4E0A\u6B21\u5132\u5B58\u5F8C\u4F60\u7DE8\u8F2F\u904E\u7684\u6E05\u55AE\u9805\u5957\u7528\u898F\u5247\uFF1B\u8F38\u5165\u6642\u4E0D\u6539\u52D5\u3002",
              rules: {
                tabsToSpaces: {
                  name: "\u5C07\u884C\u9996 Tab \u8F49\u70BA\u7A7A\u683C",
                  desc: "\u5C07\u884C\u9996\u7E2E\u6392\u7684 Tab \u8F49\u70BA\u7A7A\u683C\uFF08tab \u5BEC\u5EA6\u53EF\u8A2D\u5B9A\uFF09\u3002\u70BA\u907F\u514D\u6539\u8B8A\u5217\u8868\u5C64\u7D1A\uFF0C\u5FC5\u8981\u6642\u6703\u56DE\u9000\u5230 Markdown \u7684 tab \u7E2E\u6392\u8A9E\u7FA9\u3002\u4F8B\uFF08tab=2\uFF09\uFF1A`\\t- a` -> `  - a`\u3002",
                  tabSize: {
                    name: "Tab \u5BEC\u5EA6\uFF08\u7A7A\u683C\uFF09",
                    desc: "\u6A19\u6E96\u5316\u6642\uFF0C\u5C07\u884C\u9996 Tab \u5C55\u958B\u70BA\u591A\u5C11\u500B\u7A7A\u683C\u3002\u9810\u8A2D\uFF1A2\u3002"
                  }
                },
                cleanupInvalidSystemLines: {
                  name: "\u6E05\u7406\u7121\u6548/\u591A\u9918\u7CFB\u7D71\u884C",
                  desc: "\u522A\u9664\u5DF2\u7DE8\u8F2F\u6E05\u55AE\u9805\u4E2D\u7684\u591A\u9918\u7CFB\u7D71\u884C\uFF08\u4FDD\u7559\u7B2C\u4E00\u689D\uFF09\uFF0C\u4E26\u522A\u9664\u6E05\u55AE\u9805\u6B63\u4E0A\u65B9\u7684\u5B64\u5152\u7CFB\u7D71\u884C\u3002\u4F8B\uFF1A`  [date:: ...] ^a` + `  [date:: ...] ^b` -> \u50C5\u4FDD\u7559\u4E00\u689D\u3002"
                },
                mergeSplitSystemLine: {
                  name: "\u5408\u4F75\u62C6\u5206\u7684\u7CFB\u7D71\u884C",
                  desc: "\u628A\u5169\u884C\u7CFB\u7D71\u884C\u5408\u4F75\u70BA\u4E00\u884C\u3002\u4F8B\uFF1A`  [date:: 2026-01-26T16:01:21]` + `  ^7fp1` -> `  [date:: 2026-01-26T16:01:21] ^7fp1`\u3002"
                },
                systemLineIndent: {
                  name: "\u4FEE\u6B63\u7CFB\u7D71\u884C\u7E2E\u6392",
                  desc: "\u628A\u7CFB\u7D71\u884C\u7E2E\u6392\u5F37\u5236\u4FEE\u6B63\u70BA continuation indent\uFF08\u8207 `- ` / \u6838\u53D6\u65B9\u584A\u5F8C\u7684\u5167\u5BB9\u6B04\u5C0D\u9F4A\uFF09\u3002\u4F8B\uFF1A`- a` + `[date:: ...] ^id` -> `- a` + `  [date:: ...] ^id`\u3002"
                },
                ensureSystemLineForTouchedItems: {
                  name: "\u70BA\u5DF2\u7DE8\u8F2F\u7684\u6E05\u55AE\u9805\u88DC\u9F4A\u7CFB\u7D71\u884C",
                  desc: "\u82E5\u5DF2\u7DE8\u8F2F\u7684\u6E05\u55AE\u9805\u7F3A\u5C11\u7CFB\u7D71\u884C\uFF0C\u5132\u5B58\u6642\u81EA\u52D5\u63D2\u5165\uFF08\u5FC5\u8981\u6642\u79FB\u52D5\u5230\u5B50\u6E05\u55AE\u4E4B\u524D\uFF09\u3002"
                }
              }
            },
            blpView: {
              title: "blp-view\uFF08Query/View\uFF09",
              desc: "blp-view \u57F7\u884C\u8B77\u6B04\u8A2D\u5B9A\uFF08\u9700\u8981 Dataview\uFF09\u3002",
              allowMaterialize: {
                name: "\u5141\u8A31 materialize \u5BEB\u56DE",
                desc: "\u95DC\u9589\u5F8C\uFF0C\u5305\u542B `render.mode: materialize` \u7684 blp-view \u5C07\u5831\u932F\u4E14\u4E0D\u6703\u4FEE\u6539\u6A94\u6848\u3002"
              },
              maxSourceFiles: {
                name: "\u6700\u5927\u6383\u63CF\u6A94\u6848\u6578",
                desc: "0 \u8868\u793A\u4E0D\u9650\u5236\uFF1B\u82E5\u4E00\u6B21 view \u9700\u8981\u6383\u63CF\u8D85\u904E\u6B64\u6578\u91CF\u7684\u6A94\u6848\uFF0C\u5C07\u505C\u6B62\u57F7\u884C\u4E26\u63D0\u793A\u932F\u8AA4\u3002"
              },
              maxResults: {
                name: "\u6700\u5927\u8F38\u51FA\u7D50\u679C\u6578",
                desc: "0 \u8868\u793A\u4E0D\u9650\u5236\uFF1B\u82E5\u5339\u914D\u7D50\u679C\u8D85\u904E\u6B64\u6578\u91CF\uFF0C\u5C07\u622A\u65B7\u8F38\u51FA\u4E26\u63D0\u793A\u300C\u5DF2\u622A\u65B7\u300D\u3002"
              },
              showDiagnostics: {
                name: "\u986F\u793A blp-view \u8A3A\u65B7\u8CC7\u8A0A",
                desc: "\u5728\u8F38\u51FA\u4E0B\u65B9\u986F\u793A\u6383\u63CF\u6578\u91CF\u3001\u5339\u914D\u6578\u91CF\u8207\u8017\u6642\u7B49\u8CC7\u8A0A\u3002"
              }
            },
            ops: {
              title: "\u589E\u5F37 List Blocks \u64CD\u4F5C",
              desc: "\u70BA list item \u5B50\u6A39\u63D0\u4F9B\u985E\u4F3C outliner \u7684\u64CD\u4F5C\u8207 UI \u589E\u5F37\uFF08\u50C5 Live Preview\uFF0C\u50C5\u555F\u7528\u6A94\u6848\u751F\u6548\uFF09\u3002",
              zoom: {
                name: "\u555F\u7528 Zoom\uFF08Live Preview\uFF09",
                desc: "Zoom in/out \u5230\u7576\u524D list \u5B50\u6A39\u3002\u8207\u7B2C\u4E09\u65B9\u63D2\u4EF6 `obsidian-zoom` \u885D\u7A81\uFF0C\u4E0D\u53EF\u540C\u6642\u555F\u7528\u3002"
              },
              move: {
                name: "\u555F\u7528\u5B50\u6A39\u4E0A\u79FB/\u4E0B\u79FB",
                desc: "\u5728\u7576\u524D\u6A94\u6848\u5167\uFF0C\u5C07\u7576\u524D list \u5B50\u6A39\u5728\u5144\u5F1F\u7BC0\u9EDE\u4E4B\u9593\u4E0A\u79FB/\u4E0B\u79FB\u3002\u8207 `obsidian-outliner` \u885D\u7A81\u3002"
              },
              indent: {
                name: "\u555F\u7528\u5B50\u6A39\u7E2E\u6392/\u53CD\u7E2E\u6392",
                desc: "\u7E2E\u6392/\u53CD\u7E2E\u6392\u7576\u524D list \u5B50\u6A39\uFF08\u53EF\u958B\u95DC\uFF09\u3002\u8207 `obsidian-outliner` \u885D\u7A81\u3002"
              },
              dragDrop: {
                name: "\u555F\u7528\u62D6\u66F3\uFF08Drag & Drop\uFF09",
                desc: "\u5728\u7576\u524D\u6A94\u6848\u5167\u62D6\u66F3 list \u5B50\u6A39\u9032\u884C\u6392\u5E8F/\u6539\u8B8A\u5C64\u7D1A\uFF08\u4E0D\u652F\u63F4\u8DE8\u6A94\u6848\uFF09\u3002\u8207 `obsidian-outliner` \u885D\u7A81\u3002"
              },
              verticalLines: {
                name: "\u555F\u7528\u5782\u76F4\u7E2E\u6392\u7DDA",
                desc: "\u5728 Live Preview \u4E0B\u6E32\u67D3\u7E2E\u6392\u5C0E\u5F15\u7DDA\uFF08\u53D7\u4E3B\u984C\u5F71\u97FF\uFF0Cbest-effort\uFF09\u3002\u8207 `obsidian-outliner` \u885D\u7A81\u3002"
              },
              bulletThreading: {
                name: "\u555F\u7528 Bullet Threading",
                desc: "\u9AD8\u4EAE\u7576\u524D list block \u53CA\u5176\u7956\u5148\u8DEF\u5F91\uFF08active path\uFF09\u3002\u8207 `obsidian-outliner` \u885D\u7A81\u3002"
              }
            }
          }
        },
        // 
        commands: {
          // Flow 
          h1: "\u6A19\u984C 1",
          h2: "\u6A19\u984C 2",
          h3: "\u6A19\u984C 3",
          h4: "\u6A19\u984C 4",
          h5: "\u6A19\u984C 5",
          h6: "\u6A19\u984C 6",
          bold: "\u7C97\u9AD4",
          italic: "\u659C\u9AD4",
          strikethrough: "\u522A\u9664\u7DDA",
          highlight: "\u87A2\u5149\u6A19\u793A",
          code: "\u7A0B\u5F0F\u78BC",
          codeblock: "\u7A0B\u5F0F\u78BC\u5340\u584A",
          quote: "\u5F15\u7528",
          link: "\u9023\u7D50",
          image: "\u5716\u7247",
          table: "\u8868\u683C",
          divider: "\u5206\u9694\u7DDA",
          embed: "\u5D4C\u5165",
          tag: "\u6A19\u7C64",
          callout: "\u6A19\u8A3B",
          list: "\u6E05\u55AE",
          numberList: "\u6578\u5B57\u6E05\u55AE",
          task: "\u4EFB\u52D9",
          toggleList: "\u647A\u758A\u6E05\u55AE",
          space: "\u7A7A\u683C",
          newNote: "\u65B0\u5EFA\u7B46\u8A18",
          newFolder: "\u65B0\u5EFA\u8CC7\u6599\u593E"
        },
        // 
        commandsSuggest: {
          noResult: "\u672A\u627E\u5230\u7D50\u679C"
        },
        // 
        metadataTypes: {
          fileName: "\u6A94\u6848\u540D\u7A31",
          path: "\u8DEF\u5F91",
          folder: "\u8CC7\u6599\u593E",
          created: "\u5EFA\u7ACB\u6642\u9593",
          lastModified: "\u6700\u5F8C\u4FEE\u6539",
          extension: "\u526F\u6A94\u540D",
          size: "\u5927\u5C0F",
          tags: "\u6A19\u7C64",
          inlinks: "\u53CD\u5411\u9023\u7D50",
          outlinks: "\u6B63\u5411\u9023\u7D50",
          color: "\u984F\u8272"
        },
        // 
        whatsNew: {
          titleWithVersion: "Block Link Plus \u2014 v${1} \u66F4\u65B0\u5167\u5BB9",
          updatedFromTo: "\u5DF2\u5F9E v${1} \u66F4\u65B0\u5230 v${2}",
          viewChangelog: "\u67E5\u770B\u5B8C\u6574\u66F4\u65B0\u65E5\u8A8C",
          close: "\u95DC\u9589",
          v1_8_0: [
            "\u5167\u5D4C\u7DE8\u8F2F\uFF1A\u9077\u79FB\u5230\u539F\u751F leaf \u5F15\u64CE\uFF08\u79FB\u690D\u81EA sync-embeds\uFF0CLive Preview \u66F4\u7A69\u5B9A\uFF09\u3002",
            "\u79FB\u9664\u820A\u7248 `!![[...]]` \u8A9E\u6CD5\uFF0C\u8ACB\u6539\u7528 `![[...]]`\u3002",
            "\u591A\u884C\u584A\uFF1A\u6539\u9032 `^id-id` \u7BC4\u570D\u5EFA\u7ACB\uFF08\u5B89\u5168\u6642\u884C\u5C3E\u5167\u5D4C\u63D2\u5165\uFF1B\u5426\u5247\u5728\u584A\u7D50\u675F\u5F8C\u4EE5\u7368\u4F54\u884C\u63D2\u5165\uFF09\u3002",
            "\u4FEE\u6B63\uFF1A\u9078\u5340\u5728\u55AE\u500B\u6E05\u55AE\u9805\u5167\u6642\uFF0C\u7BC4\u570D marker \u4E0D\u518D\u64F4\u5230\u6574\u500B list\u3002",
            "\u4FEE\u6B63\uFF1A\u591A\u584A\u6A21\u5F0F\u4EE5\u300C\u584A\u300D\uFF08\u6BB5\u843D/\u6E05\u55AE\u9805\uFF09\u70BA\u55AE\u4F4D\uFF1B\u6E05\u55AE\u9805\u6709\u7E8C\u884C\u6642\uFF0CID \u6703\u63D2\u5728\u8A72\u9805\u6700\u5F8C\u4E00\u884C\uFF08#22/#27\uFF09\u3002",
            "`^id-id` \u7BC4\u570D\u5D4C\u5165\u6E32\u67D3\u4E00\u81F4\uFF08\u5373\u4F7F\u95DC\u9589\u5167\u5D4C\u7DE8\u8F2F\uFF09\u3002",
            "\u4FEE\u6B63\uFF1A\u95B1\u8B80\u6A21\u5F0F\u5F8C\u8655\u7406\u4E0D\u518D\u5C0E\u81F4\u5167\u5BB9\u88AB\u6E05\u7A7A\uFF08#29\uFF09\u3002",
            "\u65B0\u589E\uFF1A\u5347\u7D1A\u5F8C\u5F48\u51FA\u4E00\u6B21\u66F4\u65B0\u8AAA\u660E\uFF08What's New\uFF09\u3002"
          ],
          fallback: [
            "\u8ACB\u67E5\u770B\u5B8C\u6574\u66F4\u65B0\u65E5\u8A8C\u4E86\u89E3\u8A73\u60C5\u3002"
          ]
        },
        // Notices
        notices: {
          fileOutlinerUnsupportedBlockMarkdown: "\u6B64\u5340\u584A\u5305\u542B\u5217\u8868/\u6A19\u984C\u8A9E\u6CD5\u3002\u70BA\u4FDD\u6301 Outliner \u7D50\u69CB\uFF0C\u5C07\u5176\u4EE5\u7D14\u6587\u5B57\u6E32\u67D3\u3002"
        }
      }
    };
    this.lang = "en";
    this.ensureFileOutlinerPaneMenuStrings();
    const rawLang = window.localStorage.getItem("language") || import_moment.default.locale() || "";
    const lower = String(rawLang).trim().toLowerCase();
    const isZhTw = lower === "zh-tw" || lower === "zh_tw" || lower.startsWith("zh-tw") || lower.startsWith("zh_tw") || lower.startsWith("zh-hant") || lower.startsWith("zh-hk") || lower.startsWith("zh-mo");
    const isZh = lower === "zh" || lower === "zh-cn" || lower === "zh_cn" || lower.startsWith("zh-cn") || lower.startsWith("zh_cn") || lower.startsWith("zh-hans");
    if (isZhTw)
      this.lang = "zh-TW";
    else if (isZh)
      this.lang = "zh";
    else
      this.lang = "en";
  }
  ensureFileOutlinerPaneMenuStrings() {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g, _h, _i, _j, _k, _l;
    const en = (_c2 = (_b2 = (_a2 = this.all) == null ? void 0 : _a2.en) == null ? void 0 : _b2.settings) == null ? void 0 : _c2.fileOutliner;
    if (en) {
      (_d2 = en.paneMenu) != null ? _d2 : en.paneMenu = {
        openAsMarkdown: "Open as Markdown (source)",
        openAsMarkdownNewTab: "Open as Markdown (new tab)",
        openAsOutliner: "Open as Outliner",
        openAsOutlinerNewTab: "Open as Outliner (new tab)"
      };
    }
    const zh = (_g = (_f2 = (_e2 = this.all) == null ? void 0 : _e2.zh) == null ? void 0 : _f2.settings) == null ? void 0 : _g.fileOutliner;
    if (zh) {
      (_h = zh.paneMenu) != null ? _h : zh.paneMenu = {
        openAsMarkdown: "\u6253\u5F00\u4E3A Markdown\uFF08\u6E90\u7801\uFF09",
        openAsMarkdownNewTab: "\u6253\u5F00\u4E3A Markdown\uFF08\u65B0\u6807\u7B7E\u9875\uFF09",
        openAsOutliner: "\u6253\u5F00\u4E3A Outliner",
        openAsOutlinerNewTab: "\u6253\u5F00\u4E3A Outliner\uFF08\u65B0\u6807\u7B7E\u9875\uFF09"
      };
    }
    const zhTw = (_k = (_j = (_i = this.all) == null ? void 0 : _i["zh-TW"]) == null ? void 0 : _j.settings) == null ? void 0 : _k.fileOutliner;
    if (zhTw) {
      (_l = zhTw.paneMenu) != null ? _l : zhTw.paneMenu = {
        openAsMarkdown: "\u4EE5 Markdown\uFF08\u539F\u59CB\u78BC\uFF09\u958B\u555F",
        openAsMarkdownNewTab: "\u4EE5 Markdown\uFF08\u65B0\u5206\u9801\uFF09\u958B\u555F",
        openAsOutliner: "\u4EE5 Outliner \u958B\u555F",
        openAsOutlinerNewTab: "\u4EE5 Outliner\uFF08\u65B0\u5206\u9801\uFF09\u958B\u555F"
      };
    }
  }
  get texts() {
    return this.all[this.lang] || this.all.en;
  }
  get commandPalette() {
    var _a2;
    return ((_a2 = this.all[this.lang]) == null ? void 0 : _a2.commandPalette) || this.all.en.commandPalette;
  }
  get settings() {
    var _a2;
    return ((_a2 = this.all[this.lang]) == null ? void 0 : _a2.settings) || this.all.en.settings;
  }
  get commands() {
    var _a2;
    return ((_a2 = this.all[this.lang]) == null ? void 0 : _a2.commands) || this.all.en.commands;
  }
  get buttons() {
    var _a2;
    return ((_a2 = this.all[this.lang]) == null ? void 0 : _a2.buttons) || this.all.en.buttons;
  }
  get labels() {
    var _a2;
    return ((_a2 = this.all[this.lang]) == null ? void 0 : _a2.labels) || this.all.en.labels;
  }
  get notice() {
    var _a2;
    return ((_a2 = this.all[this.lang]) == null ? void 0 : _a2.notice) || this.all.en.notice;
  }
  get whatsNew() {
    var _a2;
    return ((_a2 = this.all[this.lang]) == null ? void 0 : _a2.whatsNew) || this.all.en.whatsNew;
  }
  get notices() {
    var _a2;
    return ((_a2 = this.all[this.lang]) == null ? void 0 : _a2.notices) || this.all.en.notices;
  }
};
var i18n = new T();
var i18n_default = i18n;

// src/utils/dataview-detector.ts
var import_obsidian_dataview = __toESM(require_lib());
function detectDataviewStatus() {
  var _a2;
  try {
    const api = (0, import_obsidian_dataview.getAPI)();
    if (!api) {
      return {
        installed: false,
        enabled: false,
        version: null,
        functioning: false,
        api: null
      };
    }
    const version = ((_a2 = api.version) == null ? void 0 : _a2.current) || null;
    const functioning = !!(api.pages && api.page && typeof api.pages === "function");
    return {
      installed: true,
      enabled: true,
      version,
      functioning,
      api
    };
  } catch (error) {
    console.warn("Block Link Plus: Error detecting Dataview status:", error);
    return {
      installed: false,
      enabled: false,
      version: null,
      functioning: false,
      api: null
    };
  }
}
function isDataviewAvailable() {
  const status = detectDataviewStatus();
  return status.installed && status.enabled && status.functioning;
}
function getDataviewApi() {
  const status = detectDataviewStatus();
  return status.api;
}

// src/features/file-outliner-view/labels.ts
var FALLBACK_COMMANDS = {
  toggleTaskStatus: "Outliner: Toggle task status",
  toggleTaskMarker: "Outliner: Toggle task marker"
};
var FALLBACK_CONTEXT_MENU = {
  copyBlockReference: "Copy block reference",
  copyBlockEmbed: "Copy block embed",
  copyBlockUrl: "Copy block URL",
  convertToTask: "Convert to task",
  convertToNormalBlock: "Convert to normal block",
  copy: "Copy",
  cut: "Cut",
  paste: "Paste",
  pasteAsText: "Paste as text",
  delete: "Delete",
  collapse: "Collapse",
  expand: "Expand"
};
function getFileOutlinerCommandLabels() {
  var _a2, _b2, _c2, _d2;
  const raw = (_b2 = (_a2 = i18n_default.settings) == null ? void 0 : _a2.fileOutliner) == null ? void 0 : _b2.commands;
  if (!raw)
    return FALLBACK_COMMANDS;
  return {
    toggleTaskStatus: String((_c2 = raw.toggleTaskStatus) != null ? _c2 : FALLBACK_COMMANDS.toggleTaskStatus),
    toggleTaskMarker: String((_d2 = raw.toggleTaskMarker) != null ? _d2 : FALLBACK_COMMANDS.toggleTaskMarker)
  };
}
function getFileOutlinerContextMenuLabels() {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g, _h, _i, _j, _k, _l, _m, _n;
  const raw = (_b2 = (_a2 = i18n_default.settings) == null ? void 0 : _a2.fileOutliner) == null ? void 0 : _b2.contextMenu;
  if (!raw)
    return FALLBACK_CONTEXT_MENU;
  return {
    copyBlockReference: String((_c2 = raw.copyBlockReference) != null ? _c2 : FALLBACK_CONTEXT_MENU.copyBlockReference),
    copyBlockEmbed: String((_d2 = raw.copyBlockEmbed) != null ? _d2 : FALLBACK_CONTEXT_MENU.copyBlockEmbed),
    copyBlockUrl: String((_e2 = raw.copyBlockUrl) != null ? _e2 : FALLBACK_CONTEXT_MENU.copyBlockUrl),
    convertToTask: String((_f2 = raw.convertToTask) != null ? _f2 : FALLBACK_CONTEXT_MENU.convertToTask),
    convertToNormalBlock: String((_g = raw.convertToNormalBlock) != null ? _g : FALLBACK_CONTEXT_MENU.convertToNormalBlock),
    copy: String((_h = raw.copy) != null ? _h : FALLBACK_CONTEXT_MENU.copy),
    cut: String((_i = raw.cut) != null ? _i : FALLBACK_CONTEXT_MENU.cut),
    paste: String((_j = raw.paste) != null ? _j : FALLBACK_CONTEXT_MENU.paste),
    pasteAsText: String((_k = raw.pasteAsText) != null ? _k : FALLBACK_CONTEXT_MENU.pasteAsText),
    delete: String((_l = raw.delete) != null ? _l : FALLBACK_CONTEXT_MENU.delete),
    collapse: String((_m = raw.collapse) != null ? _m : FALLBACK_CONTEXT_MENU.collapse),
    expand: String((_n = raw.expand) != null ? _n : FALLBACK_CONTEXT_MENU.expand)
  };
}

// src/features/file-outliner-view/scope-manager.ts
var import_obsidian9 = require("obsidian");
var FILE_OUTLINER_FRONTMATTER_KEY = "blp_outliner";
function normalizeFileOutlinerScopePath(input) {
  return (0, import_obsidian9.normalizePath)(input.trim()).replace(/^\/+/, "").replace(/\/+$/, "");
}
function isPathInFileOutlinerScopeFolder(path, folder) {
  const normalizedFolder = normalizeFileOutlinerScopePath(folder);
  if (!normalizedFolder)
    return true;
  return path === normalizedFolder || path.startsWith(normalizedFolder + "/");
}
function parseFrontmatterBool(raw) {
  const enabled = raw === true || raw === "true" || raw === 1;
  const disabled = raw === false || raw === "false" || raw === 0;
  return enabled ? true : disabled ? false : null;
}
function getFrontmatterStateFromObject(fm) {
  if (!fm)
    return null;
  const has = (k) => Object.prototype.hasOwnProperty.call(fm, k);
  if (has(FILE_OUTLINER_FRONTMATTER_KEY)) {
    return parseFrontmatterBool(fm[FILE_OUTLINER_FRONTMATTER_KEY]);
  }
  return null;
}
var FileOutlinerScopeManager = class {
  constructor(plugin) {
    this.scopeVersion = 0;
    this.listeners = /* @__PURE__ */ new Set();
    this.notifyScheduled = false;
    this.normalizedEnabledFiles = /* @__PURE__ */ new Set();
    this.normalizedEnabledFolders = [];
    this.normalizedSettingsVersion = -1;
    this.enabledByPath = /* @__PURE__ */ new Map();
    this.maxEnabledCacheEntries = 2e3;
    this.enabledMarkdownFilesCache = null;
    this.frontmatterOptInByPath = /* @__PURE__ */ new Map();
    this.maxFrontmatterCacheEntries = 2e3;
    this.plugin = plugin;
    this.registerObsidianListeners();
  }
  getVersion() {
    return this.scopeVersion;
  }
  onChange(cb) {
    this.listeners.add(cb);
    return () => this.listeners.delete(cb);
  }
  onSettingsChanged() {
    this.bumpScopeVersion({ clearAll: true });
  }
  isEnabledFile(file) {
    var _a2, _b2;
    if (file.extension && file.extension.toLowerCase() !== "md")
      return false;
    const filePath = (0, import_obsidian9.normalizePath)(file.path);
    const mtime = (_b2 = (_a2 = file.stat) == null ? void 0 : _a2.mtime) != null ? _b2 : 0;
    const cached = this.enabledByPath.get(filePath);
    if (cached && cached.mtime === mtime)
      return cached.enabled;
    this.ensureNormalizedSettings();
    const fmState = this.getFrontmatterState(file);
    if (fmState === false) {
      this.setEnabledCache(filePath, { enabled: false, mtime });
      return false;
    }
    if (fmState === true) {
      this.setEnabledCache(filePath, { enabled: true, mtime });
      return true;
    }
    if (this.normalizedEnabledFiles.has(filePath)) {
      this.setEnabledCache(filePath, { enabled: true, mtime });
      return true;
    }
    if (this.normalizedEnabledFolders.some((f2) => isPathInFileOutlinerScopeFolder(filePath, f2))) {
      this.setEnabledCache(filePath, { enabled: true, mtime });
      return true;
    }
    this.setEnabledCache(filePath, { enabled: false, mtime });
    return false;
  }
  getEnabledMarkdownFiles() {
    var _a2, _b2;
    if (((_a2 = this.enabledMarkdownFilesCache) == null ? void 0 : _a2.scopeVersion) === this.scopeVersion) {
      return { files: this.enabledMarkdownFilesCache.files, pathSet: this.enabledMarkdownFilesCache.pathSet };
    }
    const files = ((_b2 = this.plugin.app.vault.getFiles()) != null ? _b2 : []).filter(
      (f2) => {
        var _a3;
        return f2 instanceof import_obsidian9.TFile && ((_a3 = f2.extension) == null ? void 0 : _a3.toLowerCase()) === "md";
      }
    );
    const enabled = files.filter((f2) => this.isEnabledFile(f2));
    const pathSet = new Set(enabled.map((f2) => f2.path));
    this.enabledMarkdownFilesCache = { scopeVersion: this.scopeVersion, files: enabled, pathSet };
    return { files: enabled, pathSet };
  }
  /**
   * Invalidate a single path (rename/delete/metadata update).
   */
  invalidatePath(path) {
    const normalized = (0, import_obsidian9.normalizePath)(path);
    this.enabledByPath.delete(normalized);
    this.frontmatterOptInByPath.delete(normalized);
    this.enabledMarkdownFilesCache = null;
    this.bumpScopeVersion({ clearAll: false });
  }
  ensureNormalizedSettings() {
    var _a2, _b2;
    if (this.normalizedSettingsVersion === this.scopeVersion)
      return;
    const enabledFiles = ((_a2 = this.plugin.settings.fileOutlinerEnabledFiles) != null ? _a2 : []).map((p) => (0, import_obsidian9.normalizePath)(String(p != null ? p : ""))).filter(Boolean);
    this.normalizedEnabledFiles = new Set(enabledFiles);
    this.normalizedEnabledFolders = ((_b2 = this.plugin.settings.fileOutlinerEnabledFolders) != null ? _b2 : []).map(
      (p) => normalizeFileOutlinerScopePath(String(p != null ? p : ""))
    );
    this.normalizedSettingsVersion = this.scopeVersion;
  }
  getFrontmatterState(file) {
    const filePath = (0, import_obsidian9.normalizePath)(file.path);
    const cached = this.frontmatterOptInByPath.get(filePath);
    if (cached !== void 0)
      return cached;
    const cache = this.plugin.app.metadataCache.getFileCache(file);
    const fm = cache == null ? void 0 : cache.frontmatter;
    const state = getFrontmatterStateFromObject(fm);
    this.frontmatterOptInByPath.set(filePath, state);
    this.evictFrontmatterOptInIfNeeded();
    return state;
  }
  registerObsidianListeners() {
    var _a2, _b2;
    const pluginAny = this.plugin;
    if (!pluginAny || typeof pluginAny.registerEvent !== "function")
      return;
    const registerEvent = (ref) => pluginAny.registerEvent(ref);
    const vault = (_a2 = this.plugin.app) == null ? void 0 : _a2.vault;
    if (vault && typeof vault.on === "function") {
      registerEvent(
        vault.on("rename", (file, oldPath) => {
          var _a3;
          if (!(file instanceof import_obsidian9.TFile))
            return;
          const prev = (0, import_obsidian9.normalizePath)(String(oldPath != null ? oldPath : ""));
          const next = (0, import_obsidian9.normalizePath)(String((_a3 = file.path) != null ? _a3 : ""));
          if (prev && next && prev !== next) {
            const entry = this.enabledByPath.get(prev);
            if (entry) {
              this.enabledByPath.delete(prev);
              this.enabledByPath.set(next, entry);
            }
            const fm = this.frontmatterOptInByPath.get(prev);
            if (fm !== void 0) {
              this.frontmatterOptInByPath.delete(prev);
              this.frontmatterOptInByPath.set(next, fm);
            }
          }
          this.enabledMarkdownFilesCache = null;
          this.bumpScopeVersion({ clearAll: false });
        })
      );
      registerEvent(
        vault.on("delete", (file) => {
          var _a3, _b3;
          if (!(file instanceof import_obsidian9.TFile))
            return;
          this.enabledByPath.delete((0, import_obsidian9.normalizePath)(String((_a3 = file.path) != null ? _a3 : "")));
          this.frontmatterOptInByPath.delete((0, import_obsidian9.normalizePath)(String((_b3 = file.path) != null ? _b3 : "")));
          this.enabledMarkdownFilesCache = null;
          this.bumpScopeVersion({ clearAll: false });
        })
      );
      registerEvent(
        vault.on("create", (file) => {
          var _a3;
          if (!(file instanceof import_obsidian9.TFile))
            return;
          if (((_a3 = file.extension) == null ? void 0 : _a3.toLowerCase()) !== "md")
            return;
          this.enabledMarkdownFilesCache = null;
          this.bumpScopeVersion({ clearAll: false });
        })
      );
    }
    const metadata = (_b2 = this.plugin.app) == null ? void 0 : _b2.metadataCache;
    if (metadata && typeof metadata.on === "function") {
      registerEvent(
        metadata.on("changed", (file, _data, cache) => {
          var _a3;
          if (!(file instanceof import_obsidian9.TFile))
            return;
          const path = (0, import_obsidian9.normalizePath)(String((_a3 = file.path) != null ? _a3 : ""));
          this.enabledByPath.delete(path);
          this.enabledMarkdownFilesCache = null;
          const fm = cache == null ? void 0 : cache.frontmatter;
          const hasRelevantKey = Boolean(
            fm && Object.prototype.hasOwnProperty.call(fm, FILE_OUTLINER_FRONTMATTER_KEY)
          );
          const prevState = this.frontmatterOptInByPath.get(path);
          if (!hasRelevantKey && prevState === void 0)
            return;
          const nextState = getFrontmatterStateFromObject(fm);
          if (prevState !== nextState) {
            this.frontmatterOptInByPath.set(path, nextState);
            this.evictFrontmatterOptInIfNeeded();
            this.bumpScopeVersion({ clearAll: false });
          } else {
            this.frontmatterOptInByPath.set(path, nextState);
            this.evictFrontmatterOptInIfNeeded();
          }
        })
      );
    }
  }
  bumpScopeVersion(opts) {
    this.scopeVersion++;
    this.enabledMarkdownFilesCache = null;
    this.normalizedSettingsVersion = -1;
    if (opts.clearAll) {
      this.enabledByPath.clear();
    }
    this.scheduleNotify();
  }
  scheduleNotify() {
    if (this.notifyScheduled)
      return;
    this.notifyScheduled = true;
    const run = () => {
      this.notifyScheduled = false;
      for (const cb of [...this.listeners]) {
        try {
          cb();
        } catch (e) {
        }
      }
    };
    if (typeof queueMicrotask === "function") {
      queueMicrotask(run);
    } else if (typeof setTimeout === "function") {
      setTimeout(run, 0);
    } else {
      run();
    }
  }
  setEnabledCache(path, entry) {
    this.enabledByPath.set(path, entry);
    if (this.enabledByPath.size > this.maxEnabledCacheEntries) {
      const toDelete = this.enabledByPath.size - this.maxEnabledCacheEntries;
      const it = this.enabledByPath.keys();
      for (let i = 0; i < toDelete; i++) {
        const k = it.next().value;
        if (typeof k === "string")
          this.enabledByPath.delete(k);
      }
    }
  }
  evictFrontmatterOptInIfNeeded() {
    if (this.frontmatterOptInByPath.size <= this.maxFrontmatterCacheEntries)
      return;
    const toDelete = this.frontmatterOptInByPath.size - this.maxFrontmatterCacheEntries;
    const it = this.frontmatterOptInByPath.keys();
    for (let i = 0; i < toDelete; i++) {
      const k = it.next().value;
      if (typeof k === "string")
        this.frontmatterOptInByPath.delete(k);
    }
  }
};

// src/ui/file-outliner-settings-utils.ts
function dedupeKeepOrder(items) {
  const seen = /* @__PURE__ */ new Set();
  const out = [];
  for (const item of items) {
    if (seen.has(item))
      continue;
    seen.add(item);
    out.push(item);
  }
  return out;
}
function normalizePluginId(raw) {
  return String(raw != null ? raw : "").trim().toLowerCase();
}

// src/ui/settings-tabs.ts
var BLP_VISUALLY_HIDDEN_CLASS = "blp-visually-hidden";
function hideEl(el) {
  if (!el)
    return;
  el.classList.add(BLP_VISUALLY_HIDDEN_CLASS);
}
function unhideEl(el) {
  if (!el)
    return;
  el.classList.remove(BLP_VISUALLY_HIDDEN_CLASS);
}
var SettingsTabPane = class {
  constructor(options) {
    this.searchItems = [];
    this.name = options.name;
    this.navButton = document.createElement("button");
    this.navButton.type = "button";
    this.navButton.className = "blp-settings-nav-item";
    this.navButton.textContent = options.label;
    options.navEl.appendChild(this.navButton);
    this.contentEl = document.createElement("div");
    this.contentEl.className = "blp-settings-tab-content";
    this.contentEl.dataset.blpTab = options.name;
    options.contentRootEl.appendChild(this.contentEl);
    this.headingEl = document.createElement("div");
    this.headingEl.className = "blp-settings-tab-heading";
    this.headingEl.textContent = options.label;
    this.contentEl.appendChild(this.headingEl);
    hideEl(this.headingEl);
  }
  addSearchItem(containerEl, parts) {
    const haystack = parts.filter(Boolean).join(" ").toLowerCase();
    this.searchItems.push({ containerEl, haystack });
  }
  setSelected(isSelected) {
    if (isSelected) {
      this.navButton.classList.add("blp-settings-nav-item-selected");
      unhideEl(this.contentEl);
    } else {
      this.navButton.classList.remove("blp-settings-nav-item-selected");
      hideEl(this.contentEl);
    }
  }
  enterSearchMode() {
    unhideEl(this.contentEl);
    unhideEl(this.headingEl);
    for (const item of this.searchItems) {
      unhideEl(item.containerEl);
    }
  }
  leaveSearchMode(isSelected) {
    hideEl(this.headingEl);
    for (const item of this.searchItems) {
      unhideEl(item.containerEl);
    }
    this.setSelected(isSelected);
  }
};
var SettingsTabsController = class {
  constructor(options) {
    this.options = options;
    this.tabs = /* @__PURE__ */ new Map();
    this.inSearchMode = false;
  }
  addTab(tab) {
    this.tabs.set(tab.name, tab);
  }
  isSearchMode() {
    return this.inSearchMode;
  }
  getTab(name) {
    var _a2;
    return (_a2 = this.tabs.get(name)) != null ? _a2 : null;
  }
  init(initialTab) {
    this.selectedTab = initialTab;
    for (const [name, tab] of this.tabs) {
      tab.setSelected(name === initialTab);
    }
    hideEl(this.options.zeroStateEl);
  }
  enterSearchMode() {
    if (this.inSearchMode)
      return;
    this.inSearchMode = true;
    for (const tab of this.tabs.values()) {
      tab.enterSearchMode();
    }
  }
  leaveSearchMode(nextSelectedTab) {
    this.inSearchMode = false;
    this.selectedTab = nextSelectedTab;
    for (const [name, tab] of this.tabs) {
      tab.leaveSearchMode(name === nextSelectedTab);
    }
    hideEl(this.options.zeroStateEl);
  }
  selectTab(name) {
    if (this.inSearchMode) {
      this.leaveSearchMode(name);
      return;
    }
    if (this.selectedTab === name)
      return;
    const next = this.tabs.get(name);
    const prev = this.tabs.get(this.selectedTab);
    prev == null ? void 0 : prev.setSelected(false);
    next == null ? void 0 : next.setSelected(true);
    this.selectedTab = name;
  }
  applySearch(rawQuery) {
    const query = rawQuery.trim().toLowerCase();
    if (query === "") {
      if (this.inSearchMode)
        this.leaveSearchMode(this.selectedTab);
      return;
    }
    const tabsWithResults = /* @__PURE__ */ new Set();
    for (const [tabName, tab] of this.tabs) {
      let hasAny = false;
      for (const item of tab.searchItems) {
        const matches = query === "" || item.haystack.includes(query);
        if (matches) {
          unhideEl(item.containerEl);
          hasAny = true;
        } else {
          hideEl(item.containerEl);
        }
      }
      if (hasAny) {
        tabsWithResults.add(tabName);
        unhideEl(tab.contentEl);
      } else {
        hideEl(tab.contentEl);
      }
    }
    for (const [tabName, tab] of this.tabs) {
      if (tabsWithResults.has(tabName)) {
        unhideEl(tab.headingEl);
      } else {
        hideEl(tab.headingEl);
      }
    }
    if (tabsWithResults.size === 0) {
      unhideEl(this.options.zeroStateEl);
    } else {
      hideEl(this.options.zeroStateEl);
    }
  }
};

// src/ui/SettingsTab.ts
var BlockLinkPlusSettingsTab = class extends import_obsidian10.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.selectedTabName = "basics";
    this.searchQuery = "";
    this.plugin = plugin;
  }
  addToggleSetting(settingName, extraOnChange, containerEl) {
    const rootEl = containerEl != null ? containerEl : this.containerEl;
    return new import_obsidian10.Setting(rootEl).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings[settingName]).onChange(async (value) => {
        this.plugin.settings[settingName] = value;
        await this.plugin.saveSettings();
        extraOnChange == null ? void 0 : extraOnChange(value);
      });
    });
  }
  // Text input
  addTextInputSetting(settingName, placeholder, containerEl) {
    const rootEl = containerEl != null ? containerEl : this.containerEl;
    return new import_obsidian10.Setting(rootEl).addText(
      (text) => text.setPlaceholder(placeholder).setValue(this.plugin.settings[settingName]).onChange(async (value) => {
        if (value.length > 0) {
          this.plugin.settings[settingName] = value;
          await this.plugin.saveSettings();
        }
      })
    );
  }
  addDropdownSetting(settingName, options, display, containerEl) {
    const rootEl = containerEl != null ? containerEl : this.containerEl;
    return new import_obsidian10.Setting(rootEl).addDropdown((dropdown) => {
      var _a2;
      const displayNames = /* @__PURE__ */ new Set();
      for (const option of options) {
        const displayName = (_a2 = display == null ? void 0 : display(option)) != null ? _a2 : option;
        if (!displayNames.has(displayName)) {
          dropdown.addOption(option, displayName);
          displayNames.add(displayName);
        }
      }
      dropdown.setValue(this.plugin.settings[settingName]).onChange(async (value) => {
        this.plugin.settings[settingName] = value;
        await this.plugin.saveSettings();
      });
    });
  }
  addSliderSetting(settingName, min, max, step, containerEl) {
    const rootEl = containerEl != null ? containerEl : this.containerEl;
    return new import_obsidian10.Setting(rootEl).addSlider((slider) => {
      slider.setLimits(min, max, step).setValue(this.plugin.settings[settingName]).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings[settingName] = value;
        await this.plugin.saveSettings();
      });
    });
  }
  addHeading(heading, containerEl) {
    const rootEl = containerEl != null ? containerEl : this.containerEl;
    return new import_obsidian10.Setting(rootEl).setName(heading).setHeading();
  }
  renderStringListEditor(rootEl, opts) {
    var _a2, _b2;
    const labels = getFileOutlinerListEditorLabels();
    const normalize = (_a2 = opts.normalizeItem) != null ? _a2 : (s2) => String(s2 != null ? s2 : "").trim();
    let draft = ((_b2 = opts.getValue()) != null ? _b2 : []).map((s2) => String(s2 != null ? s2 : "")).filter(Boolean);
    const persist = async () => {
      const next = dedupeKeepOrder(draft.map(normalize).filter(Boolean));
      await opts.setValue(next);
    };
    const listRoot = rootEl.createDiv({ cls: "blp-settings-list" });
    new import_obsidian10.Setting(listRoot).setName(opts.name).setDesc(opts.desc);
    const rowsEl = listRoot.createDiv({ cls: "blp-settings-list-rows" });
    const render = () => {
      var _a3;
      rowsEl.empty();
      const isDisabled = Boolean((_a3 = opts.disabled) == null ? void 0 : _a3.call(opts));
      draft.forEach((value, idx) => {
        const row = new import_obsidian10.Setting(rowsEl).setName(opts.name).setClass("blp-settings-list-row");
        row.infoEl.style.display = "none";
        let inputEl = null;
        row.addSearch((search) => {
          search.setPlaceholder(opts.placeholder).setValue(String(value != null ? value : "")).setDisabled(isDisabled).onChange(async (raw) => {
            draft[idx] = String(raw != null ? raw : "");
            if (!normalize(raw))
              return;
            await persist();
          });
          inputEl = search.inputEl;
          if (inputEl && opts.attachSuggest)
            opts.attachSuggest(inputEl);
        });
        row.addExtraButton((btn) => {
          btn.setIcon("chevron-up").setTooltip(labels.moveUp).setDisabled(isDisabled || idx === 0).onClick(async () => {
            if (idx === 0)
              return;
            [draft[idx - 1], draft[idx]] = [draft[idx], draft[idx - 1]];
            await persist();
            render();
          });
        });
        row.addExtraButton((btn) => {
          btn.setIcon("chevron-down").setTooltip(labels.moveDown).setDisabled(isDisabled || idx === draft.length - 1).onClick(async () => {
            if (idx >= draft.length - 1)
              return;
            [draft[idx], draft[idx + 1]] = [draft[idx + 1], draft[idx]];
            await persist();
            render();
          });
        });
        row.addExtraButton((btn) => {
          btn.setIcon("x").setTooltip(labels.remove).setDisabled(isDisabled).onClick(async () => {
            draft.splice(idx, 1);
            await persist();
            render();
          });
        });
        row.settingEl.addEventListener("click", (evt) => {
          if (!(evt.target instanceof HTMLElement))
            return;
          if (evt.target.closest("button, input"))
            return;
          inputEl == null ? void 0 : inputEl.focus();
        });
      });
    };
    render();
    new import_obsidian10.Setting(listRoot).setName(opts.name).setClass("blp-settings-list-add-row").addButton((btn) => {
      var _a3;
      btn.setButtonText(opts.addButtonText).setCta().setDisabled(Boolean((_a3 = opts.disabled) == null ? void 0 : _a3.call(opts))).onClick(() => {
        var _a4;
        draft.push("");
        render();
        const inputs = rowsEl.querySelectorAll(".setting-item-control input");
        (_a4 = inputs[inputs.length - 1]) == null ? void 0 : _a4.focus();
      });
    });
  }
  display() {
    const { containerEl } = this;
    const uiText = this.getSettingsUiText();
    containerEl.empty();
    const titleEl = containerEl.createDiv({ cls: "blp-settings-title" });
    titleEl.createEl("h2", { text: i18n_default.settings.pluginTitle });
    const searchContainerEl = titleEl.createDiv({ cls: "search-input-container" });
    const searchInputEl = searchContainerEl.createEl("input", {
      type: "search",
      placeholder: uiText.searchPlaceholder
    });
    searchInputEl.classList.add("search-input");
    const headerEl = containerEl.createDiv({ cls: "blp-settings-header" });
    const navEl = headerEl.createDiv({ cls: "blp-settings-tab-group" });
    const contentRootEl = containerEl.createDiv();
    const zeroStateEl = containerEl.createDiv({ cls: "blp-settings-zero-state" });
    zeroStateEl.textContent = uiText.emptyState;
    const controller = new SettingsTabsController({ zeroStateEl });
    const tabs = {
      basics: new SettingsTabPane({ navEl, contentRootEl, name: "basics", label: uiText.tabs.basics }),
      outliner: new SettingsTabPane({ navEl, contentRootEl, name: "outliner", label: uiText.tabs.outliner })
    };
    const allTabs = Object.values(tabs);
    for (const tab of allTabs)
      controller.addTab(tab);
    if (!controller.getTab(this.selectedTabName)) {
      this.selectedTabName = "basics";
    }
    controller.init(this.selectedTabName);
    this.renderBasicsTab(tabs.basics.contentEl);
    this.renderFileOutlinerTab(tabs.outliner.contentEl);
    for (const tab of allTabs)
      this.buildSearchIndex(tab);
    const syncSectionHeadings = () => {
      for (const tab of allTabs)
        this.syncSettingSectionHeadings(tab);
    };
    const applySearch = () => {
      controller.enterSearchMode();
      controller.applySearch(searchInputEl.value);
      syncSectionHeadings();
    };
    for (const tab of allTabs) {
      tab.navButton.addEventListener("click", () => {
        if (controller.isSearchMode()) {
          searchInputEl.value = "";
          this.searchQuery = "";
        }
        this.selectedTabName = tab.name;
        controller.selectTab(tab.name);
      });
    }
    searchInputEl.value = this.searchQuery;
    searchInputEl.addEventListener("focus", () => {
      this.searchQuery = searchInputEl.value;
      applySearch();
    });
    searchInputEl.addEventListener("input", () => {
      this.searchQuery = searchInputEl.value;
      applySearch();
    });
    searchInputEl.addEventListener("keydown", (evt) => {
      if (evt.key !== "Escape")
        return;
      searchInputEl.value = "";
      this.searchQuery = "";
      if (controller.isSearchMode())
        controller.leaveSearchMode(this.selectedTabName);
    });
    if (this.searchQuery.trim())
      applySearch();
  }
  getSettingsUiText() {
    switch (i18n_default.lang) {
      case "zh":
        return {
          searchPlaceholder: "\u641C\u7D22\u8BBE\u7F6E...",
          emptyState: "\u6CA1\u6709\u5339\u914D\u7684\u8BBE\u7F6E\u3002",
          tabs: {
            basics: "\u57FA\u7840",
            outliner: "Outliner"
          }
        };
      case "zh-TW":
        return {
          searchPlaceholder: "\u641C\u5C0B\u8A2D\u5B9A...",
          emptyState: "\u6C92\u6709\u5339\u914D\u7684\u8A2D\u5B9A\u3002",
          tabs: {
            basics: "\u57FA\u790E",
            outliner: "Outliner"
          }
        };
      default:
        return {
          searchPlaceholder: "Search settings...",
          emptyState: "No matching settings.",
          tabs: {
            basics: "Basics",
            outliner: "Outliner"
          }
        };
    }
  }
  buildSearchIndex(tab) {
    var _a2, _b2, _c2, _d2, _e2;
    const tabLabel = (_a2 = tab.headingEl.textContent) != null ? _a2 : "";
    const items = Array.from(tab.contentEl.querySelectorAll(".setting-item"));
    let currentSection = "";
    for (const item of items) {
      const name = (_c2 = (_b2 = item.querySelector(".setting-item-name")) == null ? void 0 : _b2.textContent) != null ? _c2 : "";
      const desc = (_e2 = (_d2 = item.querySelector(".setting-item-description")) == null ? void 0 : _d2.textContent) != null ? _e2 : "";
      if (item.classList.contains("setting-item-heading")) {
        currentSection = `${name} ${desc}`.trim();
      }
      tab.addSearchItem(item, [tabLabel, currentSection, name, desc]);
    }
  }
  syncSettingSectionHeadings(tab) {
    const items = Array.from(tab.contentEl.querySelectorAll(".setting-item"));
    let currentHeading = null;
    let hasVisibleChild = false;
    const flush = () => {
      if (!currentHeading)
        return;
      if (hasVisibleChild)
        unhideEl(currentHeading);
      else
        hideEl(currentHeading);
    };
    for (const item of items) {
      if (item.classList.contains("setting-item-heading")) {
        flush();
        currentHeading = item;
        hasVisibleChild = false;
        continue;
      }
      if (currentHeading && !item.classList.contains(BLP_VISUALLY_HIDDEN_CLASS)) {
        hasVisibleChild = true;
      }
    }
    flush();
  }
  renderBasicsTab(rootEl) {
    const multiLineHandleSetting = new import_obsidian10.Setting(rootEl).setName(i18n_default.settings.multiLineHandle.name).setDesc(i18n_default.settings.multiLineHandle.desc);
    const getMultiLineDescription = (value) => {
      switch (parseInt(value)) {
        case 0 /* oneline */:
          return i18n_default.settings.multiLineHandle.descriptions.default;
        case 1 /* heading */:
          return i18n_default.settings.multiLineHandle.descriptions.addHeading;
        case 2 /* multblock */:
          return i18n_default.settings.multiLineHandle.descriptions.addMultiBlock;
        case 3 /* multilineblock */:
          return i18n_default.settings.multiLineHandle.descriptions.addMultilineBlock;
        default:
          return i18n_default.settings.multiLineHandle.desc;
      }
    };
    multiLineHandleSetting.addDropdown((dropdown) => {
      const options = [
        { value: 0 /* oneline */.toString(), display: i18n_default.settings.multiLineHandle.options.default },
        { value: 1 /* heading */.toString(), display: i18n_default.settings.multiLineHandle.options.addHeading },
        { value: 2 /* multblock */.toString(), display: i18n_default.settings.multiLineHandle.options.addMultiBlock },
        {
          value: 3 /* multilineblock */.toString(),
          display: i18n_default.settings.multiLineHandle.options.addMultilineBlock
        }
      ];
      options.forEach((option) => {
        dropdown.addOption(option.value, option.display);
      });
      dropdown.setValue(this.plugin.settings.mult_line_handle.toString()).onChange(async (value) => {
        this.plugin.settings.mult_line_handle = parseInt(value);
        await this.plugin.saveSettings();
        const descEl = multiLineHandleSetting.descEl;
        if (descEl)
          descEl.textContent = getMultiLineDescription(value);
      });
    });
    const initialDescription = getMultiLineDescription(this.plugin.settings.mult_line_handle.toString());
    if (multiLineHandleSetting.descEl)
      multiLineHandleSetting.descEl.textContent = initialDescription;
    this.addHeading(i18n_default.settings.blockLink.title, rootEl).setDesc(i18n_default.settings.blockLink.desc);
    this.addToggleSetting("enable_right_click_block", void 0, rootEl).setName(i18n_default.settings.blockLink.enableRightClick.name);
    this.addToggleSetting("enable_block_notification", void 0, rootEl).setName(i18n_default.settings.blockLink.enableNotification.name);
    const aliasStyleSetting = new import_obsidian10.Setting(rootEl).setName(i18n_default.settings.blockLink.aliasStyle.name).setDesc(i18n_default.settings.blockLink.aliasStyle.desc);
    const getAliasStyleDescription = (value) => {
      switch (parseInt(value)) {
        case 0 /* Default */:
          return i18n_default.settings.blockLink.aliasStyle.descriptions.noAlias;
        case 1 /* FirstChars */:
          return i18n_default.settings.blockLink.aliasStyle.descriptions.firstChars;
        case 2 /* Heading */:
          return i18n_default.settings.blockLink.aliasStyle.descriptions.parentHeading;
        case 3 /* SelectedText */:
          return i18n_default.settings.blockLink.aliasStyle.descriptions.selectedText;
        default:
          return i18n_default.settings.blockLink.aliasStyle.desc;
      }
    };
    aliasStyleSetting.addDropdown((dropdown) => {
      const options = [
        { value: 0 /* Default */.toString(), display: i18n_default.settings.blockLink.aliasStyle.options.noAlias },
        { value: 1 /* FirstChars */.toString(), display: i18n_default.settings.blockLink.aliasStyle.options.firstChars },
        { value: 2 /* Heading */.toString(), display: i18n_default.settings.blockLink.aliasStyle.options.parentHeading },
        { value: 3 /* SelectedText */.toString(), display: i18n_default.settings.blockLink.aliasStyle.options.selectedText }
      ];
      options.forEach((option) => {
        dropdown.addOption(option.value, option.display);
      });
      dropdown.setValue(this.plugin.settings.alias_type.toString()).onChange(async (value) => {
        this.plugin.settings.alias_type = parseInt(value);
        await this.plugin.saveSettings();
        const descEl = aliasStyleSetting.descEl;
        if (descEl)
          descEl.textContent = getAliasStyleDescription(value);
      });
    });
    const initialAliasDescription = getAliasStyleDescription(this.plugin.settings.alias_type.toString());
    if (aliasStyleSetting.descEl)
      aliasStyleSetting.descEl.textContent = initialAliasDescription;
    this.addSliderSetting("alias_length", 1, 100, 1, rootEl).setName(i18n_default.settings.blockLink.aliasLength.name).setDesc(i18n_default.settings.blockLink.aliasLength.desc);
    this.addToggleSetting("heading_id_newline", void 0, rootEl).setName(i18n_default.settings.blockLink.headingIdNewline.name).setDesc(i18n_default.settings.blockLink.headingIdNewline.desc);
    this.addHeading(i18n_default.settings.embedLink.title, rootEl).setDesc(i18n_default.settings.embedLink.desc);
    this.addToggleSetting("enable_right_click_embed", void 0, rootEl).setName(i18n_default.settings.embedLink.enableRightClick.name);
    this.addToggleSetting("enable_embed_notification", void 0, rootEl).setName(i18n_default.settings.embedLink.enableNotification.name);
    this.addHeading(i18n_default.settings.obsidianUri.title, rootEl).setDesc(i18n_default.settings.obsidianUri.desc);
    this.addToggleSetting("enable_right_click_url", void 0, rootEl).setName(i18n_default.settings.obsidianUri.enableRightClick.name);
    this.addToggleSetting("enable_url_notification", void 0, rootEl).setName(i18n_default.settings.obsidianUri.enableNotification.name);
    this.addHeading(i18n_default.settings.blockId.title, rootEl).setDesc(i18n_default.settings.blockId.desc);
    this.addSliderSetting("id_length", 3, 7, 1, rootEl).setName(i18n_default.settings.blockId.maxLength.name).setDesc(i18n_default.settings.blockId.maxLength.desc);
    this.addToggleSetting("enable_prefix", void 0, rootEl).setName(i18n_default.settings.blockId.enablePrefix.name);
    this.addTextInputSetting("id_prefix", "", rootEl).setName(i18n_default.settings.blockId.prefix.name).setDesc(i18n_default.settings.blockId.prefix.desc);
    this.addHeading(i18n_default.settings.inlineEdit.title, rootEl).setDesc(i18n_default.settings.inlineEdit.desc);
    this.addToggleSetting("inlineEditEnabled", void 0, rootEl).setName(i18n_default.settings.inlineEdit.enable.name).setDesc(i18n_default.settings.inlineEdit.enable.desc);
    this.addToggleSetting("inlineEditFile", void 0, rootEl).setName(i18n_default.settings.inlineEdit.file.name).setDesc(i18n_default.settings.inlineEdit.file.desc);
    this.addToggleSetting("inlineEditHeading", void 0, rootEl).setName(i18n_default.settings.inlineEdit.heading.name).setDesc(i18n_default.settings.inlineEdit.heading.desc);
    this.addToggleSetting("inlineEditBlock", void 0, rootEl).setName(i18n_default.settings.inlineEdit.block.name).setDesc(i18n_default.settings.inlineEdit.block.desc);
  }
  renderFileOutlinerTab(rootEl) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
    const ui = i18n_default.settings.fileOutliner;
    this.addHeading(ui.title, rootEl).setDesc(ui.desc);
    const master = this.addToggleSetting("fileOutlinerViewEnabled", () => this.display(), rootEl).setName(ui.enableRouting.name).setDesc(ui.enableRouting.desc);
    master.settingEl.classList.add("blp-settings-master-toggle");
    if (this.plugin.settings.fileOutlinerViewEnabled === false)
      return;
    this.addHeading(ui.groups.scope.title, rootEl);
    this.renderStringListEditor(rootEl, {
      name: ui.enabledFolders.name,
      desc: ui.enabledFolders.desc,
      addButtonText: (_a2 = ui.enabledFolders.addButton) != null ? _a2 : "Add enabled folder",
      placeholder: (_b2 = ui.enabledFolders.placeholder) != null ? _b2 : "Daily",
      getValue: () => {
        var _a3;
        return (_a3 = this.plugin.settings.fileOutlinerEnabledFolders) != null ? _a3 : [];
      },
      setValue: async (next) => {
        this.plugin.settings.fileOutlinerEnabledFolders = next;
        await this.plugin.saveSettings();
      },
      normalizeItem: normalizeFileOutlinerScopePath,
      attachSuggest: (inputEl) => void new VaultFolderSuggest(this.app, inputEl)
    });
    this.renderStringListEditor(rootEl, {
      name: ui.enabledFiles.name,
      desc: ui.enabledFiles.desc,
      addButtonText: (_c2 = ui.enabledFiles.addButton) != null ? _c2 : "Add enabled file",
      placeholder: (_d2 = ui.enabledFiles.placeholder) != null ? _d2 : "Daily/2026-01-09.md",
      getValue: () => {
        var _a3;
        return (_a3 = this.plugin.settings.fileOutlinerEnabledFiles) != null ? _a3 : [];
      },
      setValue: async (next) => {
        this.plugin.settings.fileOutlinerEnabledFiles = next;
        await this.plugin.saveSettings();
      },
      normalizeItem: normalizeFileOutlinerScopePath,
      attachSuggest: (inputEl) => void new VaultFileSuggest(this.app, inputEl)
    });
    new import_obsidian10.Setting(rootEl).setName(ui.frontmatterOverride.name).setDesc(ui.frontmatterOverride.desc);
    this.addHeading((_f2 = (_e2 = ui.groups.display) == null ? void 0 : _e2.title) != null ? _f2 : "Display", rootEl);
    this.addToggleSetting("fileOutlinerHideSystemLine", void 0, rootEl).setName(ui.hideSystemTailLines.name).setDesc(ui.hideSystemTailLines.desc);
    this.addToggleSetting("fileOutlinerEmphasisLineEnabled", void 0, rootEl).setName(ui.emphasisLine.name).setDesc(ui.emphasisLine.desc);
    this.addToggleSetting("fileOutlinerDragAndDropEnabled", void 0, rootEl).setName(ui.dragAndDrop.name).setDesc(ui.dragAndDrop.desc);
    this.addToggleSetting("fileOutlinerZoomEnabled", void 0, rootEl).setName(ui.zoom.name).setDesc(ui.zoom.desc);
    this.addHeading((_h = (_g = ui.groups.editing) == null ? void 0 : _g.title) != null ? _h : "Editing", rootEl);
    new import_obsidian10.Setting(rootEl).setName(ui.childrenOnSplit.name).setDesc(ui.childrenOnSplit.desc).addDropdown((dropdown) => {
      var _a3;
      dropdown.addOption("keep", ui.childrenOnSplit.options.keep).addOption("move", ui.childrenOnSplit.options.move).setValue((_a3 = this.plugin.settings.fileOutlinerChildrenOnSplit) != null ? _a3 : "keep").setDisabled(!this.plugin.settings.fileOutlinerViewEnabled).onChange(async (value) => {
        this.plugin.settings.fileOutlinerChildrenOnSplit = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian10.Setting(rootEl).setName(ui.pasteMultiline.name).setDesc(ui.pasteMultiline.desc).addDropdown((dropdown) => {
      var _a3;
      dropdown.addOption("split", ui.pasteMultiline.options.split).addOption("multiline", ui.pasteMultiline.options.multiline).setValue((_a3 = this.plugin.settings.fileOutlinerPasteMultiline) != null ? _a3 : "split").setDisabled(!this.plugin.settings.fileOutlinerViewEnabled).onChange(async (value) => {
        this.plugin.settings.fileOutlinerPasteMultiline = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian10.Setting(rootEl).setName(ui.backspaceWithChildren.name).setDesc(ui.backspaceWithChildren.desc).addDropdown((dropdown) => {
      var _a3;
      dropdown.addOption("merge", ui.backspaceWithChildren.options.merge).addOption("outdent", ui.backspaceWithChildren.options.outdent).setValue((_a3 = this.plugin.settings.fileOutlinerBackspaceWithChildren) != null ? _a3 : "merge").setDisabled(!this.plugin.settings.fileOutlinerViewEnabled).onChange(async (value) => {
        this.plugin.settings.fileOutlinerBackspaceWithChildren = value;
        await this.plugin.saveSettings();
      });
    });
    const cmdLabels = getFileOutlinerCommandLabels();
    const tasksHelpDesc = String((_i = ui.tasksHelp.desc) != null ? _i : "").replace("${toggleTaskStatus}", cmdLabels.toggleTaskStatus).replace("${toggleTaskMarker}", cmdLabels.toggleTaskMarker);
    new import_obsidian10.Setting(rootEl).setName(ui.tasksHelp.name).setDesc(tasksHelpDesc);
    this.addHeading((_k = (_j = ui.groups.integrations) == null ? void 0 : _j.title) != null ? _k : "Integrations", rootEl);
    this.addToggleSetting("fileOutlinerEditorContextMenuEnabled", () => this.display(), rootEl).setName(ui.editorContextMenu.enabled.name).setDesc(ui.editorContextMenu.enabled.desc);
    this.renderStringListEditor(rootEl, {
      name: ui.editorContextMenu.allowedPlugins.name,
      desc: ui.editorContextMenu.allowedPlugins.desc,
      addButtonText: (_l = ui.editorContextMenu.allowedPlugins.addButton) != null ? _l : "Add allowlisted plugin",
      placeholder: (_m = ui.editorContextMenu.allowedPlugins.placeholder) != null ? _m : "metadata-menu",
      getValue: () => {
        var _a3;
        return (_a3 = this.plugin.settings.fileOutlinerEditorContextMenuAllowedPlugins) != null ? _a3 : [];
      },
      setValue: async (next) => {
        this.plugin.settings.fileOutlinerEditorContextMenuAllowedPlugins = next;
        await this.plugin.saveSettings();
      },
      normalizeItem: normalizePluginId,
      attachSuggest: (inputEl) => void new InstalledPluginIdSuggest(this.app, inputEl),
      disabled: () => this.plugin.settings.fileOutlinerEditorContextMenuEnabled === false
    });
    this.addToggleSetting("fileOutlinerEditorCommandBridgeEnabled", () => this.display(), rootEl).setName(ui.editorCommands.enabled.name).setDesc(ui.editorCommands.enabled.desc);
    this.renderStringListEditor(rootEl, {
      name: ui.editorCommands.allowedPlugins.name,
      desc: ui.editorCommands.allowedPlugins.desc,
      addButtonText: (_n = ui.editorCommands.allowedPlugins.addButton) != null ? _n : "Add allowlisted plugin",
      placeholder: (_o = ui.editorCommands.allowedPlugins.placeholder) != null ? _o : "highlightr-plugin",
      getValue: () => {
        var _a3;
        return (_a3 = this.plugin.settings.fileOutlinerEditorCommandAllowedPlugins) != null ? _a3 : ["core"];
      },
      setValue: async (next) => {
        this.plugin.settings.fileOutlinerEditorCommandAllowedPlugins = next;
        await this.plugin.saveSettings();
      },
      normalizeItem: normalizePluginId,
      attachSuggest: (inputEl) => void new InstalledPluginIdSuggest(this.app, inputEl),
      disabled: () => this.plugin.settings.fileOutlinerEditorCommandBridgeEnabled === false
    });
    new import_obsidian10.Setting(rootEl).setName(ui.editorCommands.copyFromMenuAllowlist.name).setDesc(ui.editorCommands.copyFromMenuAllowlist.desc).addButton((btn) => {
      var _a3;
      btn.setButtonText((_a3 = ui.editorCommands.copyFromMenuAllowlist.buttonText) != null ? _a3 : "Copy from editor menu allowlist").setCta().setDisabled(this.plugin.settings.fileOutlinerEditorCommandBridgeEnabled === false).onClick(async () => {
        const raw = Array.isArray(this.plugin.settings.fileOutlinerEditorContextMenuAllowedPlugins) ? this.plugin.settings.fileOutlinerEditorContextMenuAllowedPlugins : [];
        this.plugin.settings.fileOutlinerEditorCommandAllowedPlugins = dedupeKeepOrder(
          raw.map(normalizePluginId).filter(Boolean)
        );
        await this.plugin.saveSettings();
        this.display();
      });
    });
    this.addHeading((_q = (_p = ui.groups.debug) == null ? void 0 : _p.title) != null ? _q : "Debug", rootEl);
    this.addToggleSetting("fileOutlinerDebugLogging", void 0, rootEl).setName(ui.debug.name).setDesc(ui.debug.desc);
    this.addHeading(i18n_default.settings.enhancedListBlocks.blpView.title, rootEl).setDesc(
      i18n_default.settings.enhancedListBlocks.blpView.desc
    );
    const dataviewStatus = detectDataviewStatus();
    const statusText = dataviewStatus.functioning ? i18n_default.settings.enhancedListBlocks.dataviewStatus.available.replace(
      "${version}",
      dataviewStatus.version || "unknown"
    ) : i18n_default.settings.enhancedListBlocks.dataviewStatus.unavailable;
    const statusSetting = new import_obsidian10.Setting(rootEl).setDesc(statusText);
    statusSetting.settingEl.classList.add("blp-settings-dataview-status");
    hideEl(statusSetting.nameEl);
    if (!dataviewStatus.functioning)
      statusSetting.descEl.classList.add("mod-warning");
    this.addToggleSetting("blpViewAllowMaterialize", void 0, rootEl).setName(i18n_default.settings.enhancedListBlocks.blpView.allowMaterialize.name).setDesc(i18n_default.settings.enhancedListBlocks.blpView.allowMaterialize.desc);
    new import_obsidian10.Setting(rootEl).setName(i18n_default.settings.enhancedListBlocks.blpView.maxSourceFiles.name).setDesc(i18n_default.settings.enhancedListBlocks.blpView.maxSourceFiles.desc).addText((text) => {
      var _a3;
      text.inputEl.type = "number";
      text.setPlaceholder("0").setValue(String((_a3 = this.plugin.settings.blpViewMaxSourceFiles) != null ? _a3 : 0)).onChange(async (value) => {
        const trimmed = value.trim();
        const next = trimmed ? Number.parseInt(trimmed, 10) : 0;
        if (!Number.isFinite(next) || next < 0)
          return;
        this.plugin.settings.blpViewMaxSourceFiles = next;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian10.Setting(rootEl).setName(i18n_default.settings.enhancedListBlocks.blpView.maxResults.name).setDesc(i18n_default.settings.enhancedListBlocks.blpView.maxResults.desc).addText((text) => {
      var _a3;
      text.inputEl.type = "number";
      text.setPlaceholder("0").setValue(String((_a3 = this.plugin.settings.blpViewMaxResults) != null ? _a3 : 0)).onChange(async (value) => {
        const trimmed = value.trim();
        const next = trimmed ? Number.parseInt(trimmed, 10) : 0;
        if (!Number.isFinite(next) || next < 0)
          return;
        this.plugin.settings.blpViewMaxResults = next;
        await this.plugin.saveSettings();
      });
    });
    this.addToggleSetting("blpViewShowDiagnostics", void 0, rootEl).setName(i18n_default.settings.enhancedListBlocks.blpView.showDiagnostics.name).setDesc(i18n_default.settings.enhancedListBlocks.blpView.showDiagnostics.desc);
  }
};
function getFileOutlinerListEditorLabels() {
  var _a2, _b2, _c2, _d2, _e2;
  const raw = (_b2 = (_a2 = i18n_default.settings) == null ? void 0 : _a2.fileOutliner) == null ? void 0 : _b2.listEditor;
  return {
    moveUp: String((_c2 = raw == null ? void 0 : raw.moveUp) != null ? _c2 : "Move up"),
    moveDown: String((_d2 = raw == null ? void 0 : raw.moveDown) != null ? _d2 : "Move down"),
    remove: String((_e2 = raw == null ? void 0 : raw.remove) != null ? _e2 : "Remove")
  };
}
function getVaultFolders(app) {
  var _a2, _b2, _c2;
  const files = (_b2 = (_a2 = app == null ? void 0 : app.vault) == null ? void 0 : _a2.getAllLoadedFiles) == null ? void 0 : _b2.call(_a2);
  if (!Array.isArray(files))
    return [];
  const out = [];
  for (const f2 of files) {
    if (!(f2 instanceof import_obsidian10.TFolder))
      continue;
    const path = String((_c2 = f2.path) != null ? _c2 : "").trim();
    if (!path)
      continue;
    out.push(path);
  }
  return out;
}
function getVaultMarkdownFiles(app) {
  var _a2, _b2, _c2, _d2;
  const files = (_b2 = (_a2 = app == null ? void 0 : app.vault) == null ? void 0 : _a2.getFiles) == null ? void 0 : _b2.call(_a2);
  if (!Array.isArray(files))
    return [];
  const out = [];
  for (const f2 of files) {
    if (!(f2 instanceof import_obsidian10.TFile))
      continue;
    if (String((_c2 = f2.extension) != null ? _c2 : "").toLowerCase() !== "md")
      continue;
    const path = String((_d2 = f2.path) != null ? _d2 : "").trim();
    if (!path)
      continue;
    out.push(path);
  }
  return out;
}
function fuzzyFilter(query, candidates, limit = 50) {
  const q = String(query != null ? query : "").trim();
  if (!q)
    return candidates.slice(0, limit);
  const search = (0, import_obsidian10.prepareFuzzySearch)(q);
  const scored = [];
  for (const c of candidates) {
    const r = search(c);
    if (!r)
      continue;
    scored.push({ value: c, score: r.score });
  }
  scored.sort((a, b) => b.score - a.score);
  return scored.slice(0, limit).map((x) => x.value);
}
var VaultFolderSuggest = class extends import_obsidian10.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.inputEl = inputEl;
  }
  getSuggestions(query) {
    return fuzzyFilter(query, getVaultFolders(this.app));
  }
  renderSuggestion(value, el) {
    el.setText(value);
  }
  selectSuggestion(value, _evt) {
    this.setValue(value);
    this.inputEl.dispatchEvent(new Event("input"));
    this.close();
  }
};
var VaultFileSuggest = class extends import_obsidian10.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.inputEl = inputEl;
  }
  getSuggestions(query) {
    return fuzzyFilter(query, getVaultMarkdownFiles(this.app));
  }
  renderSuggestion(value, el) {
    el.setText(value);
  }
  selectSuggestion(value, _evt) {
    this.setValue(value);
    this.inputEl.dispatchEvent(new Event("input"));
    this.close();
  }
};
function getInstalledPluginEntries(app) {
  var _a2;
  const manifests = (_a2 = app == null ? void 0 : app.plugins) == null ? void 0 : _a2.manifests;
  const out = [{ id: "core", name: "Core" }];
  if (!manifests || typeof manifests !== "object")
    return out;
  for (const [id, manifest] of Object.entries(manifests)) {
    const pluginId = String(id != null ? id : "").trim();
    if (!pluginId)
      continue;
    out.push({ id: pluginId, name: typeof (manifest == null ? void 0 : manifest.name) === "string" ? manifest.name : void 0 });
  }
  out.sort((a, b) => {
    if (a.id === "core")
      return -1;
    if (b.id === "core")
      return 1;
    return a.id.localeCompare(b.id);
  });
  return out;
}
var InstalledPluginIdSuggest = class extends import_obsidian10.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.namesById = /* @__PURE__ */ new Map();
    this.inputEl = inputEl;
    for (const entry of getInstalledPluginEntries(app)) {
      if (entry.name)
        this.namesById.set(entry.id.toLowerCase(), entry.name);
    }
  }
  getSuggestions(query) {
    const candidates = getInstalledPluginEntries(this.app).map((e) => e.id);
    return fuzzyFilter(query, candidates);
  }
  renderSuggestion(value, el) {
    const id = String(value != null ? value : "");
    const name = this.namesById.get(id.toLowerCase());
    if (!name)
      return el.setText(id);
    const root = el.createDiv({ cls: "blp-settings-suggest" });
    root.createDiv({ text: id });
    root.createDiv({ text: name, cls: "blp-settings-suggest-desc" });
  }
  selectSuggestion(value, _evt) {
    this.setValue(value);
    this.inputEl.dispatchEvent(new Event("input"));
    this.close();
  }
};

// src/ui/ViewPlugin.ts
var import_view2 = require("@codemirror/view");

// src/shared/block-marker.ts
var BLP_BLOCK_MARKER = "\u02C5";
var BLP_BLOCK_MARKER_RULE = `(^| )${BLP_BLOCK_MARKER}[a-zA-Z0-9_]+$`;

// src/ui/ViewPlugin.ts
function createViewPlugin(rule = BLP_BLOCK_MARKER_RULE) {
  let decorator = new import_view2.MatchDecorator({
    regexp: new RegExp(rule, "g"),
    decoration: () => {
      return import_view2.Decoration.mark({ class: "small-font" });
    }
  });
  return import_view2.ViewPlugin.define(
    (view) => ({
      decorations: decorator.createDeco(view),
      update(u) {
        this.decorations = decorator.updateDeco(u, this.decorations);
      }
    }),
    {
      decorations: (v) => v.decorations
    }
  );
}

// src/ui/MarkdownPostOutliner.ts
var import_obsidian12 = require("obsidian");

// src/features/file-outliner-view/enable-scope.ts
var import_obsidian11 = require("obsidian");
function isPathInFolder(path, folder) {
  return isPathInFileOutlinerScopeFolder((0, import_obsidian11.normalizePath)(path), folder);
}
var scopeByPlugin = /* @__PURE__ */ new WeakMap();
var scopeSymbol = Symbol.for("block-link-plus.fileOutlinerScopeManager");
function getFileOutlinerScopeManager(plugin) {
  const anyPlugin = plugin;
  const existing = anyPlugin == null ? void 0 : anyPlugin[scopeSymbol];
  if (existing)
    return existing;
  let scope = scopeByPlugin.get(plugin);
  if (!scope) {
    scope = new FileOutlinerScopeManager(plugin);
    scopeByPlugin.set(plugin, scope);
  }
  try {
    anyPlugin[scopeSymbol] = scope;
  } catch (e) {
  }
  return scope;
}
function isFileOutlinerEnabledFile(plugin, file) {
  if (!(file instanceof import_obsidian11.TFile))
    return false;
  return getFileOutlinerScopeManager(plugin).isEnabledFile(file);
}

// src/ui/MarkdownPostOutliner.ts
var OUTLINER_SYS_MARKER_RE2 = /\[blp_sys::\s*1\]/;
var OUTLINER_SYS_TOKENS_RE = /(\[[^\[\]]+?::[^\]]*?\]|\^[a-zA-Z0-9_-]+)/g;
var OUTLINER_READING_MODE_HIDER_MARKER = "data-blp-outliner-reading-mode-hider";
var OUTLINER_SYSTEM_LINE_HIDDEN_MARKER = "data-blp-outliner-system-line-hidden";
var OUTLINER_SYSTEM_LINE_HIDDEN_KIND_TOKEN = "token";
var OUTLINER_SYSTEM_LINE_HIDDEN_KIND_ELEMENT = "el";
function hidePreviousBrChain(el, maxCount) {
  var _a2;
  let prev = el.previousSibling;
  let hidden = 0;
  while (prev && hidden < maxCount) {
    while (prev && prev.nodeType === Node.TEXT_NODE && !((_a2 = prev.textContent) != null ? _a2 : "").trim()) {
      prev = prev.previousSibling;
    }
    if (!prev || prev.nodeType !== Node.ELEMENT_NODE)
      break;
    if (prev.tagName !== "BR")
      break;
    prev.style.display = "none";
    prev.setAttribute(OUTLINER_SYSTEM_LINE_HIDDEN_MARKER, OUTLINER_SYSTEM_LINE_HIDDEN_KIND_ELEMENT);
    hidden++;
    prev = prev.previousSibling;
  }
}
function unhideSystemLineInReadingMode(el) {
  var _a2;
  const marked = el.querySelectorAll(`[${OUTLINER_SYSTEM_LINE_HIDDEN_MARKER}]`);
  for (const node of Array.from(marked)) {
    const kind = node.getAttribute(OUTLINER_SYSTEM_LINE_HIDDEN_MARKER);
    if (node.tagName === "SPAN" && kind === OUTLINER_SYSTEM_LINE_HIDDEN_KIND_TOKEN) {
      node.replaceWith(document.createTextNode((_a2 = node.textContent) != null ? _a2 : ""));
      continue;
    }
    node.style.removeProperty("display");
    node.removeAttribute(OUTLINER_SYSTEM_LINE_HIDDEN_MARKER);
  }
}
function hideSystemLineInReadingMode(el) {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g, _h, _i, _j, _k, _l;
  unhideSystemLineInReadingMode(el);
  const hideTextNode = (tn) => {
    var _a3;
    const span = document.createElement("span");
    span.style.display = "none";
    span.setAttribute(OUTLINER_SYSTEM_LINE_HIDDEN_MARKER, OUTLINER_SYSTEM_LINE_HIDDEN_KIND_TOKEN);
    span.textContent = (_a3 = tn.nodeValue) != null ? _a3 : "";
    tn.replaceWith(span);
    return span;
  };
  const hideChildNode = (n2) => {
    var _a3;
    if (n2.nodeType === Node.TEXT_NODE) {
      const text = (_a3 = n2.nodeValue) != null ? _a3 : "";
      if (!text.trim())
        return null;
      return hideTextNode(n2);
    }
    if (n2.nodeType !== Node.ELEMENT_NODE)
      return null;
    const el2 = n2;
    hidePreviousBrChain(el2, 2);
    el2.style.display = "none";
    if (!el2.hasAttribute(OUTLINER_SYSTEM_LINE_HIDDEN_MARKER)) {
      el2.setAttribute(OUTLINER_SYSTEM_LINE_HIDDEN_MARKER, OUTLINER_SYSTEM_LINE_HIDDEN_KIND_ELEMENT);
    }
    return el2;
  };
  const markerWalker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);
  const markerTextNodes = [];
  let markerNode = markerWalker.nextNode();
  while (markerNode) {
    markerTextNodes.push(markerNode);
    markerNode = markerWalker.nextNode();
  }
  for (const textNode of markerTextNodes) {
    if (!textNode.parentElement)
      continue;
    if (textNode.parentElement.closest("pre, code"))
      continue;
    const text = (_a2 = textNode.nodeValue) != null ? _a2 : "";
    if (!OUTLINER_SYS_MARKER_RE2.test(text))
      continue;
    OUTLINER_SYS_TOKENS_RE.lastIndex = 0;
    const frag = document.createDocumentFragment();
    let last = 0;
    let match2;
    while ((match2 = OUTLINER_SYS_TOKENS_RE.exec(text)) !== null) {
      const start = match2.index;
      const end = start + match2[0].length;
      const before = text.slice(last, start);
      if (before)
        frag.append(document.createTextNode(before));
      const span = document.createElement("span");
      span.style.display = "none";
      span.setAttribute(OUTLINER_SYSTEM_LINE_HIDDEN_MARKER, OUTLINER_SYSTEM_LINE_HIDDEN_KIND_TOKEN);
      span.textContent = match2[0];
      frag.append(span);
      last = end;
    }
    const after = text.slice(last);
    if (after)
      frag.append(document.createTextNode(after));
    textNode.replaceWith(frag);
  }
  const allInlineFieldKeys = Array.from(el.querySelectorAll(".dataview.inline-field-key"));
  const getDvKeyName = (keyEl) => {
    var _a3, _b3, _c3;
    const dvKey = (_b3 = (_a3 = keyEl.getAttribute("data-dv-key")) != null ? _a3 : keyEl.getAttribute("data-dv-norm-key")) != null ? _b3 : "";
    return (dvKey || ((_c3 = keyEl.textContent) != null ? _c3 : "")).trim().toLowerCase();
  };
  const sysMarkerKeys = allInlineFieldKeys.filter((keyEl) => getDvKeyName(keyEl) === "blp_sys");
  const verMarkerKeys = sysMarkerKeys.length > 0 ? [] : allInlineFieldKeys.filter((keyEl) => getDvKeyName(keyEl) === "blp_ver");
  const markerKeysToUse = sysMarkerKeys.length > 0 ? sysMarkerKeys : verMarkerKeys;
  for (const keyEl of Array.from(markerKeysToUse)) {
    const fieldEl = keyEl.closest(".dataview.inline-field");
    if (!fieldEl)
      continue;
    const valueEl = fieldEl.querySelector(".dataview.inline-field-value");
    const valueText = ((_b2 = valueEl == null ? void 0 : valueEl.textContent) != null ? _b2 : "").trim();
    const keyName = getDvKeyName(keyEl);
    if (keyName === "blp_sys" && valueText !== "1")
      continue;
    if (keyName === "blp_ver" && valueText !== "2")
      continue;
    const hideInlineField = (n2) => {
      if (n2.nodeType !== Node.ELEMENT_NODE)
        return;
      const el2 = n2;
      if (!el2.classList.contains("dataview") || !el2.classList.contains("inline-field"))
        return;
      hidePreviousBrChain(el2, 2);
      el2.style.display = "none";
      el2.setAttribute(OUTLINER_SYSTEM_LINE_HIDDEN_MARKER, OUTLINER_SYSTEM_LINE_HIDDEN_KIND_ELEMENT);
    };
    hideInlineField(fieldEl);
    let prev = fieldEl.previousSibling;
    while (prev) {
      if (prev.nodeType === Node.ELEMENT_NODE && prev.tagName === "BR")
        break;
      hideInlineField(prev);
      prev = prev.previousSibling;
    }
    let next = fieldEl.nextSibling;
    while (next) {
      if (next.nodeType === Node.ELEMENT_NODE && next.tagName === "BR")
        break;
      hideInlineField(next);
      next = next.nextSibling;
    }
    const li = fieldEl.closest("li");
    if (li) {
      const textWalker = document.createTreeWalker(li, NodeFilter.SHOW_TEXT);
      const textNodes = [];
      let t = textWalker.nextNode();
      while (t) {
        textNodes.push(t);
        t = textWalker.nextNode();
      }
      for (const tn of textNodes) {
        const raw = (_c2 = tn.nodeValue) != null ? _c2 : "";
        if (!raw.includes("^"))
          continue;
        const caretRe = /\^([a-zA-Z0-9_-]+)\s*/g;
        caretRe.lastIndex = 0;
        const frag = document.createDocumentFragment();
        let last = 0;
        let match2;
        while ((match2 = caretRe.exec(raw)) !== null) {
          const start = match2.index;
          const end = start + match2[0].length;
          const before = raw.slice(last, start);
          if (before)
            frag.append(document.createTextNode(before));
          const span = document.createElement("span");
          span.style.display = "none";
          span.setAttribute(OUTLINER_SYSTEM_LINE_HIDDEN_MARKER, OUTLINER_SYSTEM_LINE_HIDDEN_KIND_TOKEN);
          span.textContent = match2[0];
          frag.append(span);
          last = end;
        }
        if (last === 0)
          continue;
        const after = raw.slice(last);
        if (after)
          frag.append(document.createTextNode(after));
        tn.replaceWith(frag);
      }
      const sysTokenWalker = document.createTreeWalker(li, NodeFilter.SHOW_TEXT);
      const sysTokenTextNodes = [];
      let st = sysTokenWalker.nextNode();
      while (st) {
        sysTokenTextNodes.push(st);
        st = sysTokenWalker.nextNode();
      }
      for (const tn of sysTokenTextNodes) {
        if ((_d2 = tn.parentElement) == null ? void 0 : _d2.closest("pre, code"))
          continue;
        const raw = (_e2 = tn.nodeValue) != null ? _e2 : "";
        if (!/blp_sys|blp_ver/i.test(raw))
          continue;
        hideTextNode(tn);
      }
    }
  }
  const sysTextWalker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);
  const sysTextNodes = [];
  let sysNode = sysTextWalker.nextNode();
  while (sysNode) {
    sysTextNodes.push(sysNode);
    sysNode = sysTextWalker.nextNode();
  }
  for (const tn of sysTextNodes) {
    const raw = ((_f2 = tn.nodeValue) != null ? _f2 : "").toLowerCase();
    if (!raw.includes("blp_sys"))
      continue;
    if ((_g = tn.parentElement) == null ? void 0 : _g.closest("pre, code"))
      continue;
    const li = (_h = tn.parentElement) == null ? void 0 : _h.closest("li");
    const root = li != null ? li : tn.parentElement;
    if (!root)
      continue;
    const rootText = ((_i = root.textContent) != null ? _i : "").toLowerCase();
    if (!rootText.includes("blp_ver"))
      continue;
    let direct = tn;
    while (direct.parentElement && direct.parentElement !== root) {
      direct = direct.parentElement;
    }
    if (direct.parentNode !== root)
      continue;
    let boundary = direct.previousSibling;
    while (boundary) {
      if (boundary.nodeType === Node.ELEMENT_NODE && boundary.tagName === "BR")
        break;
      if (boundary.nodeType === Node.TEXT_NODE && ((_j = boundary.nodeValue) != null ? _j : "").includes("\n"))
        break;
      boundary = boundary.previousSibling;
    }
    if (!boundary)
      continue;
    if (boundary.nodeType === Node.ELEMENT_NODE && boundary.tagName === "BR") {
      try {
        boundary.style.display = "none";
        boundary.setAttribute(OUTLINER_SYSTEM_LINE_HIDDEN_MARKER, OUTLINER_SYSTEM_LINE_HIDDEN_KIND_ELEMENT);
      } catch (e) {
      }
    } else if (boundary.nodeType === Node.TEXT_NODE) {
      const value = (_k = boundary.nodeValue) != null ? _k : "";
      const idx = value.lastIndexOf("\n");
      if (idx !== -1) {
        boundary.nodeValue = value.slice(0, idx).replace(/[ \t]+$/, "");
      }
    }
    let cursor = boundary.nextSibling;
    while (cursor) {
      if (cursor.nodeType === Node.ELEMENT_NODE) {
        const tag = cursor.tagName;
        if (tag === "UL" || tag === "OL")
          break;
        if (tag === "BR")
          break;
      } else if (cursor.nodeType === Node.TEXT_NODE && ((_l = cursor.nodeValue) != null ? _l : "").includes("\n")) {
        break;
      }
      const next = cursor.nextSibling;
      hideChildNode(cursor);
      cursor = next;
    }
  }
  const hiddenTokens = el.querySelectorAll(
    `span[${OUTLINER_SYSTEM_LINE_HIDDEN_MARKER}="${OUTLINER_SYSTEM_LINE_HIDDEN_KIND_TOKEN}"]`
  );
  for (const token of Array.from(hiddenTokens)) {
    if (!token.closest("li"))
      continue;
    hidePreviousBrChain(token, 2);
  }
}
var OutlinerReadingModeHiderChild = class extends import_obsidian12.MarkdownRenderChild {
  constructor(containerEl, plugin) {
    super(containerEl);
    this.observer = null;
    this.applyTimer = null;
    this.plugin = plugin;
    this.lastHideSetting = plugin.settings.fileOutlinerHideSystemLine;
  }
  withObserverSuspended(fn) {
    if (!this.observer) {
      fn();
      return;
    }
    try {
      this.observer.disconnect();
    } catch (e) {
    }
    try {
      fn();
    } finally {
      try {
        this.observer.observe(this.containerEl, { childList: true, subtree: true });
      } catch (e) {
      }
    }
  }
  scheduleApply() {
    if (this.applyTimer != null)
      return;
    this.applyTimer = window.setTimeout(() => {
      var _a2;
      this.applyTimer = null;
      if (!this.observer)
        return;
      if (!((_a2 = this.containerEl) == null ? void 0 : _a2.isConnected))
        return;
      const nextHide = this.plugin.settings.fileOutlinerHideSystemLine;
      this.withObserverSuspended(() => {
        if (nextHide) {
          hideSystemLineInReadingMode(this.containerEl);
        } else {
          unhideSystemLineInReadingMode(this.containerEl);
        }
      });
      this.lastHideSetting = nextHide;
    }, 0);
  }
  onload() {
    this.observer = new MutationObserver(() => {
      const nextHide = this.plugin.settings.fileOutlinerHideSystemLine;
      if (nextHide) {
        this.scheduleApply();
        return;
      }
      if (this.lastHideSetting !== nextHide) {
        this.scheduleApply();
      }
    });
    this.withObserverSuspended(() => {
      if (this.plugin.settings.fileOutlinerHideSystemLine) {
        hideSystemLineInReadingMode(this.containerEl);
      } else {
        unhideSystemLineInReadingMode(this.containerEl);
      }
    });
  }
  onunload() {
    var _a2;
    if (this.applyTimer != null) {
      window.clearTimeout(this.applyTimer);
      this.applyTimer = null;
    }
    (_a2 = this.observer) == null ? void 0 : _a2.disconnect();
    this.observer = null;
  }
};
function fileOutlinerMarkdownPostProcessor(el, ctx, plugin) {
  var _a2;
  if (el.closest(".blp-file-outliner-view"))
    return;
  const file = plugin.app.vault.getAbstractFileByPath(ctx.sourcePath);
  if (!(file instanceof import_obsidian12.TFile))
    return;
  if (plugin.settings.fileOutlinerHideSystemLine === false)
    return;
  const hasMarker = Boolean(
    el.querySelector(
      '.dataview.inline-field-key[data-dv-key="blp_sys"], .dataview.inline-field-key[data-dv-norm-key="blp_sys"], .dataview.inline-field-key[data-dv-key="blp_ver"], .dataview.inline-field-key[data-dv-norm-key="blp_ver"]'
    )
  ) || /blp_sys|blp_ver/i.test((_a2 = el.textContent) != null ? _a2 : "");
  if (!isFileOutlinerEnabledFile(plugin, file) && !hasMarker)
    return;
  if (typeof (ctx == null ? void 0 : ctx.addChild) === "function" && !el.hasAttribute(OUTLINER_READING_MODE_HIDER_MARKER)) {
    el.setAttribute(OUTLINER_READING_MODE_HIDER_MARKER, "1");
    ctx.addChild(new OutlinerReadingModeHiderChild(el, plugin));
  }
  hideSystemLineInReadingMode(el);
}

// src/ui/WhatsNewModal.ts
var import_obsidian13 = require("obsidian");

// src/features/whats-new/index.ts
function decideWhatsNewOnStartup(params) {
  var _a2;
  const lastSeenVersion = (_a2 = params.lastSeenVersion) != null ? _a2 : "";
  if (!lastSeenVersion) {
    if (!params.hasExistingData) {
      return { kind: "record", lastSeenVersion: params.currentVersion };
    }
    return { kind: "show", lastSeenVersion: params.currentVersion, previousVersion: "" };
  }
  if (lastSeenVersion === params.currentVersion)
    return { kind: "none" };
  return {
    kind: "show",
    lastSeenVersion: params.currentVersion,
    previousVersion: lastSeenVersion
  };
}
function getChangelogUrl(lang) {
  const baseUrl = "https://block-link-plus.jasper1024.com";
  if (lang === "en")
    return `${baseUrl}/en/changelog/`;
  if (lang === "zh-TW")
    return `${baseUrl}/zh-TW/changelog/`;
  return `${baseUrl}/changelog/`;
}

// src/ui/WhatsNewModal.ts
var WHATS_NEW_V2 = {
  en: [
    "Outliner is now the main workflow (Logseq-like list blocks in scoped files).",
    "Unified scope model: enable via settings (folders/files) or per-file frontmatter `blp_outliner: true/false`.",
    "`blp-view` is aligned with the Outliner scope model (no cross-scope reads).",
    "Removed legacy Timeline / Time Section features."
  ],
  zh: [
    "Outliner \u6210\u4E3A\u4E3B\u7EBF\u5DE5\u4F5C\u6D41\uFF08\u4EFF Logseq\uFF1A\u5728\u542F\u7528\u8303\u56F4\u5185\u628A\u5217\u8868\u9879\u5F53\u4F5C block\uFF09\u3002",
    "\u542F\u7528\u8303\u56F4\u7EDF\u4E00\uFF1A\u8BBE\u7F6E\u4E2D\u7684\u542F\u7528\u6587\u4EF6\u5939/\u6587\u4EF6 + \u6BCF\u6587\u4EF6 frontmatter `blp_outliner: true/false`\u3002",
    "`blp-view` \u4E0E Outliner \u542F\u7528\u8303\u56F4\u5BF9\u9F50\uFF08\u4E0D\u4F1A\u518D\u8DE8\u8303\u56F4\u8BFB\u53D6\uFF09\u3002",
    "\u79FB\u9664 Timeline / Time section \u7B49\u65E7\u80FD\u529B\u3002"
  ],
  "zh-TW": [
    "Outliner \u6210\u70BA\u4E3B\u7DDA\u5DE5\u4F5C\u6D41\uFF08\u4EFF Logseq\uFF1A\u5728\u555F\u7528\u7BC4\u570D\u5167\u628A\u6E05\u55AE\u9805\u7576\u4F5C block\uFF09\u3002",
    "\u555F\u7528\u7BC4\u570D\u7D71\u4E00\uFF1A\u8A2D\u5B9A\u4E2D\u7684\u555F\u7528\u8CC7\u6599\u593E/\u6A94\u6848 + \u6BCF\u6A94\u6848 frontmatter `blp_outliner: true/false`\u3002",
    "`blp-view` \u8207 Outliner \u555F\u7528\u7BC4\u570D\u5C0D\u9F4A\uFF08\u4E0D\u518D\u8DE8\u7BC4\u570D\u8B80\u53D6\uFF09\u3002",
    "\u79FB\u9664 Timeline / Time section \u7B49\u820A\u80FD\u529B\u3002"
  ]
};
var WHATS_NEW_V2_0_1 = {
  en: [
    "Outliner: editor command bridge enabled (core shortcuts like Ctrl+B now work in Outliner edit mode).",
    "Outliner: strict plugin allowlist for editor commands (enable specific shortcut plugins safely).",
    "Settings: one-click copy from the editor menu allowlist to the editor command allowlist."
  ],
  zh: [
    "Outliner\uFF1A\u7F16\u8F91\u5668\u547D\u4EE4\u6865\u63A5\uFF08Outliner \u7F16\u8F91\u65F6 core \u5FEB\u6377\u952E\u5982 Ctrl+B \u53EF\u7528\uFF09\u3002",
    "Outliner\uFF1A\u7F16\u8F91\u5668\u547D\u4EE4\u4E25\u683C\u767D\u540D\u5355\uFF08\u53EF\u5B89\u5168\u542F\u7528\u90E8\u5206\u5FEB\u6377\u952E\u63D2\u4EF6\uFF09\u3002",
    "\u8BBE\u7F6E\uFF1A\u652F\u6301\u4ECE\u7F16\u8F91\u5668\u53F3\u952E\u83DC\u5355\u767D\u540D\u5355\u4E00\u952E\u590D\u5236\u5230\u7F16\u8F91\u5668\u547D\u4EE4\u767D\u540D\u5355\u3002"
  ],
  "zh-TW": [
    "Outliner\uFF1A\u7DE8\u8F2F\u5668\u547D\u4EE4\u6A4B\u63A5\uFF08Outliner \u7DE8\u8F2F\u6642 core \u5FEB\u6377\u9375\u5982 Ctrl+B \u53EF\u7528\uFF09\u3002",
    "Outliner\uFF1A\u7DE8\u8F2F\u5668\u547D\u4EE4\u56B4\u683C\u767D\u540D\u55AE\uFF08\u53EF\u5B89\u5168\u555F\u7528\u90E8\u5206\u5FEB\u6377\u9375\u5916\u639B\uFF09\u3002",
    "\u8A2D\u5B9A\uFF1A\u652F\u63F4\u5F9E\u7DE8\u8F2F\u5668\u53F3\u9375\u9078\u55AE\u767D\u540D\u55AE\u4E00\u9375\u8907\u88FD\u5230\u7DE8\u8F2F\u5668\u547D\u4EE4\u767D\u540D\u55AE\u3002"
  ]
};
var WhatsNewModal = class extends import_obsidian13.Modal {
  constructor(app, options) {
    super(app);
    this.currentVersion = options.currentVersion;
    this.previousVersion = options.previousVersion;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const title = i18n_default.whatsNew.titleWithVersion.replace("${1}", this.currentVersion);
    contentEl.createEl("h2", { text: title });
    if (this.previousVersion) {
      const summary = i18n_default.whatsNew.updatedFromTo.replace("${1}", this.previousVersion).replace("${2}", this.currentVersion);
      contentEl.createEl("p", { text: summary });
    }
    const items = this.getWhatsNewItems();
    if (items.length) {
      const listEl = contentEl.createEl("ul");
      for (const item of items) {
        listEl.createEl("li", { text: item });
      }
    }
    const buttonsEl = contentEl.createDiv({ cls: "modal-button-container" });
    const changelogBtn = buttonsEl.createEl("button", {
      text: i18n_default.whatsNew.viewChangelog,
      cls: "mod-cta"
    });
    changelogBtn.addEventListener("click", () => {
      const url = getChangelogUrl(i18n_default.lang);
      window.open(url);
    });
    const closeBtn = buttonsEl.createEl("button", { text: i18n_default.whatsNew.close });
    closeBtn.addEventListener("click", () => this.close());
  }
  onClose() {
    this.contentEl.empty();
  }
  getWhatsNewItems() {
    var _a2, _b2;
    if (this.currentVersion === "1.8.0") {
      return i18n_default.whatsNew.v1_8_0;
    }
    if (this.currentVersion === "2.0.1") {
      return (_a2 = WHATS_NEW_V2_0_1[i18n_default.lang]) != null ? _a2 : WHATS_NEW_V2_0_1.en;
    }
    if (this.currentVersion === "2.0.0" || this.currentVersion.startsWith("2.0.")) {
      return (_b2 = WHATS_NEW_V2[i18n_default.lang]) != null ? _b2 : WHATS_NEW_V2.en;
    }
    return i18n_default.whatsNew.fallback;
  }
};

// src/features/command-handler/index.ts
var import_obsidian15 = require("obsidian");

// src/utils/index.ts
function generateRandomId(prefix, length) {
  if (length < 3 || length > 7) {
    throw new Error("Length must be between 3 and 7.");
  }
  const separator = prefix ? "-" : "";
  return `${prefix}${separator}${Math.random().toString(36).substring(2, 2 + length)}`;
}
function shouldInsertAfter(block) {
  if (block.type) {
    return [
      "blockquote",
      "code",
      "table",
      "comment",
      "footnoteDefinition"
    ].includes(block.type);
  }
}
function processLineContent(line) {
  if (!line.trim())
    return "";
  line = line.replace(/<[^>]+>/g, "");
  line = line.replace(/^[\s]*[-*+]\s+/, "");
  line = line.replace(/^[\s]*\d+\.\s+/, "");
  line = line.replace(/^[\s]*>+\s*/, "");
  line = line.replace(/\s*\^[a-zA-Z0-9-]+$/, "");
  line = line.replace(/\n/g, " ");
  return line.trim();
}
function processMultiLineContent(editor, start_line, end_line, alias_length) {
  let currentLine = start_line;
  while (currentLine <= end_line) {
    const line = editor.getLine(currentLine);
    const lineWithoutBlockId = line.replace(/\s*\^[a-zA-Z0-9-]+$/, "");
    if (!lineWithoutBlockId.trim()) {
      currentLine++;
      continue;
    }
    if (lineWithoutBlockId.startsWith("|-") || lineWithoutBlockId.startsWith("```")) {
      currentLine++;
      if (currentLine <= end_line) {
        const nextLine = editor.getLine(currentLine);
        if (nextLine.match(/^```\w+$/)) {
          currentLine++;
        }
      }
      continue;
    }
    const processedContent = processLineContent(lineWithoutBlockId);
    if (processedContent) {
      return processedContent.slice(0, alias_length);
    }
    currentLine++;
  }
  return "";
}
function get_is_heading(head_analysis) {
  if (!head_analysis.isValid) {
    return false;
  }
  if (!head_analysis.isMultiline) {
    if (head_analysis.hasHeadingAtStart && head_analysis.headingAtStart != null)
      return true;
  } else {
    if (head_analysis.hasHeadingAtStart && // start_line is a heading
    head_analysis.isStartHeadingMinLevel)
      return true;
  }
  return false;
}

// src/features/heading-analysis/index.ts
var MAX_ALIAS_LENGTH = 100;
function analyzeHeadings(fileCache, editor, start_line, end_line) {
  var _a2, _b2, _c2;
  if (start_line === 0 && end_line === 0) {
    return {
      isValid: false,
      start_line,
      end_line,
      isMultiline: false,
      block: null,
      nearestBeforeStartLevel: 0,
      minLevelInRange: Infinity,
      hasHeadingAtStart: false,
      hasHeadingAtEnd: false,
      headingAtStart: null,
      headingAtEnd: null,
      isStartHeadingMinLevel: false,
      isEndLineJustBeforeHeading: false,
      blockContent: null,
      nearestHeadingTitle: null,
      selectedText: null,
      blockText: null
    };
  }
  if (!fileCache || end_line < start_line) {
    return {
      isValid: false,
      start_line,
      end_line,
      isMultiline: false,
      block: null,
      nearestBeforeStartLevel: 0,
      minLevelInRange: Infinity,
      hasHeadingAtStart: false,
      hasHeadingAtEnd: false,
      headingAtStart: null,
      headingAtEnd: null,
      isStartHeadingMinLevel: false,
      isEndLineJustBeforeHeading: false,
      blockContent: null,
      nearestHeadingTitle: null,
      selectedText: null,
      blockText: null
    };
  }
  let closestBeforeStartDistance = Infinity;
  let nearestHeadingTitle = null;
  let selectedText = editor.getSelection();
  let blockText = editor.getRange({ line: start_line, ch: 0 }, { line: end_line, ch: editor.getLine(end_line).length });
  if (start_line == end_line) {
    let head_block = (_a2 = fileCache.headings) == null ? void 0 : _a2.find(
      (heading) => {
        const { start } = heading.position;
        return start.line == start_line;
      }
    );
    let block2 = (fileCache.sections || []).find((section) => {
      return section.position.start.line <= end_line && section.position.end.line >= end_line;
    });
    const blockContent2 = block2 ? processLineContent(editor.getLine(start_line)) : null;
    let nearestBeforeStartLevel2 = 0;
    let closestBeforeStartDistance2 = Infinity;
    (_b2 = fileCache.headings) == null ? void 0 : _b2.forEach((heading) => {
      const { start } = heading.position;
      if (start.line < start_line) {
        if (heading.heading.startsWith("^") || heading.heading.startsWith(BLP_BLOCK_MARKER)) {
          return;
        }
        const distance = start_line - start.line;
        if (distance < closestBeforeStartDistance2) {
          closestBeforeStartDistance2 = distance;
          nearestBeforeStartLevel2 = heading.level;
          nearestHeadingTitle = heading.heading;
        }
      }
    });
    return {
      isValid: true,
      start_line,
      end_line,
      isMultiline: false,
      block: block2,
      nearestBeforeStartLevel: nearestBeforeStartLevel2,
      minLevelInRange: head_block ? head_block.level : Infinity,
      hasHeadingAtStart: !!block2,
      hasHeadingAtEnd: false,
      headingAtStart: head_block || null,
      headingAtEnd: null,
      isStartHeadingMinLevel: block2 ? true : false,
      isEndLineJustBeforeHeading: false,
      blockContent: blockContent2,
      nearestHeadingTitle,
      selectedText,
      blockText
    };
  }
  let nearestBeforeStartLevel = 0;
  let minLevelInRange = Infinity;
  let hasHeadingAtStart = false;
  let hasHeadingAtEnd = false;
  let headingAtStart = null;
  let headingAtEnd = null;
  let isStartHeadingMinLevel = false;
  let isEndLineJustBeforeHeading = false;
  let inner_levels = new Array();
  (_c2 = fileCache.headings) == null ? void 0 : _c2.forEach((heading) => {
    const { start, end } = heading.position;
    if (start.line < start_line) {
      const distance = start_line - start.line;
      if (start_line - start.line < closestBeforeStartDistance) {
        closestBeforeStartDistance = distance;
        nearestBeforeStartLevel = heading.level;
        if (heading.heading.startsWith("^") || heading.heading.startsWith(BLP_BLOCK_MARKER)) {
          return;
        }
        nearestHeadingTitle = heading.heading;
      }
    }
    if (start.line >= start_line && end.line <= end_line) {
      minLevelInRange = Math.min(minLevelInRange, heading.level);
      inner_levels.push(heading.level);
    }
    if (start.line === start_line) {
      hasHeadingAtStart = true;
      headingAtStart = heading;
    }
    if (start.line === end_line) {
      hasHeadingAtEnd = true;
      headingAtEnd = heading;
    }
    if (start.line === end_line + 1 || start.line === end_line + 2) {
      isEndLineJustBeforeHeading = true;
    }
  });
  if (hasHeadingAtStart && headingAtStart != null) {
    if (headingAtStart.level === minLevelInRange) {
      const minLevel = Math.min(...inner_levels);
      const countOfMinLevel = inner_levels.filter(
        (level) => level === minLevel
      ).length;
      if (headingAtStart && // @ts-ignore
      headingAtStart.level === minLevel && countOfMinLevel === 1) {
        isStartHeadingMinLevel = true;
      }
    }
  }
  let block = (fileCache.sections || []).find((section) => {
    return section.position.start.line <= end_line && section.position.end.line >= end_line;
  });
  const blockContent = block ? processMultiLineContent(editor, start_line, end_line, MAX_ALIAS_LENGTH) : null;
  return {
    isValid: true,
    start_line,
    end_line,
    isMultiline: true,
    block,
    nearestBeforeStartLevel,
    minLevelInRange,
    hasHeadingAtStart,
    hasHeadingAtEnd,
    headingAtStart,
    headingAtEnd,
    isStartHeadingMinLevel,
    isEndLineJustBeforeHeading,
    blockContent,
    nearestHeadingTitle,
    selectedText,
    blockText
  };
}

// src/features/link-creation/index.ts
function lineEndsWithBlockId(line) {
  return /\s*\^[a-zA-Z0-9-]+\s*$/.test(line);
}
function isLikelyParagraphContinuationLine(line) {
  if (!line.trim())
    return false;
  if (/^\s*#{1,6}\s+/.test(line))
    return false;
  if (/^\s*>/.test(line))
    return false;
  if (/^\s*([-*+]|(\d+\.))\s+/.test(line))
    return false;
  if (/^\s*(```|~~~)/.test(line))
    return false;
  if (/^\s*(\|\s*[-:]+|\|)/.test(line))
    return false;
  if (/^\s*(---|\*\*\*|___)\s*$/.test(line))
    return false;
  if (/^\s*%%/.test(line))
    return false;
  return true;
}
function gen_insert_blocklink_singleline(block, editor, settings) {
  if (block.id) {
    return `^${block.id}`;
  }
  if (block.type === "list") {
    const activeLine = editor.getCursor("to").line;
    const line = editor.getLine(activeLine);
    const blockIdMatch = line.match(/\s*\^([a-zA-Z0-9-]+)\s*$/);
    if (blockIdMatch) {
      return `^${blockIdMatch[1]}`;
    }
  }
  const end = {
    line: block.type === "list" ? editor.getCursor("to").line : block.position.end.line,
    ch: block.type === "list" ? editor.getLine(editor.getCursor("to").line).length : block.position.end.col
  };
  if (block.type === "heading" && settings.heading_id_newline) {
    const id2 = generateRandomId(
      settings.enable_prefix ? settings.id_prefix : "",
      settings.id_length
    );
    editor.replaceRange(
      `

^${id2}`,
      { line: block.position.end.line, ch: block.position.end.col }
    );
    return `^${id2}`;
  }
  const id = generateRandomId(
    settings.enable_prefix ? settings.id_prefix : "",
    settings.id_length
  );
  const spacer = shouldInsertAfter(block) ? "\n\n" : " ";
  editor.replaceRange(`${spacer}^${id}`, end);
  return `^${id}`;
}
function gen_insert_blocklink_multline_heading(block, editor, settings, heading_level) {
  const id = generateRandomId(
    settings.enable_prefix ? settings.id_prefix : "",
    settings.id_length
  );
  const sectionEnd = block.position.end;
  const end = {
    ch: sectionEnd.col,
    line: sectionEnd.line
  };
  const heading = "#".repeat(heading_level);
  editor.replaceRange(`

 ${heading} ^${id}`, end);
  const cursor = editor.getCursor("from");
  editor.setCursor(cursor.line, cursor.ch);
  editor.replaceRange(`${heading} ${BLP_BLOCK_MARKER}${id}

`, {
    line: cursor.line,
    ch: 0
  });
  return `${BLP_BLOCK_MARKER}${id}`;
}
function _gen_insert_block_singleline(line_num, editor, settings) {
  const line = editor.getLine(line_num);
  const blockIdMatch = line.match(/\s*\^([a-zA-Z0-9-]+)\s*$/);
  if (blockIdMatch) {
    return `^${blockIdMatch[1]}`;
  }
  const end = {
    line: line_num,
    ch: editor.getLine(line_num).length
  };
  const id = generateRandomId(
    settings.enable_prefix ? settings.id_prefix : "",
    settings.id_length
  );
  const spacer = " ";
  editor.replaceRange(`${spacer}^${id}`, end);
  return `^${id}`;
}
function gen_insert_blocklink_multline_block(fileCache, editor, settings) {
  if (fileCache.sections == null && fileCache.listItems == null)
    return "";
  const start_line = editor.getCursor("from").line;
  const end_line = editor.getCursor("to").line;
  let links = new Array();
  const rangesIntersect = (aStart, aEnd, bStart, bEnd) => {
    return aStart <= bEnd && bStart <= aEnd;
  };
  const selectedTargets = [];
  if (fileCache.listItems) {
    for (const item of fileCache.listItems) {
      const itemStart = item.position.start.line;
      const itemEnd = item.position.end.line;
      if (!rangesIntersect(itemStart, itemEnd, start_line, end_line))
        continue;
      selectedTargets.push({
        kind: "listItem",
        startLine: itemStart,
        endLine: itemEnd,
        // Obsidian only indexes list-item block IDs reliably at the end of the item
        // (after all continuation lines), so insert at the item end line.
        line: itemEnd
      });
    }
  }
  if (fileCache.sections) {
    const sortedSections = [...fileCache.sections].sort(
      (a, b) => a.position.start.line - b.position.start.line
    );
    for (const section of sortedSections) {
      if (!rangesIntersect(section.position.start.line, section.position.end.line, start_line, end_line)) {
        continue;
      }
      if (section.type === "list") {
        if (!fileCache.listItems) {
          const _start_line = Math.max(section.position.start.line, start_line);
          const _end_line = Math.min(section.position.end.line, end_line);
          for (let i = _start_line; i <= _end_line; i++) {
            const id = _gen_insert_block_singleline(i, editor, settings);
            links.push(id);
          }
        }
        continue;
      }
      selectedTargets.push({
        kind: "section",
        startLine: section.position.start.line,
        endLine: section.position.end.line,
        section
      });
    }
  }
  const seen = /* @__PURE__ */ new Set();
  const uniqueTargets = selectedTargets.sort((a, b) => a.startLine - b.startLine || a.endLine - b.endLine).filter((target) => {
    const key = target.kind === "listItem" ? `listItem:${target.startLine}:${target.endLine}` : `section:${target.startLine}:${target.endLine}:${target.section.type}`;
    if (seen.has(key))
      return false;
    seen.add(key);
    return true;
  });
  for (const target of uniqueTargets) {
    if (target.kind === "listItem") {
      const id = _gen_insert_block_singleline(target.line, editor, settings);
      links.push(id);
    } else {
      const id = gen_insert_blocklink_singleline(target.section, editor, settings);
      links.push(id);
    }
  }
  return links;
}
function gen_insert_blocklink_multiline_block(fileCache, editor, settings) {
  var _a2, _b2, _c2, _d2, _e2, _f2;
  const cursorFrom = editor.getCursor("from");
  const cursorTo = editor.getCursor("to");
  const startLine = Math.min(cursorFrom.line, cursorTo.line);
  const endLine = Math.max(cursorFrom.line, cursorTo.line);
  if (startLine === endLine) {
    return { ok: false, message: "Selection must span multiple lines" };
  }
  const frontmatterEndLine = (_c2 = (_b2 = (_a2 = fileCache.frontmatter) == null ? void 0 : _a2.position) == null ? void 0 : _b2.end) == null ? void 0 : _c2.line;
  if (typeof frontmatterEndLine === "number" && startLine <= frontmatterEndLine) {
    return { ok: false, message: "Selection cannot include frontmatter" };
  }
  if (startLine === 0) {
    try {
      if (!editor.getLine(0).trim()) {
        return { ok: false, message: "Selection cannot start at an empty first line" };
      }
    } catch (e) {
      return { ok: false, message: "Selection is invalid" };
    }
  }
  let id;
  const fullText = editor.getValue();
  do {
    id = generateRandomId("", 6);
  } while (fullText.includes(`^${id}`));
  const pickListItemForLine = (line) => {
    const listItems = fileCache.listItems;
    if (!listItems)
      return null;
    let best = null;
    for (const item of listItems) {
      const s2 = item.position.start.line;
      const e = item.position.end.line;
      if (s2 <= line && line <= e) {
        if (!best || e - s2 < best.end - best.start) {
          best = { start: s2, end: e };
        }
      }
    }
    return best;
  };
  const startListItem = pickListItemForLine(startLine);
  const endListItem = pickListItemForLine(endLine);
  const startInsertLine = startListItem ? startListItem.end : startLine;
  const endInsertLine = endListItem ? endListItem.end : endLine;
  const startInsertText = editor.getLine(startInsertLine);
  if (lineEndsWithBlockId(startInsertText)) {
    return { ok: false, message: "Start line already has a block ID" };
  }
  const endInsertText = editor.getLine(endInsertLine);
  if (lineEndsWithBlockId(endInsertText)) {
    return { ok: false, message: "End line already has a block ID" };
  }
  const firstLine = startInsertText;
  let newFirstLine;
  if (firstLine.trim() === "") {
    newFirstLine = `%% %% ^${id}`;
  } else {
    newFirstLine = `${firstLine} ^${id}`;
  }
  const endSection = (fileCache.sections || []).find((section) => {
    return section.position.start.line <= endInsertLine && section.position.end.line >= endInsertLine;
  });
  const endMarker = `^${id}-${id}`;
  const endMarkerInlineSafe = startInsertLine !== endInsertLine && Boolean(endInsertText.trim()) && !(endSection && shouldInsertAfter(endSection));
  const originalCursorFrom = editor.getCursor("from");
  const originalCursorTo = editor.getCursor("to");
  const originalValue = fullText;
  try {
    editor.replaceRange(
      newFirstLine,
      { line: startInsertLine, ch: 0 },
      { line: startInsertLine, ch: firstLine.length }
    );
    if (endMarkerInlineSafe) {
      const currentEndLineText = editor.getLine(endInsertLine);
      const endPos = { line: endInsertLine, ch: currentEndLineText.length };
      editor.replaceRange(` ${endMarker}`, endPos);
    } else {
      const insertEndMarkerAsListItemContinuation = Boolean(endListItem) && startInsertLine === endInsertLine;
      const insertAfterLine = insertEndMarkerAsListItemContinuation ? endInsertLine : endSection && (shouldInsertAfter(endSection) || endSection.type === "list") ? endSection.position.end.line : endInsertLine;
      const insertAfterText = editor.getLine(insertAfterLine);
      const insertAfterPos = { line: insertAfterLine, ch: insertAfterText.length };
      let nextLineText = "";
      try {
        nextLineText = (_d2 = editor.getLine(insertAfterLine + 1)) != null ? _d2 : "";
      } catch (e) {
        nextLineText = "";
      }
      const needsBlankLineAfterMarker = isLikelyParagraphContinuationLine(nextLineText);
      let markerLine = endMarker;
      if (insertEndMarkerAsListItemContinuation) {
        const indent = (_f2 = (_e2 = editor.getLine(endInsertLine).match(/^\s*/)) == null ? void 0 : _e2[0]) != null ? _f2 : "";
        markerLine = `${indent}${endMarker}`;
      }
      const insertText = needsBlankLineAfterMarker ? `
${markerLine}
` : `
${markerLine}`;
      editor.replaceRange(insertText, insertAfterPos);
    }
    return { ok: true, link: endMarker };
  } catch (e) {
    try {
      editor.setValue(originalValue);
      editor.setSelection(originalCursorFrom, originalCursorTo);
    } catch (e2) {
    }
    return { ok: false, message: "Failed to create multiline block" };
  }
}

// src/features/clipboard-handler/index.ts
var import_obsidian14 = require("obsidian");
function _gene_obsidian_url(app, file, blockId) {
  const vault = app.vault.getName();
  const filePath = encodeURIComponent(file.path);
  const encodedBlockId = encodeURIComponent(`#${blockId}`);
  return `obsidian://open?vault=${vault}&file=${filePath}${encodedBlockId}`;
}
function copyToClipboard(app, settings, file, links, isEmbed, alias, isUrl = false) {
  const linksArray = typeof links === "string" ? [links] : links;
  const aliasArray = typeof alias === "string" ? [alias] : alias;
  const content = linksArray.map((link, index) => {
    var _a2;
    const addNewLine = index < linksArray.length - 1 ? "\n" : "";
    if (isUrl) {
      return `${_gene_obsidian_url(app, file, link)}${addNewLine}`;
    }
    let embedPrefix = "";
    if (isEmbed) {
      embedPrefix = "!";
    }
    return `${embedPrefix}${app.fileManager.generateMarkdownLink(
      file,
      "",
      "#" + link,
      (_a2 = aliasArray == null ? void 0 : aliasArray[index]) != null ? _a2 : ""
    )}${addNewLine}`;
  }).join("");
  navigator.clipboard.writeText(content);
  if (isUrl && settings.enable_url_notification) {
    new import_obsidian14.Notice("Obsidian URI copied to clipboard");
  } else if (isEmbed && settings.enable_embed_notification) {
    new import_obsidian14.Notice("Block embed link copied to clipboard");
  } else if (!isEmbed && !isUrl && settings.enable_block_notification) {
    new import_obsidian14.Notice("Block link copied to clipboard");
  }
}
function calculateAlias(settings, links, isHeading, isEmbed, isUrl, alias_length, head_analysis) {
  var _a2, _b2, _c2;
  if (isEmbed || isUrl || Number(settings.alias_type) === 0 /* Default */) {
    return void 0;
  }
  if (isHeading && head_analysis.headingAtStart) {
    return head_analysis.headingAtStart.heading;
  }
  switch (Number(settings.alias_type)) {
    case 1 /* FirstChars */:
      return links instanceof Array ? (_a2 = head_analysis.blockText) == null ? void 0 : _a2.split("\n").filter((line) => line.length > 0).map((line) => processLineContent(line).slice(0, alias_length)) : (_b2 = head_analysis.blockContent) == null ? void 0 : _b2.slice(0, alias_length);
    case 2 /* Heading */:
      return head_analysis.nearestHeadingTitle != null ? head_analysis.nearestHeadingTitle.slice(0, alias_length) : void 0;
    case 3 /* SelectedText */:
      const selectedText = (_c2 = head_analysis.selectedText) == null ? void 0 : _c2.trim();
      if (!selectedText) {
        return void 0;
      }
      return links instanceof Array ? selectedText.split("\n").filter((line) => line.length > 0).map((line) => processLineContent(line)) : processLineContent(selectedText) || void 0;
    default:
      return void 0;
  }
}

// src/features/command-handler/index.ts
function handleSingleLine(plugin, file, isHeading, isEmbed, head_analysis, editor, isUrl = false) {
  let link;
  if (plugin.settings.heading_id_newline && head_analysis.block) {
    link = gen_insert_blocklink_singleline(head_analysis.block, editor, plugin.settings);
  } else if (isHeading && head_analysis.headingAtStart) {
    link = head_analysis.headingAtStart.heading;
  } else if (!isHeading && head_analysis.block) {
    link = gen_insert_blocklink_singleline(head_analysis.block, editor, plugin.settings);
  }
  if (link) {
    const alias = calculateAlias(plugin.settings, link, isHeading, isEmbed, isUrl, plugin.settings.alias_length, head_analysis);
    copyToClipboard(plugin.app, plugin.settings, file, link, isEmbed, alias, isUrl);
  }
}
function handleMultiLine(plugin, file, isHeading, isEmbed, head_analysis, editor, fileCache, isUrl = false) {
  if (isHeading && head_analysis.headingAtStart) {
    copyToClipboard(plugin.app, plugin.settings, file, head_analysis.headingAtStart.heading, isEmbed, void 0, isUrl);
  } else {
    handleMultiLineBlock(plugin, file, isEmbed, head_analysis, editor, fileCache, isUrl);
  }
}
function _gen_insert_blocklink_multline_heading(plugin, fileCache, editor, head_analysis) {
  if (!head_analysis.block)
    return "";
  return gen_insert_blocklink_multline_heading(
    head_analysis.block,
    editor,
    plugin.settings,
    head_analysis.nearestBeforeStartLevel + 1
  );
}
function _gen_insert_blocklink_multline_block(plugin, fileCache, editor, head_analysis) {
  return gen_insert_blocklink_multline_block(
    fileCache,
    editor,
    plugin.settings
  );
}
function handleMultiLineBlock(plugin, file, isEmbed, head_analysis, editor, fileCache, isUrl = false) {
  if (plugin.settings.mult_line_handle == 0 /* oneline */) {
    if (head_analysis.block) {
      const link = gen_insert_blocklink_singleline(
        head_analysis.block,
        editor,
        plugin.settings
      );
      const alias = calculateAlias(plugin.settings, link, false, isEmbed, isUrl, plugin.settings.alias_length, head_analysis);
      copyToClipboard(plugin.app, plugin.settings, file, link, isEmbed, alias, isUrl);
    }
    return;
  } else if (plugin.settings.mult_line_handle == 3 /* multilineblock */) {
    if (head_analysis.minLevelInRange != Infinity) {
      new import_obsidian15.Notice(
        `Selection cannot contain headings`,
        1500
      );
      return;
    }
    const result = gen_insert_blocklink_multiline_block(
      fileCache,
      editor,
      plugin.settings
    );
    if (!result.ok) {
      new import_obsidian15.Notice(result.message, 1500);
      return;
    }
    const link = result.link;
    const alias = calculateAlias(plugin.settings, link, false, isEmbed, isUrl, plugin.settings.alias_length, head_analysis);
    copyToClipboard(plugin.app, plugin.settings, file, link, isEmbed, alias, isUrl);
    return;
  } else {
    if (head_analysis.minLevelInRange != Infinity) {
      new import_obsidian15.Notice(
        `Selection cannot contain headings`,
        1500
      );
      return;
    }
    const linkMethod = plugin.settings.mult_line_handle == 1 /* heading */ ? _gen_insert_blocklink_multline_heading : _gen_insert_blocklink_multline_block;
    const link = linkMethod.call(
      plugin,
      fileCache,
      editor,
      head_analysis
    );
    const alias = calculateAlias(plugin.settings, link, false, isEmbed, isUrl, plugin.settings.alias_length, head_analysis);
    copyToClipboard(plugin.app, plugin.settings, file, link, isEmbed, alias, isUrl);
    return;
  }
}
function handleCommand(plugin, isChecking, editor, view, isEmbed, isUrl = false) {
  if (isChecking) {
    return true;
  }
  const file = view.file;
  if (!file)
    return;
  const start_line = editor.getCursor("from").line;
  const end_line = editor.getCursor("to").line;
  const fileCache = plugin.app.metadataCache.getFileCache(file);
  if (!fileCache)
    return;
  let head_analysis = analyzeHeadings(fileCache, editor, start_line, end_line);
  if (!head_analysis.isValid) {
    return;
  }
  let isHeading = get_is_heading(head_analysis);
  if (!head_analysis.isMultiline) {
    handleSingleLine(plugin, file, isHeading, isEmbed, head_analysis, editor, isUrl);
  } else {
    handleMultiLine(plugin, file, isHeading, isEmbed, head_analysis, editor, fileCache, isUrl);
  }
  return true;
}

// src/ui/EditorMenu.ts
var import_obsidian16 = require("obsidian");
function handleSingleLine2(plugin, file, isHeading, isEmbed, head_analysis, editor, isUrl = false) {
  let link;
  if (plugin.settings.heading_id_newline && head_analysis.block) {
    link = gen_insert_blocklink_singleline(head_analysis.block, editor, plugin.settings);
  } else if (isHeading && head_analysis.headingAtStart) {
    link = head_analysis.headingAtStart.heading;
  } else if (!isHeading && head_analysis.block) {
    link = gen_insert_blocklink_singleline(head_analysis.block, editor, plugin.settings);
  }
  if (link) {
    const alias = calculateAlias(plugin.settings, link, isHeading, isEmbed, isUrl, plugin.settings.alias_length, head_analysis);
    copyToClipboard(plugin.app, plugin.settings, file, link, isEmbed, alias, isUrl);
  }
}
function handleMultiLine2(plugin, file, isHeading, isEmbed, head_analysis, editor, fileCache, isUrl = false) {
  if (isHeading && head_analysis.headingAtStart) {
    copyToClipboard(plugin.app, plugin.settings, file, head_analysis.headingAtStart.heading, isEmbed, void 0, isUrl);
  } else {
    handleMultiLineBlock2(plugin, file, isEmbed, head_analysis, editor, fileCache, isUrl);
  }
}
function _gen_insert_blocklink_multline_heading2(plugin, fileCache, editor, head_analysis) {
  if (!head_analysis.block)
    return "";
  return gen_insert_blocklink_multline_heading(
    head_analysis.block,
    editor,
    plugin.settings,
    head_analysis.nearestBeforeStartLevel + 1
  );
}
function _gen_insert_blocklink_multline_block2(plugin, fileCache, editor, head_analysis) {
  return gen_insert_blocklink_multline_block(
    fileCache,
    editor,
    plugin.settings
  );
}
function handleMultiLineBlock2(plugin, file, isEmbed, head_analysis, editor, fileCache, isUrl = false) {
  if (plugin.settings.mult_line_handle == 0 /* oneline */) {
    if (head_analysis.block) {
      const link = gen_insert_blocklink_singleline(
        head_analysis.block,
        editor,
        plugin.settings
      );
      const alias = calculateAlias(plugin.settings, link, false, isEmbed, isUrl, plugin.settings.alias_length, head_analysis);
      copyToClipboard(plugin.app, plugin.settings, file, link, isEmbed, alias, isUrl);
    }
    return;
  } else if (plugin.settings.mult_line_handle == 3 /* multilineblock */) {
    if (head_analysis.minLevelInRange != Infinity) {
      new import_obsidian16.Notice(
        `Selection cannot contain headings`,
        1500
      );
      return;
    }
    const result = gen_insert_blocklink_multiline_block(
      fileCache,
      editor,
      plugin.settings
    );
    if (!result.ok) {
      new import_obsidian16.Notice(result.message, 1500);
      return;
    }
    const link = result.link;
    const alias = calculateAlias(plugin.settings, link, false, isEmbed, isUrl, plugin.settings.alias_length, head_analysis);
    copyToClipboard(plugin.app, plugin.settings, file, link, isEmbed, alias, isUrl);
    return;
  } else {
    if (head_analysis.minLevelInRange != Infinity) {
      new import_obsidian16.Notice(
        `Selection cannot contain headings`,
        1500
      );
      return;
    }
    const linkMethod = plugin.settings.mult_line_handle == 1 /* heading */ ? _gen_insert_blocklink_multline_heading2 : _gen_insert_blocklink_multline_block2;
    const link = linkMethod.call(
      plugin,
      fileCache,
      editor,
      head_analysis
    );
    const alias = calculateAlias(plugin.settings, link, false, isEmbed, isUrl, plugin.settings.alias_length, head_analysis);
    copyToClipboard(plugin.app, plugin.settings, file, link, isEmbed, alias, isUrl);
    return;
  }
}
function handleMenuItemClick(plugin, view, isHeading, isEmbed, head_analysis, isUrl = false) {
  if (!view.file || !head_analysis.isValid)
    return;
  const { file, editor } = view;
  const fileCache = plugin.app.metadataCache.getFileCache(file);
  if (!fileCache)
    return;
  if (!head_analysis.isMultiline) {
    handleSingleLine2(plugin, file, isHeading, isEmbed, head_analysis, editor, isUrl);
  } else {
    handleMultiLine2(plugin, file, isHeading, isEmbed, head_analysis, editor, fileCache, isUrl);
  }
}
function handleEditorMenu(plugin, menu, editor, view) {
  const file = view.file;
  if (!file)
    return;
  const start_line = editor.getCursor("from").line;
  const end_line = editor.getCursor("to").line;
  const fileCache = plugin.app.metadataCache.getFileCache(file);
  if (!fileCache)
    return;
  let head_analysis = analyzeHeadings(fileCache, editor, start_line, end_line);
  if (!head_analysis.isValid)
    return;
  let isHeading = get_is_heading(head_analysis);
  const addItemToMenu = (title, isEmbed, isUrl = false) => {
    menu.addItem((item) => {
      item.setTitle(title).setIcon("links-coming-in").onClick(
        () => handleMenuItemClick(
          plugin,
          view,
          isHeading,
          isEmbed,
          head_analysis,
          isUrl
        )
      );
    });
  };
  if (plugin.settings.enable_right_click_block) {
    addItemToMenu(
      isHeading ? "Copy Heading as Link" : "Copy Block as Link",
      false
    );
  }
  if (plugin.settings.enable_right_click_embed) {
    addItemToMenu(
      isHeading ? "Copy Heading as Embed" : "Copy Block as Embed",
      true
    );
  }
  if (plugin.settings.enable_right_click_url) {
    addItemToMenu(
      isHeading ? "Copy Heading as Obsidian URI" : "Copy Block as Obsidian URI",
      false,
      true
    );
  }
}

// src/features/file-outliner-view/constants.ts
var FILE_OUTLINER_VIEW_TYPE = "blp-file-outliner-view";

// src/features/file-outliner-view/view.ts
var import_obsidian19 = require("obsidian");

// node_modules/luxon/build/es6/luxon.mjs
var LuxonError = class extends Error {
};
var InvalidDateTimeError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
};
var InvalidIntervalError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
};
var InvalidDurationError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
};
var ConflictingSpecificationError = class extends LuxonError {
};
var InvalidUnitError = class extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
};
var InvalidArgumentError = class extends LuxonError {
};
var ZoneIsAbstractError = class extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
};
var n = "numeric";
var s = "short";
var l = "long";
var DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
var DATE_MED = {
  year: n,
  month: s,
  day: n
};
var DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s
};
var DATE_FULL = {
  year: n,
  month: l,
  day: n
};
var DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
var TIME_SIMPLE = {
  hour: n,
  minute: n
};
var TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
var TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
var TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s
};
var TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l
};
var DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n
};
var DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s
};
var DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
var DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
var Zone = class {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The IANA name of this zone.
   * Defaults to `name` if not overwritten by a subclass.
   * @abstract
   * @type {string}
   */
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
};
var singleton$1 = null;
var SystemZone = class extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton$1 === null) {
      singleton$1 = new SystemZone();
    }
    return singleton$1;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale);
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }
  /** @override **/
  get isValid() {
    return true;
  }
};
var dtfCache = /* @__PURE__ */ new Map();
function makeDTF(zoneName) {
  let dtf = dtfCache.get(zoneName);
  if (dtf === void 0) {
    dtf = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zoneName,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
    dtfCache.set(zoneName, dtf);
  }
  return dtf;
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const { type: type2, value } = formatted[i];
    const pos = typeToPos[type2];
    if (type2 === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
var ianaZoneCache = /* @__PURE__ */ new Map();
var IANAZone = class extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name) {
    let zone = ianaZoneCache.get(name);
    if (zone === void 0) {
      ianaZoneCache.set(name, zone = new IANAZone(name));
    }
    return zone;
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache.clear();
    dtfCache.clear();
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated For backward compatibility, this forwards to isValidZone, better use `isValidZone()` directly instead.
   * @return {boolean}
   */
  static isValidSpecifier(s2) {
    return this.isValidZone(s2);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e) {
      return false;
    }
  }
  constructor(name) {
    super();
    this.zoneName = name;
    this.valid = IANAZone.isValidZone(name);
  }
  /**
   * The type of zone. `iana` for all instances of `IANAZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "iana";
  }
  /**
   * The name of this zone (i.e. the IANA zone name).
   * @override
   * @type {string}
   */
  get name() {
    return this.zoneName;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns false for all IANA zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return false;
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @override
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    if (!this.valid)
      return NaN;
    const date = new Date(ts);
    if (isNaN(date))
      return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  /**
   * Return whether this Zone is equal to another zone
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  /**
   * Return whether this Zone is valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return this.valid;
  }
};
var intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
var intlDTCache = /* @__PURE__ */ new Map();
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache.get(key);
  if (dtf === void 0) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache.set(key, dtf);
  }
  return dtf;
}
var intlNumCache = /* @__PURE__ */ new Map();
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache.get(key);
  if (inf === void 0) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache.set(key, inf);
  }
  return inf;
}
var intlRelCache = /* @__PURE__ */ new Map();
function getCachedRTF(locString, opts = {}) {
  const { base, ...cacheKeyOpts } = opts;
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache.get(key);
  if (inf === void 0) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache.set(key, inf);
  }
  return inf;
}
var sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
var intlResolvedOptionsCache = /* @__PURE__ */ new Map();
function getCachedIntResolvedOptions(locString) {
  let opts = intlResolvedOptionsCache.get(locString);
  if (opts === void 0) {
    opts = new Intl.DateTimeFormat(locString).resolvedOptions();
    intlResolvedOptionsCache.set(locString, opts);
  }
  return opts;
}
var weekInfoCache = /* @__PURE__ */ new Map();
function getCachedWeekInfo(locString) {
  let data = weekInfoCache.get(locString);
  if (!data) {
    const locale = new Intl.Locale(locString);
    data = "getWeekInfo" in locale ? locale.getWeekInfo() : locale.weekInfo;
    if (!("minimalDays" in data)) {
      data = { ...fallbackWeekSettings, ...data };
    }
    weekInfoCache.set(locString, data);
  }
  return data;
}
function parseLocaleString(localeStr) {
  const xIndex = localeStr.indexOf("-x-");
  if (xIndex !== -1) {
    localeStr = localeStr.substring(0, xIndex);
  }
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    let selectedStr;
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
      selectedStr = localeStr;
    } catch (e) {
      const smaller = localeStr.substring(0, uIndex);
      options = getCachedDTF(smaller).resolvedOptions();
      selectedStr = smaller;
    }
    const { numberingSystem, calendar } = options;
    return [selectedStr, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    if (!localeStr.includes("-u-")) {
      localeStr += "-u";
    }
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f2) {
  const ms = [];
  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2009, i, 1);
    ms.push(f2(dt));
  }
  return ms;
}
function mapWeekdays(f2) {
  const ms = [];
  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f2(dt));
  }
  return ms;
}
function listStuff(loc, length, englishFn, intlFn) {
  const mode = loc.listingMode();
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || getCachedIntResolvedOptions(loc.locale).numberingSystem === "latn";
  }
}
var PolyNumberFormatter = class {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const { padTo, floor, ...otherOpts } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0)
        intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
};
var PolyDateFormatter = class {
  constructor(dt, intl, opts) {
    this.opts = opts;
    this.originalZone = void 0;
    let z = void 0;
    if (this.opts.timeZone) {
      this.dt = dt;
    } else if (dt.zone.type === "fixed") {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        z = "UTC";
        this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else if (dt.zone.type === "iana") {
      this.dt = dt;
      z = dt.zone.name;
    } else {
      z = "UTC";
      this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
      this.originalZone = dt.zone;
    }
    const intlOpts = { ...this.opts };
    intlOpts.timeZone = intlOpts.timeZone || z;
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    if (this.originalZone) {
      return this.formatToParts().map(({ value }) => value).join("");
    }
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const parts = this.dtf.formatToParts(this.dt.toJSDate());
    if (this.originalZone) {
      return parts.map((part) => {
        if (part.type === "timeZoneName") {
          const offsetName = this.originalZone.offsetName(this.dt.ts, {
            locale: this.dt.locale,
            format: this.opts.timeZoneName
          });
          return {
            ...part,
            value: offsetName
          };
        } else {
          return part;
        }
      });
    }
    return parts;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
};
var PolyRelFormatter = class {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
};
var fallbackWeekSettings = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};
var Locale = class {
  static fromOpts(opts) {
    return Locale.create(
      opts.locale,
      opts.numberingSystem,
      opts.outputCalendar,
      opts.weekSettings,
      opts.defaultToEN
    );
  }
  static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
    return new Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache.clear();
    intlNumCache.clear();
    intlRelCache.clear();
    intlResolvedOptionsCache.clear();
    weekInfoCache.clear();
  }
  static fromObject({ locale, numberingSystem, outputCalendar, weekSettings } = {}) {
    return Locale.create(locale, numberingSystem, outputCalendar, weekSettings);
  }
  constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.weekSettings = weekSettings;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        validateWeekSettings(alts.weekSettings) || this.weekSettings,
        alts.defaultToEN || false
      );
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }
  months(length, format = false) {
    return listStuff(this, length, months, () => {
      const monthSpecialCase = this.intl === "ja" || this.intl.startsWith("ja-");
      format &= !monthSpecialCase;
      const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        const mapper = !monthSpecialCase ? (dt) => this.extract(dt, intl, "month") : (dt) => this.dtFormatter(dt, intl).format();
        this.monthsCache[formatStr][length] = mapMonths(mapper);
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length, format = false) {
    return listStuff(this, length, weekdays, () => {
      const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays(
          (dt) => this.extract(dt, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems() {
    return listStuff(
      this,
      void 0,
      () => meridiems,
      () => {
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            (dt) => this.extract(dt, intl, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(length) {
    return listStuff(this, length, eras, () => {
      const intl = { era: length };
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
          (dt) => this.extract(dt, intl, "era")
        );
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || getCachedIntResolvedOptions(this.intl).locale.startsWith("en-us");
  }
  getWeekSettings() {
    if (this.weekSettings) {
      return this.weekSettings;
    } else if (!hasLocaleWeekInfo()) {
      return fallbackWeekSettings;
    } else {
      return getCachedWeekInfo(this.locale);
    }
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
  toString() {
    return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;
  }
};
var singleton = null;
var FixedOffsetZone = class extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton === null) {
      singleton = new FixedOffsetZone(0);
    }
    return singleton;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset2) {
    return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s2) {
    if (s2) {
      const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }
  constructor(offset2) {
    super();
    this.fixed = offset2;
  }
  /**
   * The type of zone. `fixed` for all instances of `FixedOffsetZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "fixed";
  }
  /**
   * The name of this zone.
   * All fixed zones' names always start with "UTC" (plus optional offset)
   * @override
   * @type {string}
   */
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  /**
   * The IANA name of this zone, i.e. `Etc/UTC` or `Etc/GMT+/-nn`
   *
   * @override
   * @type {string}
   */
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  /**
   * Returns the offset's common name at the specified timestamp.
   *
   * For fixed offset zones this equals to the zone name.
   * @override
   */
  offsetName() {
    return this.name;
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns true for all fixed offset zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return true;
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   *
   * For fixed offset zones, this is constant and does not depend on a timestamp.
   * @override
   * @return {number}
   */
  offset() {
    return this.fixed;
  }
  /**
   * Return whether this Zone is equal to another zone (i.e. also fixed and same offset)
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  /**
   * Return whether this Zone is valid:
   * All fixed offset zones are valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return true;
  }
};
var InvalidZone = class extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return false;
  }
  /** @override **/
  get isValid() {
    return false;
  }
};
function normalizeZone(input, defaultZone2) {
  if (isUndefined(input) || input === null) {
    return defaultZone2;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default")
      return defaultZone2;
    else if (lowered === "local" || lowered === "system")
      return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt")
      return FixedOffsetZone.utcInstance;
    else
      return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
    return input;
  } else {
    return new InvalidZone(input);
  }
}
var numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
var numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str2) {
  let value = parseInt(str2, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0; i < str2.length; i++) {
      const code = str2.charCodeAt(i);
      if (str2[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str2[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
var digitRegexCache = /* @__PURE__ */ new Map();
function resetDigitRegexCache() {
  digitRegexCache.clear();
}
function digitRegex({ numberingSystem }, append = "") {
  const ns = numberingSystem || "latn";
  let appendCache = digitRegexCache.get(ns);
  if (appendCache === void 0) {
    appendCache = /* @__PURE__ */ new Map();
    digitRegexCache.set(ns, appendCache);
  }
  let regex = appendCache.get(append);
  if (regex === void 0) {
    regex = new RegExp(`${numberingSystems[ns]}${append}`);
    appendCache.set(append, regex);
  }
  return regex;
}
var now = () => Date.now();
var defaultZone = "system";
var defaultLocale = null;
var defaultNumberingSystem = null;
var defaultOutputCalendar = null;
var twoDigitCutoffYear = 60;
var throwOnInvalid;
var defaultWeekSettings = null;
var Settings = class {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n2) {
    now = n2;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  /**
   * @typedef {Object} WeekSettings
   * @property {number} firstDay
   * @property {number} minimalDays
   * @property {number[]} weekend
   */
  /**
   * @return {WeekSettings|null}
   */
  static get defaultWeekSettings() {
    return defaultWeekSettings;
  }
  /**
   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
   * how many days are required in the first week of a year.
   * Does not affect existing instances.
   *
   * @param {WeekSettings|null} weekSettings
   */
  static set defaultWeekSettings(weekSettings) {
    defaultWeekSettings = validateWeekSettings(weekSettings);
  }
  /**
   * Get the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }
  /**
   * Set the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // all 'yy' are interpreted as 20th century
   * @example Settings.twoDigitCutoffYear = 99 // all 'yy' are interpreted as 21st century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 2049; '50' -> 1950
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(cutoffYear) {
    twoDigitCutoffYear = cutoffYear % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
    DateTime.resetCache();
    resetDigitRegexCache();
  }
};
var Invalid = class {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
};
var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value) {
  return new Invalid(
    "unit out of range",
    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
  );
}
function dayOfWeek(year, month, day) {
  const d = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  const js = d.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal), day = ordinal - table[month0];
  return { month: month0 + 1, day };
}
function isoWeekdayToLocal(isoWeekday, startOfWeek) {
  return (isoWeekday - startOfWeek + 7) % 7 + 1;
}
function gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);
  let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
  } else if (weekNumber > weeksInWeekYear(year, minDaysInFirstWeek, startOfWeek)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}
function weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(weekData) };
}
function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return { year, ordinal, ...timeObject(gregData) };
}
function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(ordinalData) };
}
function usesLocalWeekValues(obj, loc) {
  const hasLocaleWeekData = !isUndefined(obj.localWeekday) || !isUndefined(obj.localWeekNumber) || !isUndefined(obj.localWeekYear);
  if (hasLocaleWeekData) {
    const hasIsoWeekData = !isUndefined(obj.weekday) || !isUndefined(obj.weekNumber) || !isUndefined(obj.weekYear);
    if (hasIsoWeekData) {
      throw new ConflictingSpecificationError(
        "Cannot mix locale-based week fields with ISO-based week fields"
      );
    }
    if (!isUndefined(obj.localWeekday))
      obj.weekday = obj.localWeekday;
    if (!isUndefined(obj.localWeekNumber))
      obj.weekNumber = obj.localWeekNumber;
    if (!isUndefined(obj.localWeekYear))
      obj.weekYear = obj.localWeekYear;
    delete obj.localWeekday;
    delete obj.localWeekNumber;
    delete obj.localWeekYear;
    return {
      minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
      startOfWeek: loc.getStartOfWeek()
    };
  } else {
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
  }
}
function hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(
    obj.weekNumber,
    1,
    weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)
  ), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.weekNumber);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else
    return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else
    return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else
    return false;
}
function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else
    return false;
}
function isUndefined(o) {
  return typeof o === "undefined";
}
function isNumber(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}
function hasLocaleWeekInfo() {
  try {
    return typeof Intl !== "undefined" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch (e) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return void 0;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function validateWeekSettings(settings) {
  if (settings == null) {
    return null;
  } else if (typeof settings !== "object") {
    throw new InvalidArgumentError("Week settings must be an object");
  } else {
    if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v) => !integerBetween(v, 1, 7))) {
      throw new InvalidArgumentError("Invalid week settings");
    }
    return {
      firstDay: settings.firstDay,
      minimalDays: settings.minimalDays,
      weekend: Array.from(settings.weekend)
    };
  }
}
function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}
function floorMod(x, n2) {
  return x - n2 * Math.floor(x / n2);
}
function padStart(input, n2 = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n2, "0");
  } else {
    padded = ("" + input).padStart(n2, "0");
  }
  return padded;
}
function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseInt(string, 10);
  }
}
function parseFloating(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseFloat(string);
  }
}
function parseMillis(fraction) {
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f2 = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f2);
  }
}
function roundTo(number, digits, rounding = "round") {
  const factor = 10 ** digits;
  switch (rounding) {
    case "expand":
      return number > 0 ? Math.ceil(number * factor) / factor : Math.floor(number * factor) / factor;
    case "trunc":
      return Math.trunc(number * factor) / factor;
    case "round":
      return Math.round(number * factor) / factor;
    case "floor":
      return Math.floor(number * factor) / factor;
    case "ceil":
      return Math.ceil(number * factor) / factor;
    default:
      throw new RangeError(`Value rounding ${rounding} is out of range`);
  }
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
  }
  return +d;
}
function firstWeekOffset(year, minDaysInFirstWeek, startOfWeek) {
  const fwdlw = isoWeekdayToLocal(dayOfWeek(year, 1, minDaysInFirstWeek), startOfWeek);
  return -fwdlw + minDaysInFirstWeek - 1;
}
function weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
  const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
  return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else
    return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
}
function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date = new Date(ts), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = { timeZoneName: offsetFormat, ...intlOpts };
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || !Number.isFinite(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty(obj, u)) {
      const v = obj[u];
      if (v === void 0 || v === null)
        continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}
function formatOffset(offset2, format) {
  const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
  switch (format) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}
var monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
var weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
var meridiems = ["AM", "PM"];
var erasLong = ["Before Christ", "Anno Domini"];
var erasShort = ["BC", "AD"];
var erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
    }
  }
  const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}
function stringifyTokens(splits, tokenToString) {
  let s2 = "";
  for (const token of splits) {
    if (token.literal) {
      s2 += token.val;
    } else {
      s2 += tokenToString(token.val);
    }
  }
  return s2;
}
var macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
var Formatter = class {
  static create(locale, opts = {}) {
    return new Formatter(locale, opts);
  }
  static parseFormat(fmt) {
    let current = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt.length; i++) {
      const c = fmt.charAt(i);
      if (c === "'") {
        if (currentFull.length > 0 || bracketed) {
          splits.push({
            literal: bracketed || /^\s+$/.test(currentFull),
            val: currentFull === "" ? "'" : currentFull
          });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
        }
        currentFull = c;
        current = c;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  dtFormatter(dt, opts = {}) {
    return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
  }
  formatDateTime(dt, opts) {
    return this.dtFormatter(dt, opts).format();
  }
  formatDateTimeParts(dt, opts) {
    return this.dtFormatter(dt, opts).formatToParts();
  }
  formatInterval(interval, opts) {
    const df = this.dtFormatter(interval.start, opts);
    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
  }
  resolvedOptions(dt, opts) {
    return this.dtFormatter(dt, opts).resolvedOptions();
  }
  num(n2, p = 0, signDisplay = void 0) {
    if (this.opts.forceSimple) {
      return padStart(n2, p);
    }
    const opts = { ...this.opts };
    if (p > 0) {
      opts.padTo = p;
    }
    if (signDisplay) {
      opts.signDisplay = signDisplay;
    }
    return this.loc.numberFormatter(opts).format(n2);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(
      standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
      "weekday"
    ), maybeMacro = (token) => {
      const formatOpts = Formatter.macroTokenToFormatOpts(token);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"), tokenToString = (token) => {
      switch (token) {
        case "S":
          return this.num(dt.millisecond);
        case "u":
        case "SSS":
          return this.num(dt.millisecond, 3);
        case "s":
          return this.num(dt.second);
        case "ss":
          return this.num(dt.second, 2);
        case "uu":
          return this.num(Math.floor(dt.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt.millisecond / 100));
        case "m":
          return this.num(dt.minute);
        case "mm":
          return this.num(dt.minute, 2);
        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
        case "H":
          return this.num(dt.hour);
        case "HH":
          return this.num(dt.hour, 2);
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return dt.zoneName;
        case "a":
          return meridiem();
        case "d":
          return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
        case "dd":
          return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
        case "c":
          return this.num(dt.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        case "E":
          return this.num(dt.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        case "L":
          return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
        case "LL":
          return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        case "M":
          return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
        case "MM":
          return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        case "y":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
        case "yy":
          return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt.weekYear, 4);
        case "W":
          return this.num(dt.weekNumber);
        case "WW":
          return this.num(dt.weekNumber, 2);
        case "n":
          return this.num(dt.localWeekNumber);
        case "nn":
          return this.num(dt.localWeekNumber, 2);
        case "ii":
          return this.num(dt.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(dt.localWeekYear, 4);
        case "o":
          return this.num(dt.ordinal);
        case "ooo":
          return this.num(dt.ordinal, 3);
        case "q":
          return this.num(dt.quarter);
        case "qq":
          return this.num(dt.quarter, 2);
        case "X":
          return this.num(Math.floor(dt.ts / 1e3));
        case "x":
          return this.num(dt.ts);
        default:
          return maybeMacro(token);
      }
    };
    return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const invertLargest = this.opts.signMode === "negativeLargestOnly" ? -1 : 1;
    const tokenToField = (token) => {
      switch (token[0]) {
        case "S":
          return "milliseconds";
        case "s":
          return "seconds";
        case "m":
          return "minutes";
        case "h":
          return "hours";
        case "d":
          return "days";
        case "w":
          return "weeks";
        case "M":
          return "months";
        case "y":
          return "years";
        default:
          return null;
      }
    }, tokenToString = (lildur, info) => (token) => {
      const mapped = tokenToField(token);
      if (mapped) {
        const inversionFactor = info.isNegativeDuration && mapped !== info.largestUnit ? invertLargest : 1;
        let signDisplay;
        if (this.opts.signMode === "negativeLargestOnly" && mapped !== info.largestUnit) {
          signDisplay = "never";
        } else if (this.opts.signMode === "all") {
          signDisplay = "always";
        } else {
          signDisplay = "auto";
        }
        return this.num(lildur.get(mapped) * inversionFactor, token.length, signDisplay);
      } else {
        return token;
      }
    }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce(
      (found, { literal, val }) => literal ? found : found.concat(val),
      []
    ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t)), durationInfo = {
      isNegativeDuration: collapsed < 0,
      // this relies on "collapsed" being based on "shiftTo", which builds up the object
      // in order
      largestUnit: Object.keys(collapsed.values)[0]
    };
    return stringifyTokens(tokens, tokenToString(collapsed, durationInfo));
  }
};
var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes(...regexes) {
  const full = regexes.reduce((f2, r) => f2 + r.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return (m) => extractors.reduce(
    ([mergedVals, mergedZone, cursor], ex) => {
      const [val, zone, next] = ex(m, cursor);
      return [{ ...mergedVals, ...val }, zone || mergedZone, next];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function parse(s2, ...patterns) {
  if (s2 == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s2);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
}
function simpleParse(...keys) {
  return (match2, cursor) => {
    const ret = {};
    let i;
    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match2[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}
var offsetRegex = /(?:([Zz])|([+-]\d\d)(?::?(\d\d))?)/;
var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
var isoTimeExtensionRegex = RegExp(`(?:[Tt]${isoTimeRegex.source})?`);
var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
var extractISOOrdinalData = simpleParse("year", "ordinal");
var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
var sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match2, pos, fallback) {
  const m = match2[pos];
  return isUndefined(m) ? fallback : parseInteger(m);
}
function extractISOYmd(match2, cursor) {
  const item = {
    year: int(match2, cursor),
    month: int(match2, cursor + 1, 1),
    day: int(match2, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match2, cursor) {
  const item = {
    hours: int(match2, cursor, 0),
    minutes: int(match2, cursor + 1, 0),
    seconds: int(match2, cursor + 2, 0),
    milliseconds: parseMillis(match2[cursor + 3])
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match2, cursor) {
  const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match2, cursor) {
  const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
  return [{}, zone, cursor + 1];
}
var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match2) {
  const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
  const hasNegativePrefix = s2[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
}
var obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr)
    result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match2) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset2;
  if (obsOffset) {
    offset2 = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset2 = 0;
  } else {
    offset2 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset2)];
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match2) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match2) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
var extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseISODate(s2) {
  return parse(
    s2,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}
function parseRFC2822Date(s2) {
  return parse(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s2) {
  return parse(
    s2,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}
function parseISODuration(s2) {
  return parse(s2, [isoDuration, extractISODuration]);
}
var extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s2) {
  return parse(s2, [isoTimeOnly, extractISOTimeOnly]);
}
var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
var extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseSQL(s2) {
  return parse(
    s2,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}
var INVALID$2 = "Invalid Duration";
var lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
};
var casualMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var daysInYearAccurate = 146097 / 400;
var daysInMonthAccurate = 146097 / 4800;
var accurateMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var orderedUnits$1 = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
var reverseUnits = orderedUnits$1.slice(0).reverse();
function clone$1(dur, alts, clear = false) {
  const conf = {
    values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
}
function durationToMillis(matrix, vals) {
  var _a2;
  let sum = (_a2 = vals.milliseconds) != null ? _a2 : 0;
  for (const unit of reverseUnits.slice(1)) {
    if (vals[unit]) {
      sum += vals[unit] * matrix[unit]["milliseconds"];
    }
  }
  return sum;
}
function normalizeValues(matrix, vals) {
  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
  orderedUnits$1.reduceRight((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const previousVal = vals[previous] * factor;
        const conv = matrix[current][previous];
        const rollUp = Math.floor(previousVal / conv);
        vals[current] += rollUp * factor;
        vals[previous] -= rollUp * conv * factor;
      }
      return current;
    } else {
      return previous;
    }
  }, null);
  orderedUnits$1.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const fraction = vals[previous] % 1;
        vals[previous] -= fraction;
        vals[current] += fraction * matrix[previous][current];
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
}
var Duration = class {
  /**
   * @private
   */
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config.matrix) {
      matrix = config.matrix;
    }
    this.values = config.values;
    this.loc = config.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config.invalid || null;
    this.matrix = matrix;
    this.isLuxonDuration = true;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count, opts) {
    return Duration.fromObject({ milliseconds: count }, opts);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
      );
    }
    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text, opts) {
    const [parsed] = parseISODuration(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text, opts) {
    const [parsed] = parseISOTimeOnly(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({ invalid });
    }
  }
  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized)
      throw new InvalidUnitError(unit);
    return normalized;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o) {
    return o && o.isLuxonDuration || false;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @param {'negative'|'all'|'negativeLargestOnly'} [opts.signMode=negative] - How to handle signs
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @example Duration.fromObject({ days: 6, seconds: 2 }).toFormat("d s", { signMode: "all" }) //=> "+6 +2"
   * @example Duration.fromObject({ days: -6, seconds: -2 }).toFormat("d s", { signMode: "all" }) //=> "-6 -2"
   * @example Duration.fromObject({ days: -6, seconds: -2 }).toFormat("d s", { signMode: "negativeLargestOnly" }) //=> "-6 2"
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @param {boolean} [opts.showZeros=true] - Show all units previously used by the duration even if they are zero
   * @example
   * ```js
   * var dur = Duration.fromObject({ months: 1, weeks: 0, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 month, 0 weeks, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 month, 0 weeks, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 mth, 0 wks, 5 hr, 6 min'
   * dur.toHuman({ showZeros: false }) //=> '1 month, 5 hours, 6 minutes'
   * ```
   */
  toHuman(opts = {}) {
    if (!this.isValid)
      return INVALID$2;
    const showZeros = opts.showZeros !== false;
    const l2 = orderedUnits$1.map((unit) => {
      const val = this.values[unit];
      if (isUndefined(val) || val === 0 && !showZeros) {
        return null;
      }
      return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
    }).filter((n2) => n2);
    return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l2);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid)
      return {};
    return { ...this.values };
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid)
      return null;
    let s2 = "P";
    if (this.years !== 0)
      s2 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0)
      s2 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0)
      s2 += this.weeks + "W";
    if (this.days !== 0)
      s2 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s2 += "T";
    if (this.hours !== 0)
      s2 += this.hours + "H";
    if (this.minutes !== 0)
      s2 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s2 === "P")
      s2 += "T0S";
    return s2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid)
      return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5)
      return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts,
      includeOffset: false
    };
    const dateTime = DateTime.fromMillis(millis, { zone: "UTC" });
    return dateTime.toISOTime(opts);
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Duration { values: ${JSON.stringify(this.values)} }`;
    } else {
      return `Duration { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    if (!this.isValid)
      return NaN;
    return durationToMillis(this.matrix, this.values);
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration), result = {};
    for (const k of orderedUnits$1) {
      if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }
    return clone$1(this, { values: result }, true);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn) {
    if (!this.isValid)
      return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn(this.values[k], k));
    }
    return clone$1(this, { values: result }, true);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values) {
    if (!this.isValid)
      return this;
    const mixed = { ...this.values, ...normalizeObject(values, Duration.normalizeUnit) };
    return clone$1(this, { values: mixed });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone$1(this, opts);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid)
      return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone$1(this, { values: vals }, true);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid)
      return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone$1(this, { values: vals }, true);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid)
      return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u) => Duration.normalizeUnit(u));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k of orderedUnits$1) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0;
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }
        if (isNumber(vals[k])) {
          own += vals[k];
        }
        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    normalizeValues(this.matrix, built);
    return clone$1(this, { values: built }, true);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    if (!this.isValid)
      return this;
    return this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    );
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid)
      return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone$1(this, { values: negated }, true);
  }
  /**
   * Removes all units with values equal to 0 from this Duration.
   * @example Duration.fromObject({ years: 2, days: 0, hours: 0, minutes: 0 }).removeZeros().toObject() //=> { years: 2 }
   * @return {Duration}
   */
  removeZeros() {
    if (!this.isValid)
      return this;
    const vals = removeZeroes(this.values);
    return clone$1(this, { values: vals }, true);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v2) {
      if (v1 === void 0 || v1 === 0)
        return v2 === void 0 || v2 === 0;
      return v1 === v2;
    }
    for (const u of orderedUnits$1) {
      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
};
var INVALID$1 = "Invalid Interval";
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
    );
  } else {
    return null;
  }
}
var Interval = class {
  /**
   * @private
   */
  constructor(config) {
    this.s = config.start;
    this.e = config.end;
    this.invalid = config.invalid || null;
    this.isLuxonInterval = true;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new Interval({ invalid });
    }
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
    return Interval.fromDateTimes(dt, dt.plus(dur));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
    return Interval.fromDateTimes(dt.minus(dur), dt);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text, opts) {
    const [s2, e] = (text || "").split("/", 2);
    if (s2 && e) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s2, opts);
        startIsValid = start.isValid;
      } catch (e2) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e2) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return Interval.fromDateTimes(start, end);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e, opts);
        if (dur.isValid) {
          return Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s2, opts);
        if (dur.isValid) {
          return Interval.before(end, dur);
        }
      }
    }
    return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o) {
    return o && o.isLuxonInterval || false;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval. This is the first instant which is not part of the interval
   * (Interval is half-open).
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns the last DateTime included in the interval (since end is not part of the interval)
   * @type {DateTime}
   */
  get lastDateTime() {
    return this.isValid ? this.e ? this.e.minus(1) : null : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
   * @return {number}
   */
  count(unit = "milliseconds", opts) {
    if (!this.isValid)
      return NaN;
    const start = this.start.startOf(unit, opts);
    let end;
    if (opts == null ? void 0 : opts.useLocaleWeeks) {
      end = this.end.reconfigure({ locale: start.locale });
    } else {
      end = this.end;
    }
    end = end.startOf(unit, opts);
    return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid)
      return false;
    return this.s > dateTime;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid)
      return false;
    return this.e <= dateTime;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid)
      return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start, end } = {}) {
    if (!this.isValid)
      return this;
    return Interval.fromDateTimes(start || this.s, end || this.e);
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid)
      return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort((a, b) => a.toMillis() - b.toMillis()), results = [];
    let { s: s2 } = this, i = 0;
    while (s2 < this.e) {
      const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      i += 1;
    }
    return results;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration) {
    const dur = Duration.fromDurationLike(duration);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s2 } = this, idx = 1, next;
    const results = [];
    while (s2 < this.e) {
      const added = this.start.plus(dur.mapUnits((x) => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(Interval.fromDateTimes(s2, next));
      s2 = next;
      idx += 1;
    }
    return results;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid)
      return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid)
      return false;
    return +this.e === +other.s;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid)
      return false;
    return +other.e === +this.s;
  }
  /**
   * Returns true if this Interval fully contains the specified Interval, specifically if the intersect (of this Interval and the other Interval) is equal to the other Interval; false otherwise.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid)
      return false;
    return this.s <= other.s && this.e >= other.e;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
    if (s2 >= e) {
      return null;
    } else {
      return Interval.fromDateTimes(s2, e);
    }
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
    return Interval.fromDateTimes(s2, e);
  }
  /**
   * Merge an array of Intervals into an equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * The resulting array will contain the Intervals in ascending order, that is, starting with the earliest Interval
   * and ending with the latest.
   *
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(
      ([sofar, current], item) => {
        if (!current) {
          return [sofar, item];
        } else if (current.overlaps(item) || current.abutsStart(item)) {
          return [sofar, current.union(item)];
        } else {
          return [sofar.concat([current]), item];
        }
      },
      [[], null]
    );
    if (final) {
      found.push(final);
    }
    return found;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start = null, currentCount = 0;
    const results = [], ends = intervals.map((i) => [
      { time: i.s, type: "s" },
      { time: i.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(Interval.fromDateTimes(start, i.time));
        }
        start = null;
      }
    }
    return Interval.merge(results);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid)
      return INVALID$1;
    return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
  }
  /**
   * Returns a string representation of this Interval appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
    } else {
      return `Interval { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid)
      return INVALID$1;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid)
      return INVALID$1;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid)
      return INVALID$1;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  '  '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(dateFormat, { separator = " \u2013 " } = {}) {
    if (!this.isValid)
      return INVALID$1;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
};
var Info = class {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  /**
   * Get the weekday on which the week starts according to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
   */
  static getStartOfWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getStartOfWeek();
  }
  /**
   * Get the minimum number of days necessary in a week before it is considered part of the next year according
   * to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number}
   */
  static getMinimumDaysInFirstWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getMinDaysInFirstWeek();
  }
  /**
   * Get the weekdays, which are considered the weekend according to the given locale
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
   */
  static getWeekendWeekdays({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getWeekendDays().slice();
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
   * @return {Array}
   */
  static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
   * @return {Array}
   */
  static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
   * @return {Array}
   */
  static meridiems({ locale = null } = {}) {
    return Locale.create(locale).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
   * @return {Array}
   */
  static eras(length = "short", { locale = null } = {}) {
    return Locale.create(locale, null, "gregory").eras(length);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
   * @example Info.features() //=> { relative: false, localeWeek: true }
   * @return {Object}
   */
  static features() {
    return { relative: hasRelative(), localeWeek: hasLocaleWeekInfo() };
  }
};
function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a, b) => b.year - a.year],
    ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
    ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
    [
      "weeks",
      (a, b) => {
        const days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  const earlier = cursor;
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      results[unit] = differ(cursor, later);
      highWater = earlier.plus(results);
      if (highWater > later) {
        results[unit]--;
        cursor = earlier.plus(results);
        if (cursor > later) {
          highWater = cursor;
          results[unit]--;
          cursor = earlier.plus(results);
        }
      } else {
        cursor = highWater;
      }
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter(
    (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
  );
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}
var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = (i) => i) {
  return { regex, deser: ([s2]) => post(parseDigits(s2)) };
}
var NBSP = String.fromCharCode(160);
var spaceOrNBSP = `[ ${NBSP}]`;
var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s2) {
  return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s2) {
  return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
    };
  }
}
function offset(regex, groups) {
  return { regex, deser: ([, h, m]) => signedOffset(h, m), groups };
}
function simple(regex) {
  return { regex, deser: ([s2]) => s2 };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
  const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s2]) => s2, literal: true }), unitate = (t) => {
    if (token.literal) {
      return literal(t);
    }
    switch (t.val) {
      case "G":
        return oneOf(loc.eras("short"), 0);
      case "GG":
        return oneOf(loc.eras("long"), 0);
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true), 1);
      case "MMMM":
        return oneOf(loc.months("long", true), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false), 1);
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one);
      case "a":
        return oneOf(loc.meridiems(), 0);
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear);
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      case "E":
      case "c":
        return intUnit(one);
      case "EEE":
        return oneOf(loc.weekdays("short", false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true), 1);
      case "Z":
      case "ZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      case " ":
        return simple(/[^\S\n\r]/);
      default:
        return literal(t);
    }
  };
  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}
var partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, formatOpts, resolvedOpts) {
  const { type: type2, value } = part;
  if (type2 === "literal") {
    const isSpace = /^\s+$/.test(value);
    return {
      literal: !isSpace,
      val: isSpace ? " " : value
    };
  }
  const style = formatOpts[type2];
  let actualType = type2;
  if (type2 === "hour") {
    if (formatOpts.hour12 != null) {
      actualType = formatOpts.hour12 ? "hour12" : "hour24";
    } else if (formatOpts.hourCycle != null) {
      if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
        actualType = "hour12";
      } else {
        actualType = "hour24";
      }
    } else {
      actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
    }
  }
  let val = partTypeStyleToTokenVal[actualType];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re = units.map((u) => u.regex).reduce((f2, r) => `${f2}(${r.source})`, "");
  return [`^${re}$`, units];
}
function match(input, regex, handlers) {
  const matches = input.match(regex);
  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (hasOwnProperty(handlers, i)) {
        const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r, k) => {
    const f2 = toField(k);
    if (f2) {
      r[f2] = matches[k];
    }
    return r;
  }, {});
  return [vals, zone, specificOffset];
}
var dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);
  if (tokens == null || tokens.includes(void 0)) {
    return token;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));
}
var TokenParser = class {
  constructor(locale, format) {
    this.locale = locale;
    this.format = format;
    this.tokens = expandMacroTokens(Formatter.parseFormat(format), locale);
    this.units = this.tokens.map((t) => unitForToken(t, locale));
    this.disqualifyingUnit = this.units.find((t) => t.invalidReason);
    if (!this.disqualifyingUnit) {
      const [regexString, handlers] = buildRegex(this.units);
      this.regex = RegExp(regexString, "i");
      this.handlers = handlers;
    }
  }
  explainFromTokens(input) {
    if (!this.isValid) {
      return { input, tokens: this.tokens, invalidReason: this.invalidReason };
    } else {
      const [rawMatches, matches] = match(input, this.regex, this.handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
      if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
        throw new ConflictingSpecificationError(
          "Can't include meridiem when specifying 24-hour format"
        );
      }
      return {
        input,
        tokens: this.tokens,
        regex: this.regex,
        rawMatches,
        matches,
        result,
        zone,
        specificOffset
      };
    }
  }
  get isValid() {
    return !this.disqualifyingUnit;
  }
  get invalidReason() {
    return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;
  }
};
function explainFromTokens(locale, input, format) {
  const parser = new TokenParser(locale, format);
  return parser.explainFromTokens(input);
}
function parseFromTokens(locale, input, format) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
  return [result, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter.create(locale, formatOpts);
  const df = formatter.dtFormatter(getDummyDateTime());
  const parts = df.formatToParts();
  const resolvedOpts = df.resolvedOptions();
  return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));
}
var INVALID = "Invalid DateTime";
var MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}
function possiblyCachedLocalWeekData(dt) {
  if (dt.localWeekData === null) {
    dt.localWeekData = gregorianToWeek(
      dt.c,
      dt.loc.getMinDaysInFirstWeek(),
      dt.loc.getStartOfWeek()
    );
  }
  return dt.localWeekData;
}
function clone(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({ ...current, ...alts, old: current });
}
function fixOffset(localTS, o, tz) {
  let utcGuess = localTS - o * 60 * 1e3;
  const o2 = tz.offset(utcGuess);
  if (o === o2) {
    return [utcGuess, o];
  }
  utcGuess -= (o2 - o) * 60 * 1e3;
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }
  return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
}
function tsToObj(ts, offset2) {
  ts += offset2 * 60 * 1e3;
  const d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
}
function objToTS(obj, offset2, zone) {
  return fixOffset(objToLocalTS(obj), offset2, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
    ...inst.c,
    year,
    month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }, millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c);
  let [ts, o] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o = inst.zone.offset(ts);
  }
  return { ts, o };
}
function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
    const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
      ...opts,
      zone: interpretationZone,
      specificOffset
    });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`)
    );
  }
}
function toTechFormat(dt, format, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
}
function toISODate(o, extended, precision) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0)
    c += "+";
  c += padStart(o.c.year, longFormat ? 6 : 4);
  if (precision === "year")
    return c;
  if (extended) {
    c += "-";
    c += padStart(o.c.month);
    if (precision === "month")
      return c;
    c += "-";
  } else {
    c += padStart(o.c.month);
    if (precision === "month")
      return c;
  }
  c += padStart(o.c.day);
  return c;
}
function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone, precision) {
  let showSeconds = !suppressSeconds || o.c.millisecond !== 0 || o.c.second !== 0, c = "";
  switch (precision) {
    case "day":
    case "month":
    case "year":
      break;
    default:
      c += padStart(o.c.hour);
      if (precision === "hour")
        break;
      if (extended) {
        c += ":";
        c += padStart(o.c.minute);
        if (precision === "minute")
          break;
        if (showSeconds) {
          c += ":";
          c += padStart(o.c.second);
        }
      } else {
        c += padStart(o.c.minute);
        if (precision === "minute")
          break;
        if (showSeconds) {
          c += padStart(o.c.second);
        }
      }
      if (precision === "second")
        break;
      if (showSeconds && (!suppressMilliseconds || o.c.millisecond !== 0)) {
        c += ".";
        c += padStart(o.c.millisecond, 3);
      }
  }
  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += padStart(Math.trunc(-o.o / 60));
      c += ":";
      c += padStart(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += padStart(Math.trunc(o.o / 60));
      c += ":";
      c += padStart(Math.trunc(o.o % 60));
    }
  }
  if (extendedZone) {
    c += "[" + o.zone.ianaName + "]";
  }
  return c;
}
var defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized)
    throw new InvalidUnitError(unit);
  return normalized;
}
function normalizeUnitWithLocalWeeks(unit) {
  switch (unit.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return normalizeUnit(unit);
  }
}
function guessOffsetForZone(zone) {
  if (zoneOffsetTs === void 0) {
    zoneOffsetTs = Settings.now();
  }
  if (zone.type !== "iana") {
    return zone.offset(zoneOffsetTs);
  }
  const zoneName = zone.name;
  let offsetGuess = zoneOffsetGuessCache.get(zoneName);
  if (offsetGuess === void 0) {
    offsetGuess = zone.offset(zoneOffsetTs);
    zoneOffsetGuessCache.set(zoneName, offsetGuess);
  }
  return offsetGuess;
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone);
  if (!zone.isValid) {
    return DateTime.invalid(unsupportedZone(zone));
  }
  const loc = Locale.fromObject(opts);
  let ts, o;
  if (!isUndefined(obj.year)) {
    for (const u of orderedUnits) {
      if (isUndefined(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = guessOffsetForZone(zone);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = Settings.now();
  }
  return new DateTime({ ts, zone, loc, o });
}
function diffRelative(start, end, opts) {
  const round = isUndefined(opts.round) ? true : opts.round, rounding = isUndefined(opts.rounding) ? "trunc" : opts.rounding, format = (c, unit) => {
    c = roundTo(c, round || opts.calendary ? 0 : 2, opts.calendary ? "round" : rounding);
    const formatter = end.loc.clone(opts).relFormatter(opts);
    return formatter.format(c, unit);
  }, differ = (unit) => {
    if (opts.calendary) {
      if (!end.hasSame(start, unit)) {
        return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
      } else
        return 0;
    } else {
      return end.diff(start, unit).get(unit);
    }
  };
  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
var zoneOffsetTs;
var zoneOffsetGuessCache = /* @__PURE__ */ new Map();
var DateTime = class {
  /**
   * @access private
   */
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;
    let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
    let c = null, o = null;
    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
      if (unchanged) {
        [c, o] = [config.old.c, config.old.o];
      } else {
        const ot = isNumber(config.o) && !config.old ? config.o : zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }
    this._zone = zone;
    this.loc = config.loc || Locale.create();
    this.invalid = invalid;
    this.weekData = null;
    this.localWeekData = null;
    this.c = c;
    this.o = o;
    this.isLuxonDateTime = true;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new DateTime({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [options.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date, options = {}) {
    const ts = isDate(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
      );
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds, options = {}) {
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({
        ts: seconds * 1e3,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.localWeekYear - a week year, according to the locale
   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const loc = Locale.fromObject(opts);
    const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, loc);
    const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
      );
    }
    if (!inst.isValid) {
      return DateTime.invalid(inst.invalid);
    }
    return inst;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [opts.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text, opts = {}) {
    const [vals, parsedZone] = parseISODate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text, fmt, opts = {}) {
    if (isUndefined(text) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
    if (invalid) {
      return DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
    }
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text, fmt, opts = {}) {
    return DateTime.fromFormat(text, fmt, opts);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text, opts = {}) {
    const [vals, parsedZone] = parseSQL(text);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new DateTime({ invalid });
    }
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map((t) => t.val).join("");
  }
  static resetCache() {
    zoneOffsetTs = void 0;
    zoneOffsetGuessCache.clear();
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit) {
    return this[unit];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  /**
   * Returns true if this date is on a weekend according to the locale, false otherwise
   * @returns {boolean}
   */
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  /**
   * Get the day of the week according to the locale.
   * 1 is the first day of the week and 7 is the last day of the week.
   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
   * @returns {number}
   */
  get localWeekday() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
  }
  /**
   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
   * because the week can start on different days of the week (see localWeekday) and because a different number of days
   * is required for a week to count as the first week of a year.
   * @returns {number}
   */
  get localWeekNumber() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
   * differently, see localWeekNumber.
   * @returns {number}
   */
  get localWeekYear() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed) {
      return [this];
    }
    const dayMs = 864e5;
    const minuteMs = 6e4;
    const localTS = objToLocalTS(this.c);
    const oEarlier = this.zone.offset(localTS - dayMs);
    const oLater = this.zone.offset(localTS + dayMs);
    const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
    const o2 = this.zone.offset(localTS - oLater * minuteMs);
    if (o1 === o2) {
      return [this];
    }
    const ts1 = localTS - o1 * minuteMs;
    const ts2 = localTS - o2 * minuteMs;
    const c1 = tsToObj(ts1, o1);
    const c2 = tsToObj(ts2, o2);
    if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
      return [clone(this, { ts: ts1 }), clone(this, { ts: ts2 })];
    }
    return [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's local week year
   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
   * @type {number}
   */
  get weeksInLocalWeekYear() {
    return this.isValid ? weeksInWeekYear(
      this.localWeekYear,
      this.loc.getMinDaysInFirstWeek(),
      this.loc.getStartOfWeek()
    ) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset2 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset2), opts);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone(this, { ts: newTS, zone });
    }
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone(this, { loc });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale) {
    return this.reconfigure({ locale });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   *
   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
   * They cannot be mixed with ISO-week units like `weekday`.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values) {
    if (!this.isValid)
      return this;
    const normalized = normalizeObject(values, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, this.loc);
    const settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian(
        { ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek), ...normalized },
        minDaysInFirstWeek,
        startOfWeek
      );
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
    } else {
      mixed = { ...this.toObject(), ...normalized };
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone(this, { ts, o });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration);
    return clone(this, adjustTime(this, dur));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration).negate();
    return clone(this, adjustTime(this, dur));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit, { useLocaleWeeks = false } = {}) {
    if (!this.isValid)
      return this;
    const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      case "quarters":
      case "months":
        o.day = 1;
      case "weeks":
      case "days":
        o.hour = 0;
      case "hours":
        o.minute = 0;
      case "minutes":
        o.second = 0;
      case "seconds":
        o.millisecond = 0;
        break;
    }
    if (normalizedUnit === "weeks") {
      if (useLocaleWeeks) {
        const startOfWeek = this.loc.getStartOfWeek();
        const { weekday } = this;
        if (weekday < startOfWeek) {
          o.weekNumber = this.weekNumber - 1;
        }
        o.weekday = startOfWeek;
      } else {
        o.weekday = 1;
      }
    }
    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }
    return this.set(o);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit, opts) {
    return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit, opts).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @param {string} [opts.precision='milliseconds'] - truncate output to desired presicion: 'years', 'months', 'days', 'hours', 'minutes', 'seconds' or 'milliseconds'. When precision and suppressSeconds or suppressMilliseconds are used together, precision sets the maximum unit shown in the output, however seconds or milliseconds will still be suppressed if they are 0.
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @example DateTime.now().toISO({ precision: 'day' }) //=> '2017-04-22Z'
   * @example DateTime.now().toISO({ precision: 'minute' }) //=> '2017-04-22T20:47Z'
   * @return {string|null}
   */
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false,
    precision = "milliseconds"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    precision = normalizeUnit(precision);
    const ext = format === "extended";
    let c = toISODate(this, ext, precision);
    if (orderedUnits.indexOf(precision) >= 3)
      c += "T";
    c += toISOTime(
      this,
      ext,
      suppressSeconds,
      suppressMilliseconds,
      includeOffset,
      extendedZone,
      precision
    );
    return c;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @param {string} [opts.precision='day'] - truncate output to desired precision: 'years', 'months', or 'days'.
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @example DateTime.utc(1982, 5, 25).toISODate({ precision: 'month' }) //=> '1982-05'
   * @return {string|null}
   */
  toISODate({ format = "extended", precision = "day" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format === "extended", normalizeUnit(precision));
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @param {string} [opts.precision='milliseconds'] - truncate output to desired presicion: 'hours', 'minutes', 'seconds' or 'milliseconds'. When precision and suppressSeconds or suppressMilliseconds are used together, precision sets the maximum unit shown in the output, however seconds or milliseconds will still be suppressed if they are 0.
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, second: 56 }).toISOTime({ precision: 'minute' }) //=> '07:34Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format = "extended",
    precision = "milliseconds"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    precision = normalizeUnit(precision);
    let c = includePrefix && orderedUnits.indexOf(precision) >= 3 ? "T" : "";
    return c + toISOTime(
      this,
      format === "extended",
      suppressSeconds,
      suppressMilliseconds,
      includeOffset,
      extendedZone,
      precision
    );
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string|null}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID;
  }
  /**
   * Returns a string representation of this DateTime appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
    } else {
      return `DateTime { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds (including milliseconds in the fractional part) of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid)
      return {};
    const base = { ...this.c };
    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
    const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(DateTime.now(), unit, opts);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval|DateTime}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit, opts) {
    if (!this.isValid)
      return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds towards zero by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {string} [options.rounding="trunc"] - rounding method to use when rounding the numbers in the output. Can be "trunc" (toward zero), "expand" (away from zero), "round", "floor", or "ceil".
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options = {}) {
    if (!this.isValid)
      return null;
    const base = options.base || DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = void 0;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options = {}) {
    if (!this.isValid)
      return null;
    return diffRelative(options.base || DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text, fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text, fmt);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text, fmt, options = {}) {
    return DateTime.fromFormatExplain(text, fmt, options);
  }
  /**
   * Build a parser for `fmt` using the given locale. This parser can be passed
   * to {@link DateTime.fromFormatParser} to a parse a date in this format. This
   * can be used to optimize cases where many dates need to be parsed in a
   * specific format.
   *
   * @param {String} fmt - the format the string is expected to be in (see
   * description)
   * @param {Object} options - options used to set locale and numberingSystem
   * for parser
   * @returns {TokenParser} - opaque object to be used
   */
  static buildFormatParser(fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return new TokenParser(localeToUse, fmt);
  }
  /**
   * Create a DateTime from an input string and format parser.
   *
   * The format parser must have been created with the same locale as this call.
   *
   * @param {String} text - the string to parse
   * @param {TokenParser} formatParser - parser from {@link DateTime.buildFormatParser}
   * @param {Object} opts - options taken by fromFormat()
   * @returns {DateTime}
   */
  static fromFormatParser(text, formatParser, opts = {}) {
    if (isUndefined(text) || isUndefined(formatParser)) {
      throw new InvalidArgumentError(
        "fromFormatParser requires an input string and a format parser"
      );
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    if (!localeToUse.equals(formatParser.locale)) {
      throw new InvalidArgumentError(
        `fromFormatParser called with a locale of ${localeToUse}, but the format parser was created for ${formatParser.locale}`
      );
    }
    const { result, zone, specificOffset, invalidReason } = formatParser.explainFromTokens(text);
    if (invalidReason) {
      return DateTime.invalid(invalidReason);
    } else {
      return parseDataToDateTime(
        result,
        zone,
        opts,
        `format ${formatParser.format}`,
        text,
        specificOffset
      );
    }
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
};
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}

// src/features/file-outliner-view/view.ts
var import_state7 = require("@codemirror/state");
var import_view6 = require("@codemirror/view");

// src/features/file-outliner-view/engine.ts
function cloneBlock(b) {
  var _a2;
  return {
    id: b.id,
    depth: b.depth,
    text: b.text,
    children: b.children.map(cloneBlock),
    system: {
      date: b.system.date,
      updated: b.system.updated,
      extra: { ...(_a2 = b.system.extra) != null ? _a2 : {} }
    },
    _systemHasBlpMarker: b._systemHasBlpMarker
  };
}
function cloneFile(file) {
  var _a2;
  return {
    frontmatter: file.frontmatter,
    blocks: ((_a2 = file.blocks) != null ? _a2 : []).map(cloneBlock)
  };
}
function rebuildDepths(list, depth) {
  for (const b of list) {
    b.depth = depth;
    rebuildDepths(b.children, depth + 1);
  }
}
function findBlockLocation(list, id, parent) {
  for (let i = 0; i < list.length; i++) {
    const b = list[i];
    if (b.id === id)
      return { block: b, parent, siblings: list, index: i };
    const child = findBlockLocation(b.children, id, b);
    if (child)
      return child;
  }
  return null;
}
function collectIds(list, out) {
  for (const b of list) {
    if (b.id)
      out.add(b.id);
    collectIds(b.children, out);
  }
}
function ensureUniqueGeneratedId(ctx, existing) {
  for (let i = 0; i < 100; i++) {
    const id = ctx.generateId();
    if (!existing.has(id))
      return id;
  }
  while (true) {
    const id = Math.random().toString(36).slice(2, 10);
    if (!existing.has(id))
      return id;
  }
}
function normalizeSelection(sel, textLen) {
  const start = Math.max(0, Math.min(textLen, sel.start));
  const end = Math.max(0, Math.min(textLen, sel.end));
  return { ...sel, start, end };
}
function insertAfter(file, targetId, ctx) {
  const next = cloneFile(file);
  const dirtyIds = /* @__PURE__ */ new Set();
  const loc = findBlockLocation(next.blocks, targetId, null);
  if (!loc) {
    return { file, selection: { id: targetId, start: 0, end: 0 }, dirtyIds, didChange: false };
  }
  const existingIds = /* @__PURE__ */ new Set();
  collectIds(next.blocks, existingIds);
  const newId = ensureUniqueGeneratedId(ctx, existingIds);
  existingIds.add(newId);
  const newBlock = {
    id: newId,
    depth: 0,
    // rebuilt below
    text: "",
    children: [],
    system: { date: ctx.now, updated: ctx.now, extra: {} },
    _systemHasBlpMarker: true
  };
  loc.siblings.splice(loc.index + 1, 0, newBlock);
  dirtyIds.add(newId);
  rebuildDepths(next.blocks, 0);
  return {
    file: next,
    selection: { id: newId, start: 0, end: 0 },
    dirtyIds,
    didChange: true
  };
}
function insertAtRootEnd(file, ctx) {
  const next = cloneFile(file);
  const dirtyIds = /* @__PURE__ */ new Set();
  const existingIds = /* @__PURE__ */ new Set();
  collectIds(next.blocks, existingIds);
  const newId = ensureUniqueGeneratedId(ctx, existingIds);
  existingIds.add(newId);
  const newBlock = {
    id: newId,
    depth: 0,
    // rebuilt below
    text: "",
    children: [],
    system: { date: ctx.now, updated: ctx.now, extra: {} },
    _systemHasBlpMarker: true
  };
  next.blocks.push(newBlock);
  dirtyIds.add(newId);
  rebuildDepths(next.blocks, 0);
  return {
    file: next,
    selection: { id: newId, start: 0, end: 0 },
    dirtyIds,
    didChange: true
  };
}
function splitAtSelection(file, sel, ctx) {
  var _a2;
  const next = cloneFile(file);
  const dirtyIds = /* @__PURE__ */ new Set();
  const loc = findBlockLocation(next.blocks, sel.id, null);
  if (!loc) {
    return { file, selection: sel, dirtyIds, didChange: false };
  }
  const currentText = String((_a2 = loc.block.text) != null ? _a2 : "");
  const normSel = normalizeSelection(sel, currentText.length);
  const left = Math.min(normSel.start, normSel.end);
  const right = Math.max(normSel.start, normSel.end);
  const before = currentText.slice(0, left);
  const after = currentText.slice(right);
  loc.block.text = before;
  dirtyIds.add(loc.block.id);
  const moveChildren = ctx.childrenOnSplit === "move";
  const movedChildren = moveChildren ? loc.block.children : [];
  if (moveChildren)
    loc.block.children = [];
  const existingIds = /* @__PURE__ */ new Set();
  collectIds(next.blocks, existingIds);
  const newId = ensureUniqueGeneratedId(ctx, existingIds);
  const newBlock = {
    id: newId,
    depth: 0,
    // rebuilt below
    text: after,
    children: movedChildren,
    system: { date: ctx.now, updated: ctx.now, extra: {} },
    _systemHasBlpMarker: true
  };
  loc.siblings.splice(loc.index + 1, 0, newBlock);
  dirtyIds.add(newId);
  rebuildDepths(next.blocks, 0);
  return {
    file: next,
    selection: { id: newId, start: 0, end: 0 },
    dirtyIds,
    didChange: true
  };
}
function indentBlock(file, sel) {
  const next = cloneFile(file);
  const dirtyIds = /* @__PURE__ */ new Set();
  const loc = findBlockLocation(next.blocks, sel.id, null);
  if (!loc)
    return { file, selection: sel, dirtyIds, didChange: false };
  if (loc.index <= 0)
    return { file, selection: sel, dirtyIds, didChange: false };
  const prev = loc.siblings[loc.index - 1];
  if (!prev)
    return { file, selection: sel, dirtyIds, didChange: false };
  loc.siblings.splice(loc.index, 1);
  prev.children.push(loc.block);
  dirtyIds.add(loc.block.id);
  dirtyIds.add(prev.id);
  rebuildDepths(next.blocks, 0);
  return { file: next, selection: sel, dirtyIds, didChange: true };
}
function outdentBlock(file, sel) {
  const next = cloneFile(file);
  const dirtyIds = /* @__PURE__ */ new Set();
  const loc = findBlockLocation(next.blocks, sel.id, null);
  if (!loc || !loc.parent)
    return { file, selection: sel, dirtyIds, didChange: false };
  const parentLoc = findBlockLocation(next.blocks, loc.parent.id, null);
  if (!parentLoc)
    return { file, selection: sel, dirtyIds, didChange: false };
  loc.siblings.splice(loc.index, 1);
  parentLoc.siblings.splice(parentLoc.index + 1, 0, loc.block);
  dirtyIds.add(loc.block.id);
  dirtyIds.add(loc.parent.id);
  rebuildDepths(next.blocks, 0);
  return { file: next, selection: sel, dirtyIds, didChange: true };
}
function moveBlockSubtree(file, sourceId, targetId, where) {
  if (!sourceId || !targetId) {
    return { file, selection: { id: sourceId, start: 0, end: 0 }, dirtyIds: /* @__PURE__ */ new Set(), didChange: false };
  }
  if (sourceId === targetId) {
    return { file, selection: { id: sourceId, start: 0, end: 0 }, dirtyIds: /* @__PURE__ */ new Set(), didChange: false };
  }
  const next = cloneFile(file);
  const dirtyIds = /* @__PURE__ */ new Set();
  const src = findBlockLocation(next.blocks, sourceId, null);
  if (!src)
    return { file, selection: { id: sourceId, start: 0, end: 0 }, dirtyIds, didChange: false };
  const srcIds = /* @__PURE__ */ new Set();
  collectIds([src.block], srcIds);
  if (srcIds.has(targetId)) {
    return { file, selection: { id: sourceId, start: 0, end: 0 }, dirtyIds, didChange: false };
  }
  const tgt = findBlockLocation(next.blocks, targetId, null);
  if (!tgt)
    return { file, selection: { id: sourceId, start: 0, end: 0 }, dirtyIds, didChange: false };
  let destSiblings;
  let destIndex;
  let destParent;
  if (where === "inside") {
    destParent = tgt.block;
    destSiblings = tgt.block.children;
    destIndex = destSiblings.length;
  } else {
    destParent = tgt.parent;
    destSiblings = tgt.siblings;
    destIndex = tgt.index + (where === "after" ? 1 : 0);
  }
  if (destSiblings === src.siblings && destIndex > src.index) {
    destIndex -= 1;
  }
  if (destSiblings === src.siblings && destIndex === src.index) {
    return { file, selection: { id: sourceId, start: 0, end: 0 }, dirtyIds, didChange: false };
  }
  src.siblings.splice(src.index, 1);
  destSiblings.splice(Math.max(0, Math.min(destSiblings.length, destIndex)), 0, src.block);
  rebuildDepths(next.blocks, 0);
  dirtyIds.add(src.block.id);
  if (src.parent)
    dirtyIds.add(src.parent.id);
  if (destParent)
    dirtyIds.add(destParent.id);
  return { file: next, selection: { id: sourceId, start: 0, end: 0 }, dirtyIds, didChange: true };
}
function mergeWithPrevious(file, sel) {
  var _a2, _b2, _c2;
  const next = cloneFile(file);
  const dirtyIds = /* @__PURE__ */ new Set();
  const loc = findBlockLocation(next.blocks, sel.id, null);
  if (!loc)
    return { file, selection: sel, dirtyIds, didChange: false };
  if (loc.index <= 0)
    return { file, selection: sel, dirtyIds, didChange: false };
  const prev = loc.siblings[loc.index - 1];
  if (!prev)
    return { file, selection: sel, dirtyIds, didChange: false };
  const prevLen = String((_a2 = prev.text) != null ? _a2 : "").length;
  prev.text = String((_b2 = prev.text) != null ? _b2 : "") + String((_c2 = loc.block.text) != null ? _c2 : "");
  prev.children.push(...loc.block.children);
  loc.siblings.splice(loc.index, 1);
  dirtyIds.add(prev.id);
  rebuildDepths(next.blocks, 0);
  return {
    file: next,
    selection: { id: prev.id, start: prevLen, end: prevLen },
    dirtyIds,
    didChange: true
  };
}
function mergeWithNext(file, sel) {
  var _a2, _b2, _c2;
  const next = cloneFile(file);
  const dirtyIds = /* @__PURE__ */ new Set();
  const loc = findBlockLocation(next.blocks, sel.id, null);
  if (!loc)
    return { file, selection: sel, dirtyIds, didChange: false };
  if (loc.index >= loc.siblings.length - 1)
    return { file, selection: sel, dirtyIds, didChange: false };
  const nextSibling = loc.siblings[loc.index + 1];
  if (!nextSibling)
    return { file, selection: sel, dirtyIds, didChange: false };
  const curLen = String((_a2 = loc.block.text) != null ? _a2 : "").length;
  loc.block.text = String((_b2 = loc.block.text) != null ? _b2 : "") + String((_c2 = nextSibling.text) != null ? _c2 : "");
  loc.block.children.push(...nextSibling.children);
  loc.siblings.splice(loc.index + 1, 1);
  dirtyIds.add(loc.block.id);
  rebuildDepths(next.blocks, 0);
  return {
    file: next,
    selection: { id: loc.block.id, start: curLen, end: curLen },
    dirtyIds,
    didChange: true
  };
}
function deleteBlock(file, targetId, ctx) {
  var _a2, _b2, _c2;
  const next = cloneFile(file);
  const dirtyIds = /* @__PURE__ */ new Set();
  const loc = findBlockLocation(next.blocks, targetId, null);
  if (!loc) {
    return { file, selection: { id: targetId, start: 0, end: 0 }, dirtyIds, didChange: false };
  }
  const focusPref = [];
  const nextSibling = loc.siblings[loc.index + 1];
  if (nextSibling)
    focusPref.push({ kind: "next", block: nextSibling });
  const prevSibling = loc.siblings[loc.index - 1];
  if (prevSibling)
    focusPref.push({ kind: "prev", block: prevSibling });
  if (loc.parent)
    focusPref.push({ kind: "parent", block: loc.parent });
  loc.siblings.splice(loc.index, 1);
  if (((_b2 = (_a2 = next.blocks) == null ? void 0 : _a2.length) != null ? _b2 : 0) === 0) {
    const existingIds = /* @__PURE__ */ new Set();
    existingIds.add(targetId);
    const newId = ensureUniqueGeneratedId(ctx, existingIds);
    const newBlock = {
      id: newId,
      depth: 0,
      text: "",
      children: [],
      system: { date: ctx.now, updated: ctx.now, extra: {} },
      _systemHasBlpMarker: true
    };
    next.blocks = [newBlock];
    dirtyIds.add(newId);
    rebuildDepths(next.blocks, 0);
    return { file: next, selection: { id: newId, start: 0, end: 0 }, dirtyIds, didChange: true };
  }
  rebuildDepths(next.blocks, 0);
  const focus = focusPref[0];
  if (!focus) {
    const first = next.blocks[0];
    if (!first)
      return { file: next, selection: { id: targetId, start: 0, end: 0 }, dirtyIds, didChange: true };
    return { file: next, selection: { id: first.id, start: 0, end: 0 }, dirtyIds, didChange: true };
  }
  const focusText = String((_c2 = focus.block.text) != null ? _c2 : "");
  const cursor = focus.kind === "next" ? 0 : focusText.length;
  return { file: next, selection: { id: focus.block.id, start: cursor, end: cursor }, dirtyIds, didChange: true };
}
function backspaceAtStart(file, sel, ctx) {
  if (sel.start !== 0 || sel.end !== 0)
    return { file, selection: sel, dirtyIds: /* @__PURE__ */ new Set(), didChange: false };
  const loc = findBlockLocation(file.blocks, sel.id, null);
  if (!loc)
    return { file, selection: sel, dirtyIds: /* @__PURE__ */ new Set(), didChange: false };
  if (loc.block.children.length > 0 && ctx.backspaceWithChildren === "outdent") {
    const outdented = outdentBlock(file, sel);
    if (outdented.didChange)
      return outdented;
  }
  const merged = mergeWithPrevious(file, sel);
  if (merged.didChange)
    return merged;
  return outdentBlock(file, sel);
}
function pasteSplitLines(file, sel, rawText, ctx) {
  var _a2, _b2, _c2, _d2;
  const text = String(rawText != null ? rawText : "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  const lines = text.split("\n");
  if (lines.length <= 1)
    return { file, selection: sel, dirtyIds: /* @__PURE__ */ new Set(), didChange: false };
  const next = cloneFile(file);
  const dirtyIds = /* @__PURE__ */ new Set();
  const loc = findBlockLocation(next.blocks, sel.id, null);
  if (!loc)
    return { file, selection: sel, dirtyIds, didChange: false };
  const currentText = String((_a2 = loc.block.text) != null ? _a2 : "");
  const normSel = normalizeSelection(sel, currentText.length);
  const left = Math.min(normSel.start, normSel.end);
  const right = Math.max(normSel.start, normSel.end);
  const before = currentText.slice(0, left);
  const after = currentText.slice(right);
  loc.block.text = before + ((_b2 = lines[0]) != null ? _b2 : "");
  dirtyIds.add(loc.block.id);
  const existingIds = /* @__PURE__ */ new Set();
  collectIds(next.blocks, existingIds);
  let insertAt = loc.index + 1;
  let lastId = null;
  for (let i = 1; i < lines.length; i++) {
    const isLast = i === lines.length - 1;
    const newId = ensureUniqueGeneratedId(ctx, existingIds);
    existingIds.add(newId);
    const newBlock = {
      id: newId,
      depth: 0,
      // rebuilt below
      text: ((_c2 = lines[i]) != null ? _c2 : "") + (isLast ? after : ""),
      children: [],
      system: { date: ctx.now, updated: ctx.now, extra: {} },
      _systemHasBlpMarker: true
    };
    loc.siblings.splice(insertAt, 0, newBlock);
    insertAt++;
    dirtyIds.add(newId);
    lastId = newId;
  }
  rebuildDepths(next.blocks, 0);
  const focusId = lastId != null ? lastId : loc.block.id;
  const focusPos = ((_d2 = lines[lines.length - 1]) != null ? _d2 : "").length;
  return {
    file: next,
    selection: { id: focusId, start: focusPos, end: focusPos },
    dirtyIds,
    didChange: true
  };
}

// src/shared/markdown/indent-utils.ts
var MARKDOWN_TAB_WIDTH = 4;
function clampTabSize(raw, fallback = 4) {
  const n2 = typeof raw === "number" ? raw : Number.NaN;
  if (!Number.isFinite(n2) || n2 <= 0)
    return fallback;
  return Math.max(1, Math.floor(n2));
}
function leadingIndentText(text) {
  var _a2, _b2;
  return (_b2 = (_a2 = text.match(/^\s*/)) == null ? void 0 : _a2[0]) != null ? _b2 : "";
}
function expandIndentTabsToSpaces(indentText2, tabSize) {
  let col = 0;
  const ts = clampTabSize(tabSize, 4);
  let out = "";
  for (const ch of indentText2) {
    if (ch === "	") {
      const step = ts - col % ts;
      out += " ".repeat(step);
      col += step;
      continue;
    }
    out += ch;
    col += 1;
  }
  return out;
}
function normalizeLineLeadingIndentTabsToSpaces(text, tabSize) {
  const indent = leadingIndentText(text);
  if (!indent.includes("	"))
    return text;
  const normalizedIndent = expandIndentTabsToSpaces(indent, tabSize);
  return normalizedIndent + text.slice(indent.length);
}

// src/shared/markdown/list-parse.ts
var LIST_ITEM_PREFIX_RE = /^(\s*)(?:([-*+])|(\d+\.))\s+(?:\[(?: |x|X)\]\s+)?/;
var FENCE_LINE_REGEX = /^(\s*)(```+|~~~+).*/;
function escapeRegex(s2) {
  return s2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function getListItemPrefixLength(text) {
  var _a2;
  const m = text.match(LIST_ITEM_PREFIX_RE);
  if (!m)
    return null;
  return ((_a2 = m[0]) != null ? _a2 : "").length;
}
function buildFenceStateMapFromDoc(doc) {
  var _a2, _b2, _c2, _d2;
  const inFenceByLineNo = new Array(Math.max(0, doc.lines) + 1).fill(false);
  let inFence = false;
  let fenceChar = "";
  let fenceLen = 0;
  let openedAtLineNo = 0;
  for (let ln = 1; ln <= doc.lines; ln++) {
    const text = (_a2 = doc.line(ln).text) != null ? _a2 : "";
    if (!inFence) {
      const prefixLen = getListItemPrefixLength(text);
      const fenceText = prefixLen !== null ? text.slice(prefixLen) : text;
      const m = fenceText.match(FENCE_LINE_REGEX);
      if (m) {
        inFence = true;
        fenceChar = (_c2 = ((_b2 = m[2]) != null ? _b2 : "")[0]) != null ? _c2 : "";
        fenceLen = ((_d2 = m[2]) != null ? _d2 : "").length;
        openedAtLineNo = ln;
      }
    }
    inFenceByLineNo[ln] = inFence;
    if (inFence) {
      const closeRe = new RegExp(`^\\s*${escapeRegex(fenceChar)}{${fenceLen},}\\s*$`);
      if (fenceChar && fenceLen >= 3 && ln !== openedAtLineNo && closeRe.test(text)) {
        inFence = false;
        fenceChar = "";
        fenceLen = 0;
        openedAtLineNo = 0;
      }
    }
  }
  return inFenceByLineNo;
}
function buildFenceStateMapFromLines(lines) {
  const doc = {
    lines: lines.length,
    line: (n2) => {
      var _a2;
      return { text: (_a2 = lines[n2 - 1]) != null ? _a2 : "" };
    }
  };
  return buildFenceStateMapFromDoc(doc);
}

// src/features/file-outliner-view/protocol.ts
var OUTLINER_PROTOCOL_VERSION = 2;
var OUTLINER_SYSTEM_MARKER_KEY = "blp_sys";
var OUTLINER_SYSTEM_MARKER_VALUE = "1";
var OUTLINER_SYSTEM_VERSION_KEY = "blp_ver";
var OUTLINER_SYSTEM_DATE_KEY = "date";
var OUTLINER_SYSTEM_UPDATED_KEY = "updated";
function normalizeNewlines(input) {
  return String(input != null ? input : "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
}
function splitFrontmatter(input) {
  var _a2, _b2;
  const text = normalizeNewlines(input);
  const lines = text.split("\n");
  if (((_a2 = lines[0]) != null ? _a2 : "").trim() !== "---")
    return { frontmatter: null, body: text };
  for (let i = 1; i < lines.length; i++) {
    if (((_b2 = lines[i]) != null ? _b2 : "").trim() === "---") {
      const fm = lines.slice(0, i + 1).join("\n");
      const body = lines.slice(i + 1).join("\n");
      return { frontmatter: fm, body };
    }
  }
  return { frontmatter: null, body: text };
}
function formatSystemDate(dt) {
  return dt.toFormat("yyyy-MM-dd'T'HH:mm:ss");
}
function indentText(depth, indentSize) {
  return " ".repeat(Math.max(0, depth) * indentSize);
}
function contentIndentText(depth, indentSize) {
  return indentText(depth, indentSize) + " ".repeat(indentSize);
}
var RESERVED_SYSTEM_KEYS = /* @__PURE__ */ new Set([
  OUTLINER_SYSTEM_DATE_KEY,
  OUTLINER_SYSTEM_UPDATED_KEY,
  OUTLINER_SYSTEM_MARKER_KEY,
  OUTLINER_SYSTEM_VERSION_KEY
]);
function parseDataviewInlineFields(text) {
  var _a2, _b2;
  const out = {};
  const re = /\[([^\[\]:]+?)::\s*([^\]]*?)\]/g;
  let m;
  while ((m = re.exec(text)) !== null) {
    const key = String((_a2 = m[1]) != null ? _a2 : "").trim();
    if (!key)
      continue;
    const value = String((_b2 = m[2]) != null ? _b2 : "").trim();
    out[key] = value;
  }
  return out;
}
function stripInlineFields(text) {
  return text.replace(/\[[^\[\]]+?::[^\]]*?\]/g, "").trim();
}
function parseSystemLineCandidate(rawLine) {
  var _a2;
  const m = rawLine.match(/\^([a-zA-Z0-9_-]+)\s*$/);
  if (!(m == null ? void 0 : m[1]))
    return null;
  const id = m[1];
  const beforeCaret = rawLine.slice(0, (_a2 = m.index) != null ? _a2 : rawLine.length);
  const residue = stripInlineFields(beforeCaret);
  if (residue.length !== 0)
    return null;
  return {
    id,
    fields: parseDataviewInlineFields(beforeCaret)
  };
}
function extractExtraSystemFields(fields) {
  const out = {};
  for (const [key, value] of Object.entries(fields)) {
    if (!key)
      continue;
    if (RESERVED_SYSTEM_KEYS.has(key))
      continue;
    out[key] = value;
  }
  return out;
}
function normalizeSystemFields(fields, now2) {
  const date = fields[OUTLINER_SYSTEM_DATE_KEY] || formatSystemDate(now2);
  const updated = fields[OUTLINER_SYSTEM_UPDATED_KEY] || formatSystemDate(now2);
  return { date, updated, extra: extractExtraSystemFields(fields) };
}
function mergeSplitSystemLines(lines, fenceMap) {
  var _a2, _b2, _c2, _d2;
  const out = [];
  for (let i = 0; i < lines.length; i++) {
    const lineNo = i + 1;
    const line = (_a2 = lines[i]) != null ? _a2 : "";
    if (fenceMap[lineNo]) {
      out.push(line);
      continue;
    }
    const dateOnly = line.match(/^(\s*)\[date::\s*(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2})\]\s*$/);
    if (!dateOnly) {
      out.push(line);
      continue;
    }
    const next = (_b2 = lines[i + 1]) != null ? _b2 : "";
    const idOnly = next.match(/^(\s*)\^([a-zA-Z0-9_-]+)\s*$/);
    if (!idOnly) {
      out.push(line);
      continue;
    }
    const dateIndent = (_c2 = dateOnly[1]) != null ? _c2 : "";
    const idIndent = (_d2 = idOnly[1]) != null ? _d2 : "";
    if (dateIndent !== idIndent) {
      out.push(line);
      continue;
    }
    out.push(`${dateIndent}[date:: ${dateOnly[2]}] ^${idOnly[2]}`);
    i++;
  }
  return out;
}
function parseBodyToBlocks(body, opts) {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g, _h, _i, _j, _k, _l, _m;
  const normalized = normalizeNewlines(body);
  const rawLines = normalized.split("\n").map((l2) => normalizeLineLeadingIndentTabsToSpaces(l2, MARKDOWN_TAB_WIDTH));
  const fenceMap0 = buildFenceStateMapFromLines(rawLines);
  const mergedLines = mergeSplitSystemLines(rawLines, fenceMap0);
  const fenceMap = buildFenceStateMapFromLines(mergedLines);
  const blocks = [];
  const stack = [];
  const indentSize = opts.indentSize;
  const now2 = opts.now;
  const OUTLINER_LIST_ITEM_PREFIX_RE = /^(\s*)(?:([-*+])|(\d+\.))\s+/;
  for (let i = 0; i < mergedLines.length; i++) {
    const lineNo = i + 1;
    const line = (_a2 = mergedLines[i]) != null ? _a2 : "";
    const inFence = (_b2 = fenceMap[lineNo]) != null ? _b2 : false;
    const prevInFence = (_c2 = fenceMap[Math.max(0, lineNo - 1)]) != null ? _c2 : false;
    const allowStructure = !inFence || inFence && !prevInFence;
    if (allowStructure) {
      const listMatch = line.match(OUTLINER_LIST_ITEM_PREFIX_RE);
      if (listMatch) {
        const indent = ((_d2 = listMatch[1]) != null ? _d2 : "").length;
        const depth = Math.max(0, Math.floor(indent / indentSize));
        const content = line.slice(((_e2 = listMatch[0]) != null ? _e2 : "").length);
        while (stack.length > depth)
          stack.pop();
        const block = {
          id: "",
          depth,
          text: content,
          children: [],
          system: { date: "", updated: "", extra: {} },
          _systemHasBlpMarker: false
        };
        if (depth === 0) {
          blocks.push(block);
        } else {
          const parent = (_f2 = stack[depth - 1]) == null ? void 0 : _f2.block;
          if (parent)
            parent.children.push(block);
          else
            blocks.push(block);
        }
        stack.push({ block, depth, contentIndent: depth * indentSize + indentSize });
        continue;
      }
      const sys = parseSystemLineCandidate(line);
      if (sys) {
        const lineIndent2 = ((_h = (_g = line.match(/^\s*/)) == null ? void 0 : _g[0]) != null ? _h : "").length;
        let owner2 = null;
        for (let j = stack.length - 1; j >= 0; j--) {
          const cand = stack[j];
          if (lineIndent2 >= cand.contentIndent) {
            owner2 = cand;
            break;
          }
        }
        if (owner2) {
          if (((_j = (_i = owner2.block.children) == null ? void 0 : _i.length) != null ? _j : 0) > 0) {
            const textLines = owner2.block.text.split("\n");
            if (textLines.length > 0 && textLines[textLines.length - 1] === "") {
              owner2.block.text = textLines.slice(0, -1).join("\n");
            }
          }
          const nextHasMarker = ((_k = sys.fields[OUTLINER_SYSTEM_MARKER_KEY]) != null ? _k : "") === OUTLINER_SYSTEM_MARKER_VALUE;
          const shouldReplace = !owner2.block.id || !owner2.block._systemHasBlpMarker && nextHasMarker;
          const extra = extractExtraSystemFields(sys.fields);
          for (const [k, v] of Object.entries(extra)) {
            if (shouldReplace || owner2.block.system.extra[k] === void 0) {
              owner2.block.system.extra[k] = v;
            }
          }
          if (shouldReplace) {
            owner2.block.id = sys.id;
            owner2.block.system = normalizeSystemFields(sys.fields, now2);
            owner2.block._systemHasBlpMarker = nextHasMarker;
          } else {
            if (!owner2.block.system.date && sys.fields[OUTLINER_SYSTEM_DATE_KEY]) {
              owner2.block.system.date = sys.fields[OUTLINER_SYSTEM_DATE_KEY];
            }
            if (!owner2.block.system.updated && sys.fields[OUTLINER_SYSTEM_UPDATED_KEY]) {
              owner2.block.system.updated = sys.fields[OUTLINER_SYSTEM_UPDATED_KEY];
            }
          }
        }
        continue;
      }
    }
    const lineIndent = ((_m = (_l = line.match(/^\s*/)) == null ? void 0 : _l[0]) != null ? _m : "").length;
    let owner = null;
    for (let j = stack.length - 1; j >= 0; j--) {
      const cand = stack[j];
      if (lineIndent >= cand.contentIndent) {
        owner = cand;
        break;
      }
    }
    if (!owner) {
      continue;
    }
    const stripped = line.trim().length === 0 ? "" : line.slice(Math.min(line.length, owner.contentIndent));
    owner.block.text = owner.block.text.length ? `${owner.block.text}
${stripped}` : stripped;
  }
  return blocks;
}
function collectIds2(blocks, out = []) {
  for (const b of blocks) {
    if (b.id)
      out.push(b.id);
    collectIds2(b.children, out);
  }
  return out;
}
function ensureUniqueIds(blocks, opts) {
  var _a2;
  const reserved = new Set(collectIds2(blocks).filter(Boolean));
  const used = /* @__PURE__ */ new Set();
  const idGenerator = (_a2 = opts.generateId) != null ? _a2 : generateRandomId;
  const gen = () => {
    const baseLen = Math.max(3, Math.min(7, Math.floor(opts.idLength)));
    for (let tries = 0; tries < 50; tries++) {
      const id = idGenerator(opts.idPrefix, baseLen);
      if (!reserved.has(id) && !used.has(id))
        return id;
    }
    for (let tries = 0; tries < 50; tries++) {
      const id = Math.random().toString(36).slice(2, 10);
      if (!reserved.has(id) && !used.has(id))
        return id;
    }
    return generateRandomId(opts.idPrefix, Math.min(7, baseLen));
  };
  const walk = (list) => {
    for (const b of list) {
      if (!b.id || used.has(b.id)) {
        let next = gen();
        used.add(next);
        b.id = next;
      } else {
        used.add(b.id);
      }
      walk(b.children);
    }
  };
  walk(blocks);
}
var TASK_MARKER_PREFIXES = ["[ ] ", "[x] ", "[X] "];
function isTaskMarkerLine(firstLine) {
  const line = String(firstLine != null ? firstLine : "");
  for (const p of TASK_MARKER_PREFIXES) {
    if (line.startsWith(p))
      return true;
  }
  return false;
}
function normalizeTaskBlocksSingleLine(blocks) {
  const walk = (list) => {
    var _a2, _b2, _c2, _d2;
    for (const b of list) {
      const doc = String((_a2 = b.text) != null ? _a2 : "");
      const nl = doc.indexOf("\n");
      if (nl >= 0) {
        const firstLine = doc.slice(0, nl);
        if (isTaskMarkerLine(firstLine)) {
          const rest = doc.slice(nl + 1);
          b.text = firstLine;
          if (rest.trim().length > 0) {
            const child = {
              id: "",
              depth: Math.max(0, ((_b2 = b.depth) != null ? _b2 : 0) + 1),
              text: rest,
              children: [],
              system: { date: "", updated: "", extra: {} },
              _systemHasBlpMarker: true
            };
            b.children = [child, ...(_c2 = b.children) != null ? _c2 : []];
          }
        }
      }
      walk((_d2 = b.children) != null ? _d2 : []);
    }
  };
  walk(blocks);
}
function normalizeSystemMarkers(blocks, opts) {
  var _a2;
  const now2 = (_a2 = opts.now) != null ? _a2 : DateTime.now();
  const walk = (list) => {
    for (const b of list) {
      if (!b.system.date)
        b.system.date = formatSystemDate(now2);
      if (!b.system.updated)
        b.system.updated = formatSystemDate(now2);
      if (!b.system.extra)
        b.system.extra = {};
      walk(b.children);
    }
  };
  walk(blocks);
}
function escapeBodyLineIfNeeded(line, inFence) {
  if (inFence)
    return line;
  if (LIST_ITEM_PREFIX_RE.test(line)) {
    if (/^[-*+]\s+/.test(line))
      return `\\${line}`;
    const m = line.match(/^(\d+)\.\s+/);
    if (m)
      return line.replace(/^(\d+)\./, "$1\\.");
  }
  return line;
}
function serializeBlocks(blocks, opts) {
  const out = [];
  const indentSize = opts.indentSize;
  const walk = (list, depth) => {
    var _a2, _b2, _c2, _d2, _e2;
    for (const b of list) {
      const indent = indentText(depth, indentSize);
      const bodyIndent = contentIndentText(depth, indentSize);
      const rawLines = String((_a2 = b.text) != null ? _a2 : "").split("\n");
      const first = (_b2 = rawLines[0]) != null ? _b2 : "";
      out.push(`${indent}- ${first}`);
      const fenceMap = buildFenceStateMapFromLines(rawLines);
      for (let i = 1; i < rawLines.length; i++) {
        const raw = (_c2 = rawLines[i]) != null ? _c2 : "";
        const inFence = (_d2 = fenceMap[i + 1]) != null ? _d2 : false;
        out.push(raw.length === 0 ? bodyIndent : `${bodyIndent}${escapeBodyLineIfNeeded(raw, inFence)}`);
      }
      const extraKeys = Object.keys((_e2 = b.system.extra) != null ? _e2 : {}).sort();
      const extraFields = extraKeys.map((k) => `[${k}:: ${b.system.extra[k]}]`);
      const tailFields = [
        `[${OUTLINER_SYSTEM_DATE_KEY}:: ${b.system.date}]`,
        `[${OUTLINER_SYSTEM_UPDATED_KEY}:: ${b.system.updated}]`,
        `[${OUTLINER_SYSTEM_MARKER_KEY}:: ${OUTLINER_SYSTEM_MARKER_VALUE}]`,
        `[${OUTLINER_SYSTEM_VERSION_KEY}:: ${OUTLINER_PROTOCOL_VERSION}]`,
        ...extraFields
      ].join(" ");
      out.push(`${bodyIndent}${tailFields} ^${b.id}`.trimEnd());
      walk(b.children, depth + 1);
    }
  };
  walk(blocks, 0);
  return out;
}
function serializeOutlinerBlocksForClipboard(blocks, opts) {
  const out = [];
  const indentSize = opts.indentSize;
  const walk = (list, depth) => {
    var _a2, _b2, _c2, _d2;
    for (const b of list) {
      const indent = indentText(depth, indentSize);
      const bodyIndent = contentIndentText(depth, indentSize);
      const rawLines = String((_a2 = b.text) != null ? _a2 : "").split("\n");
      const first = (_b2 = rawLines[0]) != null ? _b2 : "";
      out.push(`${indent}- ${first}`);
      const fenceMap = buildFenceStateMapFromLines(rawLines);
      for (let i = 1; i < rawLines.length; i++) {
        const raw = (_c2 = rawLines[i]) != null ? _c2 : "";
        const inFence = (_d2 = fenceMap[i + 1]) != null ? _d2 : false;
        out.push(raw.length === 0 ? bodyIndent : `${bodyIndent}${escapeBodyLineIfNeeded(raw, inFence)}`);
      }
      walk(b.children, depth + 1);
    }
  };
  walk(blocks, 0);
  return out.join("\n").trimEnd();
}
function parseOutlinerFile(input, opts) {
  const src = normalizeNewlines(input);
  const { frontmatter, body } = splitFrontmatter(src);
  const blocks = parseBodyToBlocks(body, opts);
  return { frontmatter, blocks };
}
function serializeOutlinerFile(file, opts) {
  var _a2;
  const bodyLines = serializeBlocks((_a2 = file.blocks) != null ? _a2 : [], opts);
  const nextBody = bodyLines.join("\n") + "\n";
  return file.frontmatter ? `${file.frontmatter}
${nextBody}` : nextBody;
}
function normalizeOutlinerFile(input, opts) {
  var _a2, _b2;
  const indentSize = Math.max(1, Math.floor((_a2 = opts.indentSize) != null ? _a2 : 2));
  const now2 = (_b2 = opts.now) != null ? _b2 : DateTime.now();
  const src = normalizeNewlines(input);
  const file = parseOutlinerFile(src, { indentSize, now: now2 });
  normalizeTaskBlocksSingleLine(file.blocks);
  ensureUniqueIds(file.blocks, opts);
  normalizeSystemMarkers(file.blocks, { ...opts, indentSize, now: now2 });
  const content = serializeOutlinerFile(file, { indentSize });
  const didChange = normalizeNewlines(content) !== normalizeNewlines(src.endsWith("\n") ? src : src + "\n");
  return { file, content, didChange };
}

// src/features/file-outliner-view/pane-menu-labels.ts
var FALLBACK = {
  openAsMarkdown: "Open as Markdown (source)",
  openAsMarkdownNewTab: "Open as Markdown (new tab)",
  openAsOutliner: "Open as Outliner",
  openAsOutlinerNewTab: "Open as Outliner (new tab)"
};
function getFileOutlinerPaneMenuLabels() {
  var _a2, _b2, _c2, _d2, _e2, _f2;
  const raw = (_b2 = (_a2 = i18n_default.settings) == null ? void 0 : _a2.fileOutliner) == null ? void 0 : _b2.paneMenu;
  if (!raw)
    return FALLBACK;
  return {
    openAsMarkdown: String((_c2 = raw.openAsMarkdown) != null ? _c2 : FALLBACK.openAsMarkdown),
    openAsMarkdownNewTab: String((_d2 = raw.openAsMarkdownNewTab) != null ? _d2 : FALLBACK.openAsMarkdownNewTab),
    openAsOutliner: String((_e2 = raw.openAsOutliner) != null ? _e2 : FALLBACK.openAsOutliner),
    openAsOutlinerNewTab: String((_f2 = raw.openAsOutlinerNewTab) != null ? _f2 : FALLBACK.openAsOutlinerNewTab)
  };
}

// src/features/file-outliner-view/display-controller.ts
var import_obsidian17 = require("obsidian");

// src/features/file-outliner-view/block-markdown.ts
var HEADING_LINE_RE = /^\s{0,3}#{1,6}(?:\s+|$)/;
function escapeListMarkerLine(line) {
  var _a2;
  const ul = line.match(/^(\s*)[-*+](\s+)/);
  if (ul) {
    const indentLen = ((_a2 = ul[1]) != null ? _a2 : "").length;
    return `${line.slice(0, indentLen)}\\${line.slice(indentLen)}`;
  }
  if (/^\s*\d+\.\s+/.test(line)) {
    return line.replace(/^(\s*)(\d+)\.(\s+)/, "$1$2\\.$3");
  }
  return line;
}
function escapeHeadingLine(line) {
  return line.replace(/^(\s{0,3})(#{1,6})/, "$1\\$2");
}
function sanitizeOutlinerBlockMarkdownForDisplay(text) {
  var _a2, _b2, _c2, _d2;
  const normalized = String(text != null ? text : "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  const lines = normalized.split("\n");
  const outLines = [];
  const issues = [];
  let hasListIssue = false;
  let hasHeadingIssue = false;
  let inFence = false;
  let fenceChar = "";
  let fenceLen = 0;
  let openedAtLineNo = 0;
  for (let i = 0; i < lines.length; i++) {
    const lineNo = i + 1;
    const raw = (_a2 = lines[i]) != null ? _a2 : "";
    if (!inFence) {
      let next = raw;
      if (LIST_ITEM_PREFIX_RE.test(raw)) {
        hasListIssue = true;
        issues.push({ kind: "list", lineNo, line: raw });
        next = escapeListMarkerLine(next);
      }
      if (HEADING_LINE_RE.test(raw)) {
        hasHeadingIssue = true;
        issues.push({ kind: "heading", lineNo, line: raw });
        next = escapeHeadingLine(next);
      }
      outLines.push(next);
      const m = next.match(FENCE_LINE_REGEX);
      if (m) {
        inFence = true;
        fenceChar = (_c2 = String((_b2 = m[2]) != null ? _b2 : "")[0]) != null ? _c2 : "";
        fenceLen = String((_d2 = m[2]) != null ? _d2 : "").length;
        openedAtLineNo = lineNo;
      }
      continue;
    }
    outLines.push(raw);
    if (fenceChar && fenceLen >= 3 && lineNo !== openedAtLineNo) {
      const closeRe = new RegExp(`^\\s*${escapeRegex(fenceChar)}{${fenceLen},}\\s*$`);
      if (closeRe.test(raw)) {
        inFence = false;
        fenceChar = "";
        fenceLen = 0;
        openedAtLineNo = 0;
      }
    }
  }
  return {
    sanitized: outLines.join("\n"),
    issues,
    hasListIssue,
    hasHeadingIssue
  };
}

// src/features/file-outliner-view/display-render-scheduler.ts
var DisplayRenderScheduler = class {
  constructor() {
    this.visibleIds = /* @__PURE__ */ new Set();
    this.needsRenderIds = /* @__PURE__ */ new Set();
    this.queuedIds = /* @__PURE__ */ new Set();
    this.queue = [];
  }
  reset() {
    this.visibleIds.clear();
    this.needsRenderIds.clear();
    this.queuedIds.clear();
    this.queue = [];
  }
  remove(id) {
    this.visibleIds.delete(id);
    this.needsRenderIds.delete(id);
    this.queuedIds.delete(id);
  }
  setVisible(id, visible) {
    if (visible)
      this.visibleIds.add(id);
    else
      this.visibleIds.delete(id);
    this.maybeEnqueue(id);
  }
  markNeedsRender(id) {
    this.needsRenderIds.add(id);
    this.maybeEnqueue(id);
  }
  markRendered(id) {
    this.needsRenderIds.delete(id);
  }
  hasPendingWork() {
    return this.queue.length > 0;
  }
  takeNextBatch(budget) {
    const out = [];
    const max = Math.max(0, Math.floor(budget));
    while (out.length < max && this.queue.length > 0) {
      const id = this.queue.shift();
      if (!id)
        continue;
      this.queuedIds.delete(id);
      if (!this.visibleIds.has(id))
        continue;
      if (!this.needsRenderIds.has(id))
        continue;
      out.push(id);
    }
    return out;
  }
  maybeEnqueue(id) {
    if (!this.visibleIds.has(id))
      return;
    if (!this.needsRenderIds.has(id))
      return;
    if (this.queuedIds.has(id))
      return;
    this.queuedIds.add(id);
    this.queue.push(id);
  }
};

// src/features/file-outliner-view/embed-dom.ts
function normalizeInternalMarkdownEmbeds(root) {
  var _a2;
  const embeds = [];
  if ((_a2 = root.matches) == null ? void 0 : _a2.call(root, ".internal-embed.markdown-embed")) {
    embeds.push(root);
  } else {
    embeds.push(...Array.from(root.querySelectorAll(".internal-embed.markdown-embed")));
  }
  let normalized = 0;
  for (const embedEl of embeds) {
    if (normalizeOneEmbed(embedEl))
      normalized += 1;
  }
  return { normalized };
}
function findDirectChildByClass(parent, cls) {
  var _a2;
  for (const child of Array.from(parent.children)) {
    if ((_a2 = child.classList) == null ? void 0 : _a2.contains(cls))
      return child;
  }
  return null;
}
function normalizeOneEmbed(embedEl) {
  const existingContent = findDirectChildByClass(embedEl, "markdown-embed-content");
  const titleEl = findDirectChildByClass(embedEl, "markdown-embed-title");
  const linkEl = findDirectChildByClass(embedEl, "markdown-embed-link");
  let contentEl = existingContent;
  let changed = false;
  if (!contentEl) {
    contentEl = document.createElement("div");
    contentEl.className = "markdown-embed-content";
    changed = true;
    const insertAfter2 = linkEl != null ? linkEl : titleEl;
    if ((insertAfter2 == null ? void 0 : insertAfter2.parentElement) === embedEl && typeof insertAfter2.after === "function") {
      insertAfter2.after(contentEl);
    } else if ((insertAfter2 == null ? void 0 : insertAfter2.parentElement) === embedEl) {
      embedEl.insertBefore(contentEl, insertAfter2.nextSibling);
    } else {
      embedEl.insertBefore(contentEl, embedEl.firstChild);
    }
  }
  const snapshot = Array.from(embedEl.childNodes);
  for (const node of snapshot) {
    if (node === titleEl)
      continue;
    if (node === linkEl)
      continue;
    if (node === contentEl)
      continue;
    try {
      contentEl.appendChild(node);
      changed = true;
    } catch (e) {
    }
  }
  return changed;
}

// src/features/file-outliner-view/task-marker.ts
var TODO_PREFIX = "[ ] ";
var DONE_PREFIX_LOWER = "[x] ";
var DONE_PREFIX_UPPER = "[X] ";
function parseTaskMarkerPrefix(firstLine) {
  const line = String(firstLine != null ? firstLine : "");
  if (line.startsWith(TODO_PREFIX))
    return { marker: "todo", rest: line.slice(TODO_PREFIX.length) };
  if (line.startsWith(DONE_PREFIX_LOWER))
    return { marker: "done", rest: line.slice(DONE_PREFIX_LOWER.length) };
  if (line.startsWith(DONE_PREFIX_UPPER))
    return { marker: "done", rest: line.slice(DONE_PREFIX_UPPER.length) };
  return null;
}
function toggleTaskStatusMarkerPrefix(firstLine) {
  const line = String(firstLine != null ? firstLine : "");
  const parsed = parseTaskMarkerPrefix(line);
  if (!parsed)
    return `${TODO_PREFIX}${line}`;
  if (parsed.marker === "todo")
    return `${DONE_PREFIX_LOWER}${parsed.rest}`;
  return `${TODO_PREFIX}${parsed.rest}`;
}
function toggleTaskMarkerPrefix(firstLine) {
  const line = String(firstLine != null ? firstLine : "");
  const parsed = parseTaskMarkerPrefix(line);
  if (!parsed)
    return `${TODO_PREFIX}${line}`;
  return parsed.rest;
}
function ensureTaskMarkerPrefix(firstLine) {
  const line = String(firstLine != null ? firstLine : "");
  const parsed = parseTaskMarkerPrefix(line);
  if (parsed)
    return line;
  return `${TODO_PREFIX}${line}`;
}
function ensureTaskMarkerPrefixInBlockText(text) {
  const doc = String(text != null ? text : "");
  const nl = doc.indexOf("\n");
  const firstLineEnd = nl >= 0 ? nl : doc.length;
  const firstLine = doc.slice(0, firstLineEnd);
  return `${ensureTaskMarkerPrefix(firstLine)}${doc.slice(firstLineEnd)}`;
}
function ensureTodoTaskMarkerPrefix(firstLine) {
  const line = String(firstLine != null ? firstLine : "");
  const parsed = parseTaskMarkerPrefix(line);
  const rest = parsed ? parsed.rest : line;
  return `${TODO_PREFIX}${rest}`;
}
function ensureTodoTaskMarkerPrefixInBlockText(text) {
  const doc = String(text != null ? text : "");
  const nl = doc.indexOf("\n");
  const firstLineEnd = nl >= 0 ? nl : doc.length;
  const firstLine = doc.slice(0, firstLineEnd);
  return `${ensureTodoTaskMarkerPrefix(firstLine)}${doc.slice(firstLineEnd)}`;
}
function getTaskMarkerFromBlockText(text) {
  const doc = String(text != null ? text : "");
  const nl = doc.indexOf("\n");
  const firstLineEnd = nl >= 0 ? nl : doc.length;
  const firstLine = doc.slice(0, firstLineEnd);
  const parsed = parseTaskMarkerPrefix(firstLine);
  if (!parsed)
    return null;
  const renderText = `${parsed.rest}${doc.slice(firstLineEnd)}`;
  const checked = parsed.marker === "done";
  return { marker: parsed.marker, checked, renderText };
}

// src/features/file-outliner-view/display-controller.ts
var OutlinerDisplayController = class {
  constructor(host) {
    this.scheduler = new DisplayRenderScheduler();
    this.renderSeqById = /* @__PURE__ */ new Map();
    this.componentById = /* @__PURE__ */ new Map();
    this.displayRenderDrainTimer = null;
    this.visibleRefreshTimer = null;
    this.visibleBufferPx = 500;
    this.host = host;
  }
  reset() {
    this.scheduler.reset();
    this.renderSeqById.clear();
    if (this.displayRenderDrainTimer) {
      window.clearTimeout(this.displayRenderDrainTimer);
      this.displayRenderDrainTimer = null;
    }
    if (this.visibleRefreshTimer) {
      window.clearTimeout(this.visibleRefreshTimer);
      this.visibleRefreshTimer = null;
    }
    for (const component of this.componentById.values()) {
      this.host.tryOrLog("display/reset/removeChild", () => this.host.removeChildComponent(component));
    }
    this.componentById.clear();
  }
  removeBlock(id) {
    this.scheduler.remove(id);
    this.renderSeqById.delete(id);
    const prev = this.componentById.get(id);
    if (prev) {
      this.host.tryOrLog("display/removeBlock/removeChild", () => this.host.removeChildComponent(prev));
      this.componentById.delete(id);
    }
  }
  markNeedsRender(id) {
    this.scheduler.markNeedsRender(id);
  }
  markRendered(id) {
    this.scheduler.markRendered(id);
  }
  ensurePlaceholderAndScheduleFirstRender(id) {
    if (this.host.getEditingId() === id)
      return;
    const display = this.host.getDisplayEl(id);
    if (!display)
      return;
    if (display.childNodes.length !== 0)
      return;
    this.renderBlockPlaceholder(id);
    this.scheduler.markNeedsRender(id);
  }
  scheduleVisibleBlockRefresh() {
    if (this.visibleRefreshTimer)
      return;
    this.visibleRefreshTimer = window.setTimeout(() => {
      this.visibleRefreshTimer = null;
      try {
        this.refreshVisibleBlocksFromDom();
      } catch (err) {
        this.host.debugLog("display/scheduleVisibleBlockRefresh/refreshVisibleBlocksFromDom", err);
      }
      this.scheduleDisplayRenderDrain();
    }, 0);
  }
  refreshVisibleBlocksFromDom() {
    const rootRect = this.host.contentEl.getBoundingClientRect();
    const top = rootRect.top - this.visibleBufferPx;
    const bottom = rootRect.bottom + this.visibleBufferPx;
    for (const [id, rowEl] of this.host.getRowElEntries()) {
      let visible = false;
      try {
        if (rowEl.getClientRects().length > 0) {
          const r = rowEl.getBoundingClientRect();
          visible = r.bottom >= top && r.top <= bottom;
        }
      } catch (err) {
        this.host.debugLog("display/refreshVisibleBlocksFromDom/rowRect", err);
      }
      this.scheduler.setVisible(id, visible);
    }
  }
  scheduleDisplayRenderDrain() {
    if (this.displayRenderDrainTimer)
      return;
    this.displayRenderDrainTimer = window.setTimeout(() => {
      this.displayRenderDrainTimer = null;
      this.drainDisplayRenderQueue();
    }, 0);
  }
  drainDisplayRenderQueue() {
    const budget = 12;
    const ids = this.scheduler.takeNextBatch(budget);
    for (const id of ids) {
      if (id === this.host.getEditingId())
        continue;
      try {
        this.renderBlockDisplay(id);
      } catch (err) {
        this.host.debugLog("display/drain/renderBlockDisplay", err);
        this.scheduler.markRendered(id);
      }
    }
    if (this.scheduler.hasPendingWork()) {
      this.scheduleDisplayRenderDrain();
    }
  }
  renderBlockPlaceholder(id) {
    var _a2, _b2;
    const b = this.host.getBlock(id);
    const display = this.host.getDisplayEl(id);
    if (!b || !display)
      return;
    if (this.host.getEditingId() === id)
      return;
    const task = getTaskMarkerFromBlockText((_a2 = b.text) != null ? _a2 : "");
    const text = task ? task.renderText : String((_b2 = b.text) != null ? _b2 : "");
    const p = document.createElement("p");
    p.textContent = text;
    if (!task) {
      display.replaceChildren(p);
      return;
    }
    const row = document.createElement("div");
    row.className = "blp-outliner-task-row";
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.className = "blp-outliner-task-checkbox";
    checkbox.checked = task.checked;
    checkbox.addEventListener("click", (evt) => {
      evt.stopPropagation();
      this.host.toggleTaskStatusForBlock(id);
    });
    row.appendChild(checkbox);
    const content = document.createElement("div");
    content.className = "blp-outliner-task-content";
    content.appendChild(p);
    row.appendChild(content);
    display.replaceChildren(row);
  }
  renderBlockDisplay(id) {
    var _a2, _b2, _c2;
    const b = this.host.getBlock(id);
    if (!b)
      return;
    if (!this.host.getDisplayEl(id))
      return;
    const seq2 = ((_a2 = this.renderSeqById.get(id)) != null ? _a2 : 0) + 1;
    this.renderSeqById.set(id, seq2);
    const task = getTaskMarkerFromBlockText((_b2 = b.text) != null ? _b2 : "");
    const renderText = task ? task.renderText : (_c2 = b.text) != null ? _c2 : "";
    const md = sanitizeOutlinerBlockMarkdownForDisplay(renderText);
    const sourcePath = this.host.getSourcePath();
    const tmp = document.createElement("div");
    tmp.classList.add("markdown-rendered");
    const component = this.host.addChildComponent();
    void import_obsidian17.MarkdownRenderer.render(this.host.app, md.sanitized, tmp, sourcePath, component).then(() => {
      if (this.renderSeqById.get(id) !== seq2) {
        this.host.tryOrLog(
          "display/renderBlockDisplay/discard/removeChild(component)",
          () => this.host.removeChildComponent(component)
        );
        return;
      }
      const display = this.host.getDisplayEl(id);
      if (!display) {
        this.host.tryOrLog(
          "display/renderBlockDisplay/noDisplay/removeChild(component)",
          () => this.host.removeChildComponent(component)
        );
        this.renderSeqById.delete(id);
        return;
      }
      this.host.tryOrLog("display/renderBlockDisplay/removeCopyCodeButtons", () => {
        tmp.querySelectorAll("button.copy-code-button").forEach((btn) => btn.remove());
      });
      this.host.tryOrLog(
        "display/renderBlockDisplay/normalizeInternalMarkdownEmbeds",
        () => normalizeInternalMarkdownEmbeds(tmp)
      );
      if (this.host.plugin.settings.fileOutlinerHideSystemLine !== false) {
        this.host.tryOrLog("display/renderBlockDisplay/hideSystemLines", () => {
          var _a3;
          const hasMarker = Boolean(
            tmp.querySelector(
              '.dataview.inline-field-key[data-dv-key="blp_sys"], .dataview.inline-field-key[data-dv-norm-key="blp_sys"]'
            )
          ) || ((_a3 = tmp.textContent) != null ? _a3 : "").includes("blp_sys::");
          if (hasMarker) {
            fileOutlinerMarkdownPostProcessor(tmp, { sourcePath }, this.host.plugin);
          }
        });
      }
      const prev = this.componentById.get(id);
      if (md.issues.length > 0) {
        this.host.tryOrLog("display/renderBlockDisplay/issuesBanner", () => {
          var _a3, _b3;
          const banner = document.createElement("div");
          banner.className = "blp-outliner-block-warning";
          const icon = document.createElement("span");
          icon.className = "blp-outliner-block-warning-icon";
          icon.textContent = "!";
          banner.appendChild(icon);
          const text = document.createElement("span");
          text.className = "blp-outliner-block-warning-text";
          text.textContent = String(
            (_b3 = (_a3 = i18n_default.notices) == null ? void 0 : _a3.fileOutlinerUnsupportedBlockMarkdown) != null ? _b3 : "Block contains list/heading syntax. Rendered as plain text to preserve outliner structure."
          );
          banner.appendChild(text);
          tmp.prepend(banner);
        });
      }
      if (task) {
        const row = document.createElement("div");
        row.className = "blp-outliner-task-row";
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.className = "blp-outliner-task-checkbox";
        checkbox.checked = task.checked;
        checkbox.addEventListener("click", (evt) => {
          evt.stopPropagation();
          this.host.toggleTaskStatusForBlock(id);
        });
        row.appendChild(checkbox);
        const content = document.createElement("div");
        content.className = "blp-outliner-task-content";
        content.appendChild(tmp);
        row.appendChild(content);
        display.replaceChildren(row);
      } else {
        display.replaceChildren(tmp);
      }
      this.componentById.set(id, component);
      this.scheduler.markRendered(id);
      if (prev) {
        this.host.tryOrLog("display/renderBlockDisplay/removeChild(prev)", () => this.host.removeChildComponent(prev));
      }
    }).catch((err) => {
      this.host.debugLog("display/renderBlockDisplay/markdownRenderer", err);
      this.host.tryOrLog(
        "display/renderBlockDisplay/catch/removeChild(component)",
        () => this.host.removeChildComponent(component)
      );
    });
  }
};

// src/features/file-outliner-view/editor-suggest-bridge.ts
var import_obsidian18 = require("obsidian");
var import_state3 = require("@codemirror/state");
function clamp(n2, min, max) {
  return Math.max(min, Math.min(max, n2));
}
function posToOffset(doc, pos) {
  var _a2, _b2;
  const lineNo = clamp(Math.floor((_a2 = pos.line) != null ? _a2 : 0), 0, Math.max(0, doc.lines - 1));
  const ch = Math.max(0, Math.floor((_b2 = pos.ch) != null ? _b2 : 0));
  const line = doc.line(lineNo + 1);
  return line.from + Math.min(ch, line.length);
}
function offsetToPos(doc, offset2) {
  const off = clamp(Math.floor(offset2 != null ? offset2 : 0), 0, doc.length);
  const line = doc.lineAt(off);
  return { line: line.number - 1, ch: off - line.from };
}
function normalizeCoords(input) {
  if (!input)
    return null;
  if (Number.isFinite(input.x) && Number.isFinite(input.y))
    return { x: input.x, y: input.y };
  if (Number.isFinite(input.left) && Number.isFinite(input.top))
    return { x: input.left, y: input.top };
  return null;
}
var OutlinerSuggestEditor = class extends import_obsidian18.Editor {
  constructor(cm, opts) {
    super();
    this.cm = cm;
    this.containerEl = cm.dom;
    try {
      const logicalHasFocus = opts == null ? void 0 : opts.logicalHasFocus;
      if (logicalHasFocus && !Object.prototype.hasOwnProperty.call(cm, "hasFocus")) {
        const proto = Object.getPrototypeOf(cm);
        const desc = Object.getOwnPropertyDescriptor(proto, "hasFocus");
        const baseGet = desc == null ? void 0 : desc.get;
        if (typeof baseGet === "function") {
          Object.defineProperty(cm, "hasFocus", {
            get() {
              try {
                if (baseGet.call(this))
                  return true;
              } catch (e) {
              }
              try {
                return !!logicalHasFocus();
              } catch (e) {
                return false;
              }
            },
            configurable: true
          });
        }
      }
    } catch (e) {
    }
    try {
      const elAny = this.containerEl;
      if (elAny && !("win" in elAny)) {
        Object.defineProperty(elAny, "win", { value: window, configurable: true });
      }
    } catch (e) {
    }
  }
  refresh() {
    try {
      this.cm.requestMeasure();
    } catch (e) {
    }
  }
  getValue() {
    return this.cm.state.doc.toString();
  }
  setValue(content) {
    const next = String(content != null ? content : "");
    this.cm.dispatch({
      changes: { from: 0, to: this.cm.state.doc.length, insert: next },
      selection: { anchor: next.length }
    });
  }
  getLine(line) {
    const doc = this.cm.state.doc;
    const lineNo = clamp(Math.floor(line != null ? line : 0), 0, Math.max(0, doc.lines - 1));
    return doc.line(lineNo + 1).text;
  }
  lineCount() {
    return this.cm.state.doc.lines;
  }
  lastLine() {
    return Math.max(0, this.cm.state.doc.lines - 1);
  }
  getSelection() {
    const r = this.cm.state.selection.main;
    return this.cm.state.sliceDoc(Math.min(r.from, r.to), Math.max(r.from, r.to));
  }
  /**
   * Minimal implementation used by core editor commands like `editor:toggle-bold`.
   * Best-effort: supports common inline wrappers only.
   */
  toggleMarkdownFormatting(style) {
    const kind = String(style != null ? style : "").toLowerCase();
    const token = kind === "bold" ? "**" : kind === "italic" ? "*" : kind === "strikethrough" ? "~~" : kind === "highlight" ? "==" : kind === "code" ? "`" : null;
    if (!token)
      return;
    const r = this.cm.state.selection.main;
    const from = Math.min(r.from, r.to);
    const to = Math.max(r.from, r.to);
    const doc = this.cm.state.doc;
    const docText = doc.toString();
    const tokenLen = token.length;
    const hasTokenBefore = from >= tokenLen && docText.slice(from - tokenLen, from) === token;
    const hasTokenAfter = to + tokenLen <= doc.length && docText.slice(to, to + tokenLen) === token;
    if (from === to) {
      const hasCursorBefore = from >= tokenLen && docText.slice(from - tokenLen, from) === token;
      const hasCursorAfter = from + tokenLen <= doc.length && docText.slice(from, from + tokenLen) === token;
      if (hasCursorBefore && hasCursorAfter) {
        this.cm.dispatch({
          changes: [
            { from, to: from + tokenLen, insert: "" },
            { from: from - tokenLen, to: from, insert: "" }
          ],
          selection: { anchor: from - tokenLen }
        });
        return;
      }
      this.cm.dispatch({
        changes: { from, to, insert: token + token },
        selection: { anchor: from + tokenLen }
      });
      return;
    }
    if (hasTokenBefore && hasTokenAfter) {
      this.cm.dispatch({
        changes: [
          { from: to, to: to + tokenLen, insert: "" },
          { from: from - tokenLen, to: from, insert: "" }
        ],
        selection: { anchor: from - tokenLen, head: to - tokenLen }
      });
      return;
    }
    const selected = docText.slice(from, to);
    this.cm.dispatch({
      changes: { from, to, insert: token + selected + token },
      selection: { anchor: from + tokenLen, head: to + tokenLen }
    });
  }
  getRange(from, to) {
    const doc = this.cm.state.doc;
    const a = posToOffset(doc, from);
    const b = posToOffset(doc, to);
    return this.cm.state.sliceDoc(Math.min(a, b), Math.max(a, b));
  }
  replaceSelection(replacement, _origin) {
    const r = this.cm.state.selection.main;
    const from = Math.min(r.from, r.to);
    const to = Math.max(r.from, r.to);
    const insert = String(replacement != null ? replacement : "");
    this.cm.dispatch({
      changes: { from, to, insert },
      selection: { anchor: from + insert.length }
    });
  }
  replaceRange(replacement, from, to, _origin) {
    const doc = this.cm.state.doc;
    const a = posToOffset(doc, from);
    const b = to ? posToOffset(doc, to) : a;
    const insert = String(replacement != null ? replacement : "");
    this.cm.dispatch({
      changes: { from: Math.min(a, b), to: Math.max(a, b), insert },
      selection: { anchor: Math.min(a, b) + insert.length }
    });
  }
  getCursor(string) {
    const r = this.cm.state.selection.main;
    const doc = this.cm.state.doc;
    if (string === "anchor")
      return offsetToPos(doc, r.anchor);
    if (string === "head")
      return offsetToPos(doc, r.head);
    const from = Math.min(r.from, r.to);
    const to = Math.max(r.from, r.to);
    return offsetToPos(doc, string === "to" ? to : from);
  }
  listSelections() {
    const doc = this.cm.state.doc;
    return this.cm.state.selection.ranges.map((r) => ({
      anchor: offsetToPos(doc, r.anchor),
      head: offsetToPos(doc, r.head)
    }));
  }
  setSelection(anchor, head) {
    const doc = this.cm.state.doc;
    const a = posToOffset(doc, anchor);
    const h = head ? posToOffset(doc, head) : a;
    this.cm.dispatch({ selection: { anchor: a, head: h } });
  }
  setSelections(ranges, main) {
    const doc = this.cm.state.doc;
    const next = ranges.map((r) => {
      const a = posToOffset(doc, r.anchor);
      const h = r.head ? posToOffset(doc, r.head) : a;
      return import_state3.EditorSelection.range(a, h);
    });
    this.cm.dispatch({
      selection: import_state3.EditorSelection.create(next, clamp(typeof main === "number" ? main : 0, 0, Math.max(0, next.length - 1)))
    });
  }
  focus() {
    this.cm.focus();
  }
  blur() {
    var _a2, _b2;
    try {
      (_b2 = (_a2 = this.cm.contentDOM) == null ? void 0 : _a2.blur) == null ? void 0 : _b2.call(_a2);
    } catch (e) {
    }
  }
  hasFocus() {
    try {
      return this.cm.hasFocus;
    } catch (e) {
      return false;
    }
  }
  getScrollInfo() {
    const el = this.cm.scrollDOM;
    return { top: el.scrollTop, left: el.scrollLeft };
  }
  scrollTo(x, y) {
    const el = this.cm.scrollDOM;
    if (typeof x === "number")
      el.scrollLeft = x;
    if (typeof y === "number")
      el.scrollTop = y;
  }
  scrollIntoView(range, _center) {
    const doc = this.cm.state.doc;
    const a = posToOffset(doc, range.from);
    const b = posToOffset(doc, range.to);
    const pos = Math.min(a, b);
    try {
      this.cm.dispatch({ selection: { anchor: pos }, scrollIntoView: true });
    } catch (e) {
    }
  }
  undo() {
  }
  redo() {
  }
  exec(_command) {
  }
  transaction(tx, _origin) {
    var _a2, _b2;
    const doc = this.cm.state.doc;
    const changes = [];
    if (typeof tx.replaceSelection === "string") {
      const r = this.cm.state.selection.main;
      const from = Math.min(r.from, r.to);
      const to = Math.max(r.from, r.to);
      changes.push({ from, to, insert: tx.replaceSelection });
    }
    for (const c of (_a2 = tx.changes) != null ? _a2 : []) {
      const a = posToOffset(doc, c.from);
      const b = c.to ? posToOffset(doc, c.to) : a;
      changes.push({ from: Math.min(a, b), to: Math.max(a, b), insert: String((_b2 = c.text) != null ? _b2 : "") });
    }
    let selection;
    if (tx.selection) {
      const a = posToOffset(doc, tx.selection.from);
      const h = tx.selection.to ? posToOffset(doc, tx.selection.to) : a;
      selection = { anchor: a, head: h };
    }
    try {
      this.cm.dispatch({ changes, selection });
    } catch (e) {
    }
  }
  wordAt(pos) {
    var _a2, _b2;
    const doc = this.cm.state.doc;
    const off = posToOffset(doc, pos);
    const anyState = this.cm.state;
    try {
      const w = typeof anyState.wordAt === "function" ? anyState.wordAt(off) : null;
      if (w && typeof w.from === "number" && typeof w.to === "number") {
        return { from: offsetToPos(doc, w.from), to: offsetToPos(doc, w.to) };
      }
    } catch (e) {
    }
    const text = doc.toString();
    const isWord = (ch) => /[0-9A-Za-z_\-]/.test(ch);
    let start = off;
    let end = off;
    while (start > 0 && isWord((_a2 = text[start - 1]) != null ? _a2 : ""))
      start--;
    while (end < text.length && isWord((_b2 = text[end]) != null ? _b2 : ""))
      end++;
    if (start === end)
      return null;
    return { from: offsetToPos(doc, start), to: offsetToPos(doc, end) };
  }
  posToOffset(pos) {
    return posToOffset(this.cm.state.doc, pos);
  }
  offsetToPos(offset2) {
    return offsetToPos(this.cm.state.doc, offset2);
  }
  coordsAtPos(pos) {
    var _a2;
    const off = posToOffset(this.cm.state.doc, pos);
    return (_a2 = this.cm.coordsAtPos(off)) != null ? _a2 : new DOMRect();
  }
  posAtCoords(coords) {
    const c = normalizeCoords(coords);
    const off = c ? this.cm.posAtCoords(c) : null;
    return offsetToPos(this.cm.state.doc, off != null ? off : 0);
  }
};
function triggerEditorSuggest(mgr, editor, file) {
  try {
    if (mgr && typeof mgr.trigger === "function") {
      return { triggered: !!mgr.trigger(editor, file, true) };
    }
  } catch (e) {
  }
  if (!(mgr == null ? void 0 : mgr.suggests) || typeof mgr.setCurrentSuggest !== "function")
    return { triggered: false };
  for (const s2 of mgr.suggests) {
    if (!s2 || typeof s2.trigger !== "function")
      continue;
    try {
      if (s2.trigger(editor, file, true)) {
        mgr.setCurrentSuggest(s2);
        return { triggered: true };
      }
    } catch (e) {
    }
  }
  return { triggered: false };
}

// src/features/file-outliner-view/dnd-controller.ts
var OutlinerDndController = class {
  constructor(host) {
    this.preStart = null;
    this.state = null;
    this.indicatorEl = null;
    this.dropTargetId = null;
    this.lastEndAt = 0;
    this.host = host;
  }
  getLastEndAt() {
    return this.lastEndAt;
  }
  onSettingsChanged() {
    if (this.host.isEnabled())
      return;
    this.preStart = null;
    if (this.state)
      this.stopDragging({ apply: false });
  }
  clear() {
    var _a2;
    this.preStart = null;
    this.state = null;
    this.dropTargetId = null;
    this.lastEndAt = 0;
    try {
      document.body.classList.remove("blp-outliner-dragging");
    } catch (err) {
      this.host.debugLog("dnd/clear/bodyClass.remove", err);
    }
    try {
      (_a2 = this.indicatorEl) == null ? void 0 : _a2.remove();
    } catch (err) {
      this.host.debugLog("dnd/clear/indicator.remove", err);
    }
    this.indicatorEl = null;
  }
  onPointerDown(sourceId, evt) {
    var _a2, _b2;
    if (evt.button !== 0)
      return;
    if (!this.host.hasOutlinerFile())
      return;
    if (!this.host.isEnabled())
      return;
    if (this.state)
      return;
    this.preStart = {
      sourceId,
      pointerId: evt.pointerId,
      startX: evt.clientX,
      startY: evt.clientY
    };
    try {
      (_b2 = (_a2 = evt.currentTarget) == null ? void 0 : _a2.setPointerCapture) == null ? void 0 : _b2.call(_a2, evt.pointerId);
    } catch (err) {
      this.host.debugLog("dnd/pointerDown/setPointerCapture", err);
    }
  }
  onPointerMove(evt) {
    const pre = this.preStart;
    if (pre && evt.pointerId === pre.pointerId) {
      if (!this.host.isEnabled())
        return;
      const dx = evt.clientX - pre.startX;
      const dy = evt.clientY - pre.startY;
      if (Math.hypot(dx, dy) >= 4) {
        this.startDragging(pre);
      }
    }
    const state = this.state;
    if (!state)
      return;
    if (evt.pointerId !== state.pointerId)
      return;
    if (!this.host.isEnabled()) {
      this.stopDragging({ apply: false });
      return;
    }
    evt.preventDefault();
    const drop = this.computeDropVariant(evt.clientX, evt.clientY, state.sourceId);
    state.drop = drop;
    this.renderDropIndicator(drop);
  }
  onPointerUp(evt) {
    var _a2, _b2;
    const pre = this.preStart;
    if (pre && evt.pointerId === pre.pointerId) {
      this.preStart = null;
    }
    try {
      (_b2 = (_a2 = evt.currentTarget) == null ? void 0 : _a2.releasePointerCapture) == null ? void 0 : _b2.call(_a2, evt.pointerId);
    } catch (err) {
      this.host.debugLog("dnd/pointerUp/releasePointerCapture", err);
    }
    const state = this.state;
    if (!state)
      return;
    if (evt.pointerId !== state.pointerId)
      return;
    this.stopDragging({ apply: true });
  }
  onPointerCancel(evt) {
    var _a2, _b2;
    const pre = this.preStart;
    if (pre && evt.pointerId === pre.pointerId) {
      this.preStart = null;
    }
    try {
      (_b2 = (_a2 = evt.currentTarget) == null ? void 0 : _a2.releasePointerCapture) == null ? void 0 : _b2.call(_a2, evt.pointerId);
    } catch (err) {
      this.host.debugLog("dnd/pointerCancel/releasePointerCapture", err);
    }
    const state = this.state;
    if (!state)
      return;
    if (evt.pointerId !== state.pointerId)
      return;
    this.stopDragging({ apply: false });
  }
  startDragging(pre) {
    var _a2;
    this.preStart = null;
    if (!this.host.hasOutlinerFile())
      return;
    if (!this.host.isEnabled())
      return;
    const editingId = this.host.getEditingId();
    if (editingId) {
      try {
        this.host.exitEditMode(editingId);
      } catch (err) {
        this.host.debugLog("dnd/startDragging/exitEditMode", err);
      }
    }
    this.state = { sourceId: pre.sourceId, pointerId: pre.pointerId, drop: null };
    try {
      document.body.classList.add("blp-outliner-dragging");
    } catch (err) {
      this.host.debugLog("dnd/startDragging/bodyClass.add", err);
    }
    (_a2 = this.host.getBlockEl(pre.sourceId)) == null ? void 0 : _a2.classList.add("is-blp-outliner-dnd-source");
    this.ensureDropIndicator();
  }
  stopDragging(opts) {
    var _a2, _b2;
    const state = this.state;
    this.state = null;
    this.preStart = null;
    if (!state)
      return;
    this.lastEndAt = Date.now();
    try {
      document.body.classList.remove("blp-outliner-dragging");
    } catch (err) {
      this.host.debugLog("dnd/stopDragging/bodyClass.remove", err);
    }
    (_a2 = this.host.getBlockEl(state.sourceId)) == null ? void 0 : _a2.classList.remove("is-blp-outliner-dnd-source");
    if (this.dropTargetId) {
      (_b2 = this.host.getBlockEl(this.dropTargetId)) == null ? void 0 : _b2.classList.remove("is-blp-outliner-dnd-target");
    }
    this.dropTargetId = null;
    this.renderDropIndicator(null);
    const drop = state.drop;
    if (!opts.apply || !drop || !this.host.hasOutlinerFile())
      return;
    this.host.applyDrop(state.sourceId, drop);
  }
  computeDropVariant(x, y, sourceId) {
    var _a2, _b2;
    const hit = document.elementFromPoint(x, y);
    if (!hit)
      return null;
    const contentEl = this.host.getContentEl();
    if (!contentEl.contains(hit))
      return null;
    const blockEl = hit.closest(".ls-block");
    if (!blockEl)
      return null;
    const targetId = blockEl.dataset.blpOutlinerId;
    if (!targetId)
      return null;
    if (this.host.isSelfOrDescendant(sourceId, targetId))
      return null;
    const rowEl = blockEl.querySelector(":scope > .block-main-container");
    const rowRect = (_a2 = rowEl == null ? void 0 : rowEl.getBoundingClientRect()) != null ? _a2 : blockEl.getBoundingClientRect();
    const contentWrap = blockEl.querySelector(
      ":scope > .block-main-container > .block-content-wrapper"
    );
    const contentRect = (_b2 = contentWrap == null ? void 0 : contentWrap.getBoundingClientRect()) != null ? _b2 : rowRect;
    const childrenContainer = blockEl.querySelector(":scope > .block-children-container");
    const childrenOffsetPx = childrenContainer ? Number.parseFloat(getComputedStyle(childrenContainer).marginLeft) || 0 : 0;
    const baseWhere = y < rowRect.top + rowRect.height / 2 ? "before" : "after";
    let where = baseWhere;
    if (baseWhere === "after" && childrenOffsetPx > 0) {
      const insideThreshold = Math.max(12, Math.min(24, childrenOffsetPx * 0.6));
      if (x > contentRect.left + insideThreshold)
        where = "inside";
    }
    return { targetId, where };
  }
  ensureDropIndicator() {
    var _a2;
    if (this.indicatorEl && ((_a2 = this.host.getRootEl()) == null ? void 0 : _a2.contains(this.indicatorEl)))
      return;
    this.host.ensureRoot();
    const root = this.host.getRootEl();
    if (!root)
      return;
    const el = document.createElement("div");
    el.className = "blp-outliner-dnd-indicator";
    el.style.display = "none";
    root.appendChild(el);
    this.indicatorEl = el;
  }
  renderDropIndicator(drop) {
    var _a2, _b2, _c2;
    const indicator = this.indicatorEl;
    const root = this.host.getRootEl();
    if (!indicator || !root)
      return;
    if (!drop && this.dropTargetId) {
      (_a2 = this.host.getBlockEl(this.dropTargetId)) == null ? void 0 : _a2.classList.remove("is-blp-outliner-dnd-target");
      this.dropTargetId = null;
    }
    if (!drop) {
      indicator.style.display = "none";
      return;
    }
    const targetEl = this.host.getBlockEl(drop.targetId);
    if (!targetEl) {
      indicator.style.display = "none";
      return;
    }
    if (this.dropTargetId !== drop.targetId) {
      if (this.dropTargetId) {
        (_b2 = this.host.getBlockEl(this.dropTargetId)) == null ? void 0 : _b2.classList.remove("is-blp-outliner-dnd-target");
      }
      this.dropTargetId = drop.targetId;
      targetEl.classList.add("is-blp-outliner-dnd-target");
    }
    const rootRect = root.getBoundingClientRect();
    const targetRect = targetEl.getBoundingClientRect();
    const contentWrap = targetEl.querySelector(
      ":scope > .block-main-container > .block-content-wrapper"
    );
    const contentRect = (_c2 = contentWrap == null ? void 0 : contentWrap.getBoundingClientRect()) != null ? _c2 : targetRect;
    const childrenContainer = targetEl.querySelector(":scope > .block-children-container");
    const childrenOffsetPx = childrenContainer ? Number.parseFloat(getComputedStyle(childrenContainer).marginLeft) || 0 : 0;
    const lineLeft = drop.where === "inside" ? contentRect.left + childrenOffsetPx : contentRect.left;
    const lineTop = drop.where === "before" ? targetRect.top : targetRect.bottom;
    const left = Math.max(0, lineLeft - rootRect.left);
    const top = Math.max(0, lineTop - rootRect.top);
    const width = Math.max(16, rootRect.right - lineLeft - 12);
    indicator.style.display = "";
    indicator.style.left = `${Math.round(left)}px`;
    indicator.style.top = `${Math.round(top)}px`;
    indicator.style.width = `${Math.round(width)}px`;
  }
};

// src/features/file-outliner-view/dom-controller.ts
var OutlinerDomController = class {
  constructor(host) {
    this.blockElById = /* @__PURE__ */ new Map();
    this.blockRowElById = /* @__PURE__ */ new Map();
    this.blockContentElById = /* @__PURE__ */ new Map();
    this.childrenContainerElById = /* @__PURE__ */ new Map();
    this.childrenElById = /* @__PURE__ */ new Map();
    this.displayElById = /* @__PURE__ */ new Map();
    this.host = host;
  }
  clearBlocks() {
    for (const el of this.blockElById.values())
      el.remove();
    this.blockElById.clear();
    this.blockRowElById.clear();
    this.blockContentElById.clear();
    this.childrenContainerElById.clear();
    this.childrenElById.clear();
    this.displayElById.clear();
  }
  getBlockElEntries() {
    return this.blockElById.entries();
  }
  getRowElEntries() {
    return this.blockRowElById.entries();
  }
  getBlockEl(id) {
    var _a2;
    return (_a2 = this.blockElById.get(id)) != null ? _a2 : null;
  }
  getBlockContentEl(id) {
    var _a2;
    return (_a2 = this.blockContentElById.get(id)) != null ? _a2 : null;
  }
  getChildrenContainerEl(id) {
    var _a2;
    return (_a2 = this.childrenContainerElById.get(id)) != null ? _a2 : null;
  }
  getChildrenEl(id) {
    var _a2;
    return (_a2 = this.childrenElById.get(id)) != null ? _a2 : null;
  }
  getDisplayEl(id) {
    var _a2;
    return (_a2 = this.displayElById.get(id)) != null ? _a2 : null;
  }
  removeBlock(id) {
    const el = this.blockElById.get(id);
    if (el)
      el.remove();
    this.blockElById.delete(id);
    this.blockRowElById.delete(id);
    this.blockContentElById.delete(id);
    this.childrenContainerElById.delete(id);
    this.childrenElById.delete(id);
    this.displayElById.delete(id);
  }
  ensureBlockElement(id) {
    const existing = this.blockElById.get(id);
    if (existing)
      return existing;
    const blockEl = document.createElement("div");
    blockEl.className = "ls-block";
    blockEl.dataset.blpOutlinerId = id;
    const main = document.createElement("div");
    main.className = "block-main-container items-baseline";
    blockEl.appendChild(main);
    this.blockRowElById.set(id, main);
    const controlWrap = document.createElement("div");
    controlWrap.className = "block-control-wrap items-center";
    main.appendChild(controlWrap);
    const foldToggle = document.createElement("button");
    foldToggle.type = "button";
    foldToggle.className = "blp-outliner-fold-toggle";
    foldToggle.addEventListener("click", (evt) => {
      evt.preventDefault();
      evt.stopPropagation();
      this.host.toggleCollapsed(id);
    });
    controlWrap.appendChild(foldToggle);
    const bulletContainer = document.createElement("span");
    bulletContainer.className = "bullet-container";
    controlWrap.appendChild(bulletContainer);
    const bullet = document.createElement("span");
    bullet.className = "bullet";
    bulletContainer.appendChild(bullet);
    const contentWrap = document.createElement("div");
    contentWrap.className = "block-content-wrapper";
    main.appendChild(contentWrap);
    const content = document.createElement("div");
    content.className = "block-content";
    contentWrap.appendChild(content);
    this.blockContentElById.set(id, content);
    const display = document.createElement("div");
    display.className = "blp-file-outliner-display";
    content.appendChild(display);
    this.displayElById.set(id, display);
    const onActivate = (evt) => {
      const target = evt.target;
      if (target == null ? void 0 : target.closest("a, button, input, textarea"))
        return;
      if (target == null ? void 0 : target.closest(".internal-embed, .markdown-embed, .markdown-embed-link"))
        return;
      const end = this.host.getBlockTextLength(id);
      this.host.enterEditMode(id, { cursorStart: end, cursorEnd: end, scroll: true });
    };
    display.addEventListener("click", onActivate);
    bulletContainer.addEventListener("click", (evt) => {
      var _a2, _b2;
      evt.preventDefault();
      evt.stopPropagation();
      let lastEndAt = 0;
      try {
        lastEndAt = this.host.getDnd().getLastEndAt();
      } catch (err) {
        (_b2 = (_a2 = this.host).debugLog) == null ? void 0 : _b2.call(_a2, "dom/ensureBlockElement/getLastEndAt", err);
      }
      if (Date.now() - lastEndAt < 250)
        return;
      if (this.host.isZoomEnabled() === false) {
        onActivate(evt);
        return;
      }
      this.host.zoomInto(id);
    });
    bulletContainer.addEventListener("pointerdown", (evt) => {
      var _a2, _b2;
      try {
        this.host.getDnd().onPointerDown(id, evt);
      } catch (err) {
        (_b2 = (_a2 = this.host).debugLog) == null ? void 0 : _b2.call(_a2, "dom/ensureBlockElement/dnd/pointerdown", err);
      }
    });
    bulletContainer.addEventListener("pointermove", (evt) => {
      var _a2, _b2;
      try {
        this.host.getDnd().onPointerMove(evt);
      } catch (err) {
        (_b2 = (_a2 = this.host).debugLog) == null ? void 0 : _b2.call(_a2, "dom/ensureBlockElement/dnd/pointermove", err);
      }
    });
    bulletContainer.addEventListener("pointerup", (evt) => {
      var _a2, _b2;
      try {
        this.host.getDnd().onPointerUp(evt);
      } catch (err) {
        (_b2 = (_a2 = this.host).debugLog) == null ? void 0 : _b2.call(_a2, "dom/ensureBlockElement/dnd/pointerup", err);
      }
    });
    bulletContainer.addEventListener("pointercancel", (evt) => {
      var _a2, _b2;
      try {
        this.host.getDnd().onPointerCancel(evt);
      } catch (err) {
        (_b2 = (_a2 = this.host).debugLog) == null ? void 0 : _b2.call(_a2, "dom/ensureBlockElement/dnd/pointercancel", err);
      }
    });
    bulletContainer.addEventListener("contextmenu", (evt) => {
      evt.preventDefault();
      evt.stopPropagation();
      this.host.openBulletMenu(id, evt);
    });
    const childrenContainer = document.createElement("div");
    childrenContainer.className = "block-children-container flex";
    blockEl.appendChild(childrenContainer);
    this.childrenContainerElById.set(id, childrenContainer);
    const leftBorder = document.createElement("div");
    leftBorder.className = "block-children-left-border";
    childrenContainer.appendChild(leftBorder);
    const children = document.createElement("div");
    children.className = "block-children w-full";
    childrenContainer.appendChild(children);
    this.childrenElById.set(id, children);
    const insertHint = document.createElement("div");
    insertHint.className = "blp-outliner-insert-hint";
    insertHint.addEventListener("click", (evt) => {
      evt.preventDefault();
      evt.stopPropagation();
      this.host.insertAfterBlock(id);
    });
    const insertIcon = document.createElement("div");
    insertIcon.className = "blp-outliner-insert-icon";
    insertIcon.textContent = "+";
    insertHint.appendChild(insertIcon);
    blockEl.appendChild(insertHint);
    this.blockElById.set(id, blockEl);
    return blockEl;
  }
};

// src/features/file-outliner-view/editor-state.ts
var import_state6 = require("@codemirror/state");
var import_view5 = require("@codemirror/view");

// node_modules/@codemirror/basic-setup/dist/index.js
var import_view3 = require("@codemirror/view");
var import_view4 = require("@codemirror/view");
var import_state4 = require("@codemirror/state");
var import_state5 = require("@codemirror/state");
var import_language = require("@codemirror/language");
var import_commands = require("@codemirror/commands");
var import_search = require("@codemirror/search");
var import_autocomplete = require("@codemirror/autocomplete");
var import_lint = require("@codemirror/lint");
var basicSetup = [
  (0, import_view3.lineNumbers)(),
  (0, import_view3.highlightActiveLineGutter)(),
  (0, import_view3.highlightSpecialChars)(),
  (0, import_commands.history)(),
  (0, import_language.foldGutter)(),
  (0, import_view3.drawSelection)(),
  (0, import_view3.dropCursor)(),
  import_state4.EditorState.allowMultipleSelections.of(true),
  (0, import_language.indentOnInput)(),
  (0, import_language.syntaxHighlighting)(import_language.defaultHighlightStyle, { fallback: true }),
  (0, import_language.bracketMatching)(),
  (0, import_autocomplete.closeBrackets)(),
  (0, import_autocomplete.autocompletion)(),
  (0, import_view3.rectangularSelection)(),
  (0, import_view3.crosshairCursor)(),
  (0, import_view3.highlightActiveLine)(),
  (0, import_search.highlightSelectionMatches)(),
  import_view3.keymap.of([
    ...import_autocomplete.closeBracketsKeymap,
    ...import_commands.defaultKeymap,
    ...import_search.searchKeymap,
    ...import_commands.historyKeymap,
    ...import_language.foldKeymap,
    ...import_autocomplete.completionKeymap,
    ...import_lint.lintKeymap
  ])
];

// src/features/file-outliner-view/editor-shortcuts.ts
function isPlainTextPasteShortcut(evt) {
  var _a2;
  const key = String((_a2 = evt == null ? void 0 : evt.key) != null ? _a2 : "").toLowerCase();
  if (key !== "v")
    return false;
  const mod = Boolean(evt == null ? void 0 : evt.ctrlKey) || Boolean(evt == null ? void 0 : evt.metaKey);
  if (!mod)
    return false;
  return Boolean(evt == null ? void 0 : evt.shiftKey) && !Boolean(evt == null ? void 0 : evt.altKey);
}

// src/features/file-outliner-view/editor-state.ts
function createOutlinerEditorState(doc, sel, host) {
  const clamp3 = (n2) => Math.max(0, Math.min(doc.length, Math.floor(n2)));
  const anchor = clamp3(sel.cursorStart);
  const head = clamp3(sel.cursorEnd);
  return import_state6.EditorState.create({
    doc,
    selection: { anchor, head },
    extensions: [
      basicSetup,
      import_view5.EditorView.lineWrapping,
      import_view5.EditorView.theme({
        "&": {
          font: "inherit"
        },
        ".cm-scroller": {
          font: "inherit",
          lineHeight: "inherit"
        }
      }),
      import_state6.Prec.high(
        import_view5.keymap.of([
          {
            key: "Mod-Enter",
            run: () => host.onToggleTask()
          },
          {
            key: "Mod-Shift-Enter",
            run: () => host.onToggleTaskMarker()
          },
          {
            key: "ArrowUp",
            run: (view) => host.onArrowNavigate("up", view)
          },
          {
            key: "ArrowDown",
            run: (view) => host.onArrowNavigate("down", view)
          },
          {
            key: "Shift-Enter",
            run: (view) => host.onSoftEnter(view)
          },
          {
            key: "Enter",
            run: () => host.onEnter()
          },
          {
            key: "Tab",
            run: () => host.onTab(false)
          },
          {
            key: "Shift-Tab",
            run: () => host.onTab(true)
          },
          {
            key: "Backspace",
            run: () => host.onBackspace()
          },
          {
            key: "Delete",
            run: () => host.onDelete()
          }
        ])
      ),
      import_view5.EditorView.updateListener.of((update) => {
        if (host.isSyncSuppressed())
          return;
        if (update.docChanged) {
          host.onDocChanged(update.state.doc.toString());
          host.onMaybeTriggerSuggest();
        }
        if (update.selectionSet && !host.isArrowNavDispatching() && !host.shouldPreserveArrowNavGoalOnce()) {
          host.onResetArrowNavGoalColumn();
        }
      }),
      import_view5.EditorView.domEventHandlers({
        keydown: (evt) => {
          var _a2;
          if (isPlainTextPasteShortcut(evt))
            host.onPlainTextPasteShortcut();
          const key = String((_a2 = evt == null ? void 0 : evt.key) != null ? _a2 : "");
          const isPlainArrow = (key === "ArrowUp" || key === "ArrowDown") && !Boolean(evt == null ? void 0 : evt.shiftKey) && !Boolean(evt == null ? void 0 : evt.ctrlKey) && !Boolean(evt == null ? void 0 : evt.metaKey) && !Boolean(evt == null ? void 0 : evt.altKey);
          if (!isPlainArrow)
            host.onResetArrowNavGoalColumn();
          return false;
        },
        pointerdown: () => {
          host.onResetArrowNavGoalColumn();
          return false;
        },
        paste: (evt) => host.onPaste(evt)
      })
    ]
  });
}

// src/features/file-outliner-view/editor-menu-bridge.ts
function normalizePluginId2(raw) {
  const s2 = String(raw != null ? raw : "").trim();
  return s2 ? s2.toLowerCase() : "core";
}
function extractPluginIdsFromStack(stack) {
  const s2 = String(stack != null ? stack : "");
  if (!s2)
    return [];
  const ids = [];
  {
    const re = /plugin:([^:\n]+):/g;
    let m;
    while (m = re.exec(s2)) {
      if (m[1])
        ids.push(m[1]);
    }
  }
  if (ids.length === 0) {
    const re = /[\\/]+plugins[\\/]+([^\\/\r\n]+)[\\/]/g;
    let m;
    while (m = re.exec(s2)) {
      if (m[1])
        ids.push(m[1]);
    }
  }
  return ids;
}
function shouldAllowPluginId(pluginId, allowed, blocked) {
  if (blocked && blocked.has(pluginId))
    return false;
  return allowed.has(pluginId);
}
function withPluginFilteredMenu(menu, opts, run) {
  var _a2;
  const allowed = new Set(Array.from((_a2 = opts.allowedPluginIds) != null ? _a2 : []).map(normalizePluginId2));
  if (allowed.size === 0)
    return run();
  const blocked = opts.blockedPluginIds ? new Set(Array.from(opts.blockedPluginIds).map(normalizePluginId2)) : void 0;
  const getStack = typeof opts.getStack === "function" ? opts.getStack : () => {
    var _a3;
    return String((_a3 = new Error("blp-menu-stack").stack) != null ? _a3 : "");
  };
  const anyMenu = menu;
  const baseAddItem = typeof anyMenu.addItem === "function" ? anyMenu.addItem.bind(menu) : null;
  const baseAddSeparator = typeof anyMenu.addSeparator === "function" ? anyMenu.addSeparator.bind(menu) : null;
  const baseAddSubmenu = typeof anyMenu.addSubmenu === "function" ? anyMenu.addSubmenu.bind(menu) : null;
  if (!baseAddItem || !baseAddSeparator)
    return run();
  const allowCurrentCallSite = () => {
    var _a3;
    const stack = getStack();
    const candidates = extractPluginIdsFromStack(stack).map(normalizePluginId2);
    const pluginId = (_a3 = candidates.find((id) => !(blocked && blocked.has(id)))) != null ? _a3 : "core";
    return shouldAllowPluginId(pluginId, allowed, blocked);
  };
  try {
    anyMenu.addItem = (cb) => {
      if (!allowCurrentCallSite())
        return;
      return baseAddItem(cb);
    };
    anyMenu.addSeparator = () => {
      if (!allowCurrentCallSite())
        return;
      return baseAddSeparator();
    };
    if (baseAddSubmenu) {
      anyMenu.addSubmenu = (cb) => {
        if (!allowCurrentCallSite())
          return;
        return baseAddSubmenu(cb);
      };
    }
    run();
  } finally {
    anyMenu.addItem = baseAddItem;
    anyMenu.addSeparator = baseAddSeparator;
    if (baseAddSubmenu)
      anyMenu.addSubmenu = baseAddSubmenu;
  }
}

// src/features/file-outliner-view/root-click-router.ts
function resolveSourcePathForInternalLink(host, targetEl, defaultSourcePath) {
  var _a2, _b2, _c2;
  if (!defaultSourcePath)
    return defaultSourcePath;
  const embedEl = targetEl.closest(".internal-embed.markdown-embed");
  if (!embedEl)
    return defaultSourcePath;
  const raw = ((_b2 = (_a2 = embedEl.getAttribute("src")) != null ? _a2 : embedEl.getAttribute("alt")) != null ? _b2 : "").trim();
  if (!raw)
    return defaultSourcePath;
  const pipeIndex = raw.indexOf("|");
  const actual = pipeIndex === -1 ? raw : raw.substring(0, pipeIndex);
  const hashIndex = actual.indexOf("#");
  const notePath = (hashIndex === -1 ? actual : actual.substring(0, hashIndex)).trim();
  if (!notePath)
    return defaultSourcePath;
  try {
    const file = host.app.metadataCache.getFirstLinkpathDest(notePath, defaultSourcePath);
    return (_c2 = file == null ? void 0 : file.path) != null ? _c2 : defaultSourcePath;
  } catch (err) {
    host.debugLog("rootClick/resolveSourcePathForInternalLink", err);
    return defaultSourcePath;
  }
}
function handleOutlinerRootClickCapture(evt, host) {
  var _a2, _b2, _c2, _d2;
  const target = evt.target;
  if (!target)
    return;
  if (evt.defaultPrevented)
    return;
  if (target.closest(".markdown-source-view"))
    return;
  if (target.closest(".blp-file-outliner-editor"))
    return;
  const defaultSourcePath = host.getDefaultSourcePath();
  const anchor = target.closest("a.internal-link");
  if (anchor) {
    const href = (_d2 = (_c2 = (_b2 = anchor.getAttribute("data-href")) != null ? _b2 : (_a2 = anchor == null ? void 0 : anchor.dataset) == null ? void 0 : _a2.href) != null ? _c2 : anchor.getAttribute("href")) != null ? _d2 : "";
    if (!href)
      return;
    evt.preventDefault();
    evt.stopPropagation();
    const sourcePath = resolveSourcePathForInternalLink(host, anchor, defaultSourcePath);
    const newLeaf = Boolean(evt.ctrlKey || evt.metaKey);
    void host.app.workspace.openLinkText(href, sourcePath, newLeaf);
    return;
  }
  const embedEl = target.closest(".internal-embed.markdown-embed");
  if (!embedEl)
    return;
  if (!defaultSourcePath)
    return;
  if (target.closest("a, button, input, textarea"))
    return;
  evt.preventDefault();
  evt.stopPropagation();
  void host.plugin.inlineEditEngine.mountInlineEmbedInOutliner(embedEl, defaultSourcePath);
}

// src/features/file-outliner-view/arrow-navigation.ts
function computeVisibleBlockOrder(renderBlocks, collapsedIds) {
  const out = [];
  const walk = (blocks) => {
    for (const b of blocks) {
      if (!(b == null ? void 0 : b.id))
        continue;
      out.push(b.id);
      if (collapsedIds.has(b.id))
        continue;
      if (Array.isArray(b.children) && b.children.length > 0)
        walk(b.children);
    }
  };
  walk(renderBlocks != null ? renderBlocks : []);
  return out;
}
function findAdjacentVisibleBlockId(nav, currentId, dir) {
  var _a2, _b2;
  const idx = nav.indexById.get(currentId);
  if (idx === void 0)
    return null;
  if (dir === "up")
    return idx > 0 ? (_a2 = nav.order[idx - 1]) != null ? _a2 : null : null;
  return idx + 1 < nav.order.length ? (_b2 = nav.order[idx + 1]) != null ? _b2 : null : null;
}
function computeVisibleBlockNav(renderBlocks, collapsedIds) {
  const order = computeVisibleBlockOrder(renderBlocks, collapsedIds);
  const indexById = /* @__PURE__ */ new Map();
  for (let i = 0; i < order.length; i++) {
    const id = order[i];
    if (id)
      indexById.set(id, i);
  }
  return { order, indexById };
}
function clamp2(n2, min, max) {
  return Math.max(min, Math.min(max, n2));
}
function cursorPosAtFirstLine(text, goalCh) {
  const s2 = String(text != null ? text : "");
  const nl = s2.indexOf("\n");
  const first = nl >= 0 ? s2.slice(0, nl) : s2;
  return clamp2(Math.floor(goalCh), 0, first.length);
}
function cursorPosAtLastLine(text, goalCh) {
  const s2 = String(text != null ? text : "");
  const lastNl = s2.lastIndexOf("\n");
  if (lastNl < 0)
    return clamp2(Math.floor(goalCh), 0, s2.length);
  const last = s2.slice(lastNl + 1);
  const ch = clamp2(Math.floor(goalCh), 0, last.length);
  return lastNl + 1 + ch;
}

// src/features/file-outliner-view/view.ts
function formatSystemDate2(dt) {
  return dt.toFormat("yyyy-MM-dd'T'HH:mm:ss");
}
function extractCaretIdFromSubpath(raw) {
  var _a2;
  const s2 = String(raw != null ? raw : "");
  const m = s2.match(/\^([a-zA-Z0-9_-]+)/);
  return (_a2 = m == null ? void 0 : m[1]) != null ? _a2 : null;
}
var FileOutlinerView = class extends import_obsidian19.TextFileView {
  constructor(leaf, plugin) {
    super(leaf);
    this.outlinerFile = null;
    this.blockById = /* @__PURE__ */ new Map();
    this.parentById = /* @__PURE__ */ new Map();
    this.dirtyBlockIds = /* @__PURE__ */ new Set();
    this.rootEl = null;
    this.zoomHeaderEl = null;
    this.topLevelBlocksEl = null;
    this.editorHostEl = null;
    this.editorView = null;
    this.suggestEditor = null;
    this.bridgedActiveEditor = null;
    this.bridgedActiveEditorPrev = null;
    this.suppressEditorSync = false;
    this.editingId = null;
    this.pendingFocus = null;
    this.pendingScrollToId = null;
    this.pendingBlurTimer = null;
    this.lastPlainPasteShortcutAt = 0;
    this.collapsedIds = /* @__PURE__ */ new Set();
    this.zoomStack = [];
    this.visibleNavCache = null;
    this.arrowNavGoalCh = null;
    this.arrowNavDispatching = false;
    this.preserveArrowNavGoalOnce = false;
    this.indentSize = 2;
    this.plugin = plugin;
    this.dom = new OutlinerDomController({
      isZoomEnabled: () => this.plugin.settings.fileOutlinerZoomEnabled !== false,
      getBlockTextLength: (id) => {
        var _a2, _b2;
        return String((_b2 = (_a2 = this.blockById.get(id)) == null ? void 0 : _a2.text) != null ? _b2 : "").length;
      },
      enterEditMode: (id, opts) => this.enterEditMode(id, opts),
      zoomInto: (id) => this.zoomInto(id),
      toggleCollapsed: (id) => this.toggleCollapsed(id),
      openBulletMenu: (id, evt) => this.openBulletMenu(id, evt),
      insertAfterBlock: (id) => this.insertAfterBlock(id),
      getDnd: () => this.dnd,
      debugLog: (scope, err) => this.debugLog(scope, err)
    });
    this.display = new OutlinerDisplayController({
      app: this.app,
      plugin: this.plugin,
      contentEl: this.contentEl,
      getSourcePath: () => {
        var _a2, _b2;
        return (_b2 = (_a2 = this.file) == null ? void 0 : _a2.path) != null ? _b2 : "";
      },
      getEditingId: () => this.editingId,
      getBlock: (id) => {
        var _a2;
        return (_a2 = this.blockById.get(id)) != null ? _a2 : null;
      },
      getDisplayEl: (id) => this.dom.getDisplayEl(id),
      getRowElEntries: () => this.dom.getRowElEntries(),
      addChildComponent: () => this.addChild(new import_obsidian19.Component()),
      removeChildComponent: (component) => this.removeChild(component),
      toggleTaskStatusForBlock: (id) => this.toggleTaskStatusForBlock(id),
      debugLog: (scope, err) => this.debugLog(scope, err),
      tryOrLog: (scope, fn) => this.tryOrLog(scope, fn)
    });
    this.dnd = new OutlinerDndController({
      isEnabled: () => this.plugin.settings.fileOutlinerDragAndDropEnabled !== false,
      hasOutlinerFile: () => Boolean(this.outlinerFile),
      getEditingId: () => this.editingId,
      exitEditMode: (id) => this.exitEditMode(id),
      getContentEl: () => this.contentEl,
      ensureRoot: () => this.ensureRoot(),
      getRootEl: () => this.rootEl,
      getBlockEl: (id) => this.dom.getBlockEl(id),
      isSelfOrDescendant: (rootId, id) => this.isSelfOrDescendant(rootId, id),
      applyDrop: (sourceId, drop) => {
        if (!this.outlinerFile)
          return;
        if (drop.where === "inside") {
          this.collapsedIds.delete(drop.targetId);
          this.visibleNavCache = null;
        }
        this.applyEngineResult(moveBlockSubtree(this.outlinerFile, sourceId, drop.targetId, drop.where), {
          focus: false
        });
      },
      debugLog: (scope, err) => this.debugLog(scope, err)
    });
    this.contentEl.addClass("blp-file-outliner-view");
    this.syncFeatureToggles();
    this.registerDomEvent(this.contentEl, "scroll", () => this.display.scheduleVisibleBlockRefresh());
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => this.updateActiveEditorBridge()));
  }
  toggleActiveTaskStatus() {
    if (!this.editingId)
      return false;
    return this.onEditorToggleTask();
  }
  toggleActiveTaskMarker() {
    if (!this.editingId)
      return false;
    return this.onEditorToggleTaskMarker();
  }
  debugLog(scope, err) {
    if (this.plugin.settings.fileOutlinerDebugLogging !== true)
      return;
    try {
      console.error(`[BLP Outliner] ${scope}`, err);
    } catch (e) {
    }
  }
  tryOrLog(scope, fn) {
    try {
      fn();
    } catch (err) {
      this.debugLog(scope, err);
    }
  }
  /**
   * Keep purely-visual feature flags as root CSS classes so behavior and styling can be gated
   * without touching the core protocol/engine.
   */
  syncFeatureToggles() {
    try {
      this.contentEl.classList.toggle(
        "blp-outliner-dnd-enabled",
        this.plugin.settings.fileOutlinerDragAndDropEnabled !== false
      );
      this.contentEl.classList.toggle(
        "blp-outliner-emphasis-line-enabled",
        this.plugin.settings.fileOutlinerEmphasisLineEnabled !== false
      );
    } catch (err) {
      this.debugLog("syncFeatureToggles", err);
    }
  }
  /**
   * Called after plugin settings are saved to apply feature toggles to already-open leaves.
   */
  onFileOutlinerSettingsChanged() {
    this.syncFeatureToggles();
    this.updateActiveEditorBridge();
    this.dnd.onSettingsChanged();
    if (this.plugin.settings.fileOutlinerZoomEnabled === false && this.zoomStack.length > 0) {
      try {
        if (this.editingId)
          this.exitEditMode(this.editingId);
      } catch (err) {
        this.debugLog("onSettingsChanged/exitEditMode", err);
      }
      this.zoomStack = [];
      this.visibleNavCache = null;
      this.render({ forceRebuild: true });
    }
  }
  getViewType() {
    return FILE_OUTLINER_VIEW_TYPE;
  }
  getDisplayText() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.file) == null ? void 0 : _a2.basename) != null ? _b2 : "Outliner";
  }
  getIcon() {
    return "list";
  }
  onPaneMenu(menu, source) {
    super.onPaneMenu(menu, source);
    if (source !== "more-options")
      return;
    if (!this.file)
      return;
    const labels = getFileOutlinerPaneMenuLabels();
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle(labels.openAsMarkdown).setIcon("file-text").onClick(() => void this.openSourceMarkdownView({ newLeaf: false }));
    });
    menu.addItem((item) => {
      item.setTitle(labels.openAsMarkdownNewTab).setIcon("copy").onClick(() => void this.openSourceMarkdownView({ newLeaf: "tab" }));
    });
  }
  clear() {
    this.uninstallActiveEditorBridge();
    this.outlinerFile = null;
    this.blockById.clear();
    this.parentById.clear();
    this.dom.clearBlocks();
    this.display.reset();
    this.dirtyBlockIds.clear();
    this.editingId = null;
    this.pendingFocus = null;
    this.pendingScrollToId = null;
    if (this.pendingBlurTimer) {
      window.clearTimeout(this.pendingBlurTimer);
      this.pendingBlurTimer = null;
    }
    this.tryOrLog("clear/editor.destroy", () => {
      var _a2;
      return (_a2 = this.editorView) == null ? void 0 : _a2.destroy();
    });
    this.editorView = null;
    this.editorHostEl = null;
    this.rootEl = null;
    this.zoomHeaderEl = null;
    this.topLevelBlocksEl = null;
    this.collapsedIds.clear();
    this.zoomStack = [];
    this.visibleNavCache = null;
    this.dnd.clear();
    this.contentEl.empty();
  }
  isEditorCommandBridgeActive() {
    if (this.plugin.settings.fileOutlinerEditorCommandBridgeEnabled === false)
      return false;
    if (!this.editingId)
      return false;
    if (!this.suggestEditor)
      return false;
    if (!this.editorHostEl || this.editorHostEl.style.display === "none")
      return false;
    try {
      if (this.leaf !== this.app.workspace.activeLeaf)
        return false;
    } catch (err) {
      this.debugLog("activeEditorBridge/activeLeaf", err);
    }
    return true;
  }
  installActiveEditorBridge() {
    var _a2, _b2;
    if (!this.suggestEditor)
      return;
    const wsAny = this.app.workspace;
    if (this.bridgedActiveEditor) {
      try {
        if (wsAny.activeEditor !== this.bridgedActiveEditor)
          wsAny.activeEditor = this.bridgedActiveEditor;
      } catch (err) {
        this.debugLog("activeEditorBridge/reinstall", err);
      }
      return;
    }
    let prev = null;
    try {
      prev = (_a2 = wsAny.activeEditor) != null ? _a2 : null;
    } catch (e) {
      prev = null;
    }
    const bridge = {
      __blpFileOutlinerBridge: true,
      editor: this.suggestEditor,
      getMode: () => "source",
      file: (_b2 = this.file) != null ? _b2 : null,
      view: this
    };
    this.bridgedActiveEditorPrev = prev;
    this.bridgedActiveEditor = bridge;
    try {
      wsAny.activeEditor = bridge;
    } catch (err) {
      this.debugLog("activeEditorBridge/install", err);
    }
  }
  uninstallActiveEditorBridge() {
    var _a2;
    const wsAny = this.app.workspace;
    if (!this.bridgedActiveEditor)
      return;
    try {
      if (wsAny.activeEditor === this.bridgedActiveEditor) {
        wsAny.activeEditor = (_a2 = this.bridgedActiveEditorPrev) != null ? _a2 : null;
      }
    } catch (err) {
      this.debugLog("activeEditorBridge/uninstall", err);
    } finally {
      this.bridgedActiveEditor = null;
      this.bridgedActiveEditorPrev = null;
    }
  }
  updateActiveEditorBridge() {
    if (this.isEditorCommandBridgeActive())
      this.installActiveEditorBridge();
    else
      this.uninstallActiveEditorBridge();
  }
  setEphemeralState(state) {
    super.setEphemeralState(state);
    const id = extractCaretIdFromSubpath(state == null ? void 0 : state.subpath);
    if (!id)
      return;
    this.pendingScrollToId = id;
    this.scrollToBlockId(id);
  }
  setViewData(data, clear) {
    if (clear)
      this.clear();
    const idPrefix = this.plugin.settings.enable_prefix ? this.plugin.settings.id_prefix : "";
    const { file, content, didChange } = normalizeOutlinerFile(data, {
      idPrefix,
      idLength: this.plugin.settings.id_length,
      indentSize: this.indentSize,
      now: DateTime.now()
    });
    this.data = content;
    this.outlinerFile = file;
    this.visibleNavCache = null;
    this.rebuildIndex();
    this.render({ forceRebuild: true });
    if (didChange) {
      this.markDirtyAndRequestSave();
    }
  }
  getViewData() {
    var _a2;
    if (!this.outlinerFile)
      return (_a2 = this.data) != null ? _a2 : "";
    if (this.dirtyBlockIds.size > 0) {
      const now2 = formatSystemDate2(DateTime.now());
      for (const id of Array.from(this.dirtyBlockIds)) {
        const b = this.blockById.get(id);
        if (b)
          b.system.updated = now2;
      }
      this.dirtyBlockIds.clear();
    }
    const content = serializeOutlinerFile(this.outlinerFile, { indentSize: this.indentSize });
    this.data = content;
    return content;
  }
  markDirtyAndRequestSave(opts) {
    if (opts == null ? void 0 : opts.dirtyIds) {
      for (const id of opts.dirtyIds)
        this.dirtyBlockIds.add(id);
    }
    this.requestSave();
  }
  async flushSave() {
    await this.save();
  }
  rebuildIndex() {
    var _a2, _b2;
    this.blockById.clear();
    this.parentById.clear();
    const walk = (list, parentId) => {
      for (const b of list) {
        this.blockById.set(b.id, b);
        this.parentById.set(b.id, parentId);
        walk(b.children, b.id);
      }
    };
    walk((_b2 = (_a2 = this.outlinerFile) == null ? void 0 : _a2.blocks) != null ? _b2 : [], null);
  }
  generateUniqueId() {
    const prefix = this.plugin.settings.enable_prefix ? this.plugin.settings.id_prefix : "";
    const length = this.plugin.settings.id_length;
    for (let i = 0; i < 50; i++) {
      const id = generateRandomId(prefix, length);
      if (this.blockById.has(id))
        continue;
      return id;
    }
    while (true) {
      const id = Math.random().toString(36).slice(2, 10);
      if (this.blockById.has(id))
        continue;
      return id;
    }
  }
  async openSourceMarkdownView(opts) {
    const file = this.file;
    if (!file)
      return;
    this.tryOrLog("openSourceMarkdownView/exitEditMode", () => {
      if (this.editingId)
        this.exitEditMode(this.editingId);
    });
    try {
      await this.flushSave();
    } catch (err) {
      this.debugLog("openSourceMarkdownView/flushSave", err);
    }
    const leaf = opts.newLeaf ? this.app.workspace.getLeaf(opts.newLeaf) : this.leaf;
    await leaf.setViewState({
      type: "markdown",
      state: { file: file.path, mode: "source" },
      active: true
    });
    this.tryOrLog(
      "openSourceMarkdownView/setActiveLeaf",
      () => this.app.workspace.setActiveLeaf(leaf, { focus: true })
    );
  }
  ensureRoot() {
    if (this.rootEl && this.zoomHeaderEl && this.topLevelBlocksEl && this.editorHostEl && this.editorView)
      return;
    this.contentEl.empty();
    const root = this.contentEl.createDiv({ cls: "blp-file-outliner-root" });
    this.rootEl = root;
    const clickHost = {
      app: this.app,
      plugin: this.plugin,
      getDefaultSourcePath: () => {
        var _a2, _b2;
        return (_b2 = (_a2 = this.file) == null ? void 0 : _a2.path) != null ? _b2 : "";
      },
      debugLog: (scope, err) => this.debugLog(scope, err)
    };
    root.addEventListener(
      "click",
      (evt) => handleOutlinerRootClickCapture(evt, clickHost),
      true
    );
    const header = root.createDiv({ cls: "blp-file-outliner-zoom-header" });
    header.style.display = "none";
    this.zoomHeaderEl = header;
    const blocks = root.createDiv({ cls: "blp-file-outliner-blocks" });
    this.topLevelBlocksEl = blocks;
    const emptyInsertHint = document.createElement("div");
    emptyInsertHint.className = "blp-outliner-empty-insert-hint blp-outliner-insert-hint";
    emptyInsertHint.title = "Add block";
    emptyInsertHint.addEventListener("click", (evt) => {
      evt.preventDefault();
      evt.stopPropagation();
      this.insertFirstBlock();
    });
    const emptyInsertIcon = document.createElement("div");
    emptyInsertIcon.className = "blp-outliner-insert-icon";
    emptyInsertIcon.textContent = "+";
    emptyInsertHint.appendChild(emptyInsertIcon);
    blocks.appendChild(emptyInsertHint);
    const host = document.createElement("div");
    host.className = "blp-file-outliner-editor";
    host.style.display = "none";
    root.appendChild(host);
    this.editorHostEl = host;
    this.editorView = new import_view6.EditorView({
      parent: host,
      state: this.createEditorState("", { cursorStart: 0, cursorEnd: 0 })
    });
    this.suggestEditor = new OutlinerSuggestEditor(this.editorView, {
      logicalHasFocus: () => {
        if (!this.editingId)
          return false;
        try {
          if (this.leaf !== this.app.workspace.activeLeaf)
            return false;
        } catch (err) {
          this.debugLog("suggest/logicalHasFocus/activeLeaf", err);
        }
        if (!this.editorHostEl || this.editorHostEl.style.display === "none")
          return false;
        return true;
      }
    });
    this.editorView.contentDOM.addEventListener("focusout", () => this.onEditorBlur());
    this.editorView.dom.addEventListener("contextmenu", (evt) => this.onEditorContextMenu(evt));
  }
  createEditorState(doc, sel) {
    return createOutlinerEditorState(doc, sel, {
      isSyncSuppressed: () => this.suppressEditorSync,
      isArrowNavDispatching: () => this.arrowNavDispatching,
      shouldPreserveArrowNavGoalOnce: () => this.preserveArrowNavGoalOnce,
      onResetArrowNavGoalColumn: () => this.resetArrowNavGoalColumn(),
      onPlainTextPasteShortcut: () => {
        this.lastPlainPasteShortcutAt = Date.now();
      },
      onDocChanged: (nextText) => this.onEditorDocChanged(nextText),
      onMaybeTriggerSuggest: () => this.maybeTriggerEditorSuggest(),
      onPaste: (evt) => this.onEditorPaste(evt),
      onToggleTask: () => this.onEditorToggleTask(),
      onToggleTaskMarker: () => this.onEditorToggleTaskMarker(),
      onArrowNavigate: (dir, editor) => this.onEditorArrowNavigate(dir, editor),
      onEnter: () => this.onEditorEnter(),
      onSoftEnter: (editor) => this.onEditorSoftEnter(editor),
      onTab: (shift) => this.onEditorTab(shift),
      onBackspace: () => this.onEditorBackspace(),
      onDelete: () => this.onEditorDelete()
    });
  }
  maybeTriggerEditorSuggest() {
    var _a2;
    const id = this.editingId;
    const file = this.file;
    const editor = this.suggestEditor;
    if (!id)
      return;
    if (!file)
      return;
    if (!editor)
      return;
    if (!editor.hasFocus())
      return;
    const mgr = (_a2 = this.app.workspace) == null ? void 0 : _a2.editorSuggest;
    triggerEditorSuggest(mgr, editor, file);
  }
  onEditorContextMenu(evt) {
    if (this.plugin.settings.fileOutlinerEditorContextMenuEnabled === false)
      return;
    if (!this.file)
      return;
    if (!this.editingId)
      return;
    if (!this.editorView)
      return;
    evt.preventDefault();
    evt.stopPropagation();
    const menu = new import_obsidian19.Menu();
    this.buildEditorContextMenu(menu);
    menu.showAtMouseEvent(evt);
  }
  buildEditorContextMenu(menu) {
    if (!this.file)
      return;
    if (!this.editingId)
      return;
    if (!this.editorView)
      return;
    const labels = getFileOutlinerContextMenuLabels();
    const sel = this.editorView.state.selection.main;
    const from = Math.min(sel.from, sel.to);
    const to = Math.max(sel.from, sel.to);
    const selectedText = from === to ? "" : this.editorView.state.sliceDoc(from, to);
    const hasSelection = selectedText.trim().length > 0;
    menu.addItem((item) => {
      item.setTitle(labels.cut).setDisabled(!hasSelection).onClick(() => void this.cutEditorSelection());
    });
    menu.addItem((item) => {
      item.setTitle(labels.copy).setDisabled(!hasSelection).onClick(() => void this.copyEditorSelection());
    });
    menu.addItem((item) => {
      item.setTitle(labels.paste).onClick(() => void this.pasteFromClipboard({ plainTextBypass: false }));
    });
    menu.addItem((item) => {
      item.setTitle(labels.pasteAsText).onClick(() => void this.pasteFromClipboard({ plainTextBypass: true }));
    });
    menu.addSeparator();
    const caretId = `^${this.editingId}`;
    const alias = hasSelection ? this.toSingleLineAlias(selectedText) : void 0;
    menu.addItem((item) => {
      item.setTitle(labels.copyBlockReference).onClick(() => {
        copyToClipboard(this.app, this.plugin.settings, this.file, caretId, false, alias, false);
      });
    });
    menu.addItem((item) => {
      item.setTitle(labels.copyBlockEmbed).onClick(() => {
        copyToClipboard(this.app, this.plugin.settings, this.file, caretId, true, alias, false);
      });
    });
    menu.addItem((item) => {
      item.setTitle(labels.copyBlockUrl).onClick(() => {
        copyToClipboard(this.app, this.plugin.settings, this.file, caretId, false, void 0, true);
      });
    });
    this.injectAllowlistedEditorMenuItems(menu);
  }
  toSingleLineAlias(input) {
    const s2 = String(input != null ? input : "").replace(/\r?\n/g, " ").replace(/\s+/g, " ").trim();
    if (!s2)
      return void 0;
    return s2.length > 140 ? `${s2.slice(0, 140).trim()}...` : s2;
  }
  async copyEditorSelection() {
    if (!this.editorView)
      return;
    const r = this.editorView.state.selection.main;
    const from = Math.min(r.from, r.to);
    const to = Math.max(r.from, r.to);
    if (from === to)
      return;
    const text = this.editorView.state.sliceDoc(from, to);
    await navigator.clipboard.writeText(text);
  }
  async cutEditorSelection() {
    if (!this.editorView)
      return;
    const r = this.editorView.state.selection.main;
    const from = Math.min(r.from, r.to);
    const to = Math.max(r.from, r.to);
    if (from === to)
      return;
    const text = this.editorView.state.sliceDoc(from, to);
    await navigator.clipboard.writeText(text);
    this.editorView.dispatch({ changes: { from, to, insert: "" }, selection: { anchor: from } });
  }
  async pasteFromClipboard(opts) {
    var _a2;
    if (!this.editorView)
      return;
    let raw = "";
    try {
      raw = await navigator.clipboard.readText();
    } catch (err) {
      this.debugLog("editorContextMenu/paste/readText", err);
      return;
    }
    if (!raw)
      return;
    const hasNl = raw.includes("\n") || raw.includes("\r");
    const isTask = Boolean(getTaskMarkerFromBlockText(this.editorView.state.doc.toString()));
    const shouldSplit = hasNl && (isTask || !opts.plainTextBypass && this.plugin.settings.fileOutlinerPasteMultiline === "split");
    if (shouldSplit) {
      const sel = this.getActiveSelection();
      if (!sel || !this.outlinerFile)
        return;
      const ctx = this.getEngineContext();
      const markerLen = "[ ] ".length;
      const engineSel = isTask ? { ...sel, start: Math.max(sel.start, markerLen), end: Math.max(sel.end, markerLen) } : sel;
      const result = pasteSplitLines(this.outlinerFile, engineSel, raw, { now: ctx.now, generateId: ctx.generateId });
      if (!result.didChange)
        return;
      if (isTask) {
        const focusId = result.selection.id;
        for (const id of Array.from(result.dirtyIds)) {
          if (id === engineSel.id)
            continue;
          const b = this.findBlockInFile(result.file, id);
          if (!b)
            continue;
          const prev = String((_a2 = b.text) != null ? _a2 : "");
          const next = ensureTaskMarkerPrefixInBlockText(prev);
          if (next === prev)
            continue;
          b.text = next;
          if (id === focusId) {
            const delta = next.length - prev.length;
            result.selection.start += delta;
            result.selection.end += delta;
          }
        }
      }
      this.applyEngineResult(result);
      return;
    }
    const r = this.editorView.state.selection.main;
    const from = Math.min(r.from, r.to);
    const to = Math.max(r.from, r.to);
    this.editorView.dispatch({
      changes: { from, to, insert: raw },
      selection: { anchor: from + raw.length }
    });
  }
  injectAllowlistedEditorMenuItems(menu) {
    var _a2;
    if (!this.suggestEditor)
      return;
    const raw = Array.isArray(this.plugin.settings.fileOutlinerEditorContextMenuAllowedPlugins) ? this.plugin.settings.fileOutlinerEditorContextMenuAllowedPlugins : [];
    const allowed = new Set(raw.map((s2) => String(s2 != null ? s2 : "").trim().toLowerCase()).filter(Boolean));
    if (allowed.size === 0)
      return;
    menu.addSeparator();
    const wsAny = this.app.workspace;
    const handlers = (_a2 = wsAny == null ? void 0 : wsAny._) == null ? void 0 : _a2["editor-menu"];
    withPluginFilteredMenu(
      menu,
      { allowedPluginIds: allowed, blockedPluginIds: /* @__PURE__ */ new Set(["block-link-plus"]) },
      () => {
        var _a3;
        if (Array.isArray(handlers)) {
          for (const h of handlers) {
            const fn = h == null ? void 0 : h.fn;
            if (typeof fn !== "function")
              continue;
            try {
              fn(menu, this.suggestEditor, this);
            } catch (err) {
              this.debugLog("editorContextMenu/editor-menu/handler", err);
            }
          }
          return;
        }
        try {
          (_a3 = wsAny == null ? void 0 : wsAny.trigger) == null ? void 0 : _a3.call(wsAny, "editor-menu", menu, this.suggestEditor, this);
        } catch (err) {
          this.debugLog("editorContextMenu/editor-menu/trigger", err);
        }
      }
    );
  }
  closeEditorSuggests() {
    var _a2;
    const mgr = (_a2 = this.app.workspace) == null ? void 0 : _a2.editorSuggest;
    const suggests = Array.isArray(mgr == null ? void 0 : mgr.suggests) ? mgr.suggests : [];
    for (const s2 of suggests) {
      if (!(s2 == null ? void 0 : s2.isOpen))
        continue;
      this.tryOrLog("closeEditorSuggests/close", () => {
        var _a3;
        return (_a3 = s2.close) == null ? void 0 : _a3.call(s2);
      });
    }
  }
  render(opts) {
    const file = this.outlinerFile;
    this.ensureRoot();
    const root = this.topLevelBlocksEl;
    this.pruneZoomStack();
    if (!file || !root)
      return;
    this.renderZoomHeader();
    if (opts == null ? void 0 : opts.forceRebuild) {
      this.tryOrLog("render/forceRebuild/keepEditorHost", () => {
        if (this.editorHostEl && this.rootEl) {
          this.rootEl.appendChild(this.editorHostEl);
        }
      });
      this.dom.clearBlocks();
      this.display.reset();
    }
    const renderBlocks = this.getRenderBlocks(file);
    root.classList.toggle("is-blp-outliner-empty", renderBlocks.length === 0);
    this.syncBlockList(root, renderBlocks);
    this.pruneDom();
    if (this.pendingFocus) {
      const { id, cursorStart, cursorEnd } = this.pendingFocus;
      this.pendingFocus = null;
      this.enterEditMode(id, { cursorStart, cursorEnd, scroll: true });
    } else if (this.editingId) {
      this.enterEditMode(this.editingId, { cursorStart: 0, cursorEnd: 0, scroll: false, reuseExisting: true });
    }
    if (this.pendingScrollToId) {
      this.scrollToBlockId(this.pendingScrollToId);
    }
    try {
      this.display.refreshVisibleBlocksFromDom();
    } catch (err) {
      this.debugLog("render/refreshVisibleBlocksFromDom", err);
    }
    this.display.scheduleDisplayRenderDrain();
  }
  getZoomRootId() {
    var _a2;
    return this.zoomStack.length > 0 ? (_a2 = this.zoomStack[this.zoomStack.length - 1]) != null ? _a2 : null : null;
  }
  pruneZoomStack() {
    let changed = false;
    while (this.zoomStack.length > 0) {
      const id = this.zoomStack[this.zoomStack.length - 1];
      if (id && this.blockById.has(id))
        break;
      this.zoomStack.pop();
      changed = true;
    }
    if (changed)
      this.visibleNavCache = null;
  }
  getRenderBlocks(file) {
    var _a2, _b2;
    const rootId = this.getZoomRootId();
    if (!rootId)
      return (_a2 = file.blocks) != null ? _a2 : [];
    const root = this.blockById.get(rootId);
    return root ? [root] : (_b2 = file.blocks) != null ? _b2 : [];
  }
  renderZoomHeader() {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    const header = this.zoomHeaderEl;
    if (!header)
      return;
    const rootId = this.getZoomRootId();
    if (!rootId) {
      header.style.display = "none";
      header.replaceChildren();
      return;
    }
    header.style.display = "";
    header.replaceChildren();
    const back = document.createElement("button");
    back.type = "button";
    back.className = "blp-outliner-zoom-back";
    back.textContent = "Back";
    back.addEventListener("click", (evt) => {
      evt.preventDefault();
      evt.stopPropagation();
      this.zoomOut();
    });
    header.appendChild(back);
    const crumbs = document.createElement("div");
    crumbs.className = "blp-outliner-zoom-breadcrumbs";
    header.appendChild(crumbs);
    const addSep = () => {
      const sep = document.createElement("span");
      sep.className = "blp-outliner-zoom-sep";
      sep.textContent = ">";
      crumbs.appendChild(sep);
    };
    const addCrumb = (opts) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "blp-outliner-zoom-crumb";
      if (opts.isCurrent)
        btn.classList.add("is-blp-outliner-zoom-current");
      btn.textContent = opts.text;
      if (opts.onClick) {
        btn.addEventListener("click", (evt) => {
          var _a3;
          evt.preventDefault();
          evt.stopPropagation();
          (_a3 = opts.onClick) == null ? void 0 : _a3.call(opts);
        });
      } else {
        btn.disabled = true;
      }
      crumbs.appendChild(btn);
    };
    const fileCrumbText = (_d2 = (_c2 = (_a2 = this.file) == null ? void 0 : _a2.basename) != null ? _c2 : (_b2 = this.file) == null ? void 0 : _b2.path) != null ? _d2 : "File";
    addCrumb({
      text: fileCrumbText,
      onClick: () => {
        var _a3, _b3;
        const focusId = this.getZoomRootId();
        if (this.editingId)
          this.exitEditMode(this.editingId);
        this.zoomStack = [];
        this.visibleNavCache = null;
        if (focusId && this.blockById.has(focusId)) {
          const end = String((_b3 = (_a3 = this.blockById.get(focusId)) == null ? void 0 : _a3.text) != null ? _b3 : "").length;
          this.pendingFocus = { id: focusId, cursorStart: end, cursorEnd: end };
          this.pendingScrollToId = focusId;
        }
        this.render({ forceRebuild: true });
      }
    });
    for (let i = 0; i < this.zoomStack.length; i++) {
      const id = this.zoomStack[i];
      if (!id)
        continue;
      addSep();
      const block = this.blockById.get(id);
      const title = (_f2 = String((_e2 = block == null ? void 0 : block.text) != null ? _e2 : id).split("\n")[0]) != null ? _f2 : id;
      const isCurrent = i === this.zoomStack.length - 1;
      addCrumb({
        text: title,
        isCurrent,
        onClick: isCurrent ? void 0 : () => {
          var _a3, _b3;
          if (this.editingId)
            this.exitEditMode(this.editingId);
          this.zoomStack = this.zoomStack.slice(0, i + 1);
          this.visibleNavCache = null;
          const focusId = this.getZoomRootId();
          if (focusId && this.blockById.has(focusId)) {
            const end = String((_b3 = (_a3 = this.blockById.get(focusId)) == null ? void 0 : _a3.text) != null ? _b3 : "").length;
            this.pendingFocus = { id: focusId, cursorStart: end, cursorEnd: end };
            this.pendingScrollToId = focusId;
          }
          this.render({ forceRebuild: true });
        }
      });
    }
  }
  isDescendantOrSelf(descendantId, ancestorId) {
    var _a2;
    let cur = descendantId;
    while (cur) {
      if (cur === ancestorId)
        return true;
      cur = (_a2 = this.parentById.get(cur)) != null ? _a2 : null;
    }
    return false;
  }
  setCollapsed(id, collapsed) {
    var _a2, _b2;
    const block = this.blockById.get(id);
    const hasChildren = ((_b2 = (_a2 = block == null ? void 0 : block.children) == null ? void 0 : _a2.length) != null ? _b2 : 0) > 0;
    if (!hasChildren) {
      this.collapsedIds.delete(id);
      collapsed = false;
    }
    if (collapsed)
      this.collapsedIds.add(id);
    else
      this.collapsedIds.delete(id);
    this.visibleNavCache = null;
    const el = this.dom.getBlockEl(id);
    if (el)
      el.classList.toggle("is-blp-outliner-collapsed", collapsed);
    const childrenContainer = this.dom.getChildrenContainerEl(id);
    if (childrenContainer)
      childrenContainer.style.display = collapsed ? "none" : "";
    if (collapsed && this.editingId && this.isDescendantOrSelf(this.editingId, id) && this.editingId !== id) {
      this.exitEditMode(this.editingId);
    }
  }
  toggleCollapsed(id) {
    this.setCollapsed(id, !this.collapsedIds.has(id));
  }
  zoomInto(id) {
    var _a2, _b2, _c2;
    const current = this.getZoomRootId();
    if (current === id)
      return;
    if (!this.blockById.has(id))
      return;
    if (this.editingId)
      this.exitEditMode(this.editingId);
    const nextStack = [];
    const visited = /* @__PURE__ */ new Set();
    let cur = id;
    while (cur && !visited.has(cur)) {
      visited.add(cur);
      nextStack.push(cur);
      cur = (_a2 = this.parentById.get(cur)) != null ? _a2 : null;
    }
    nextStack.reverse();
    this.zoomStack = nextStack;
    this.visibleNavCache = null;
    const end = String((_c2 = (_b2 = this.blockById.get(id)) == null ? void 0 : _b2.text) != null ? _c2 : "").length;
    this.pendingFocus = { id, cursorStart: end, cursorEnd: end };
    this.render({ forceRebuild: true });
  }
  zoomOut() {
    var _a2, _b2, _c2, _d2;
    if (this.zoomStack.length === 0)
      return;
    if (this.editingId)
      this.exitEditMode(this.editingId);
    const popped = this.zoomStack.pop();
    this.visibleNavCache = null;
    const focusId = (_b2 = (_a2 = this.getZoomRootId()) != null ? _a2 : popped) != null ? _b2 : null;
    if (focusId) {
      const end = String((_d2 = (_c2 = this.blockById.get(focusId)) == null ? void 0 : _c2.text) != null ? _d2 : "").length;
      this.pendingFocus = { id: focusId, cursorStart: end, cursorEnd: end };
      this.pendingScrollToId = focusId;
    }
    this.render({ forceRebuild: true });
  }
  insertAfterBlock(id) {
    if (!this.outlinerFile)
      return;
    const ctx = this.getEngineContext();
    this.applyEngineResult(insertAfter(this.outlinerFile, id, ctx));
  }
  insertFirstBlock() {
    if (!this.outlinerFile)
      return;
    const ctx = this.getEngineContext();
    this.applyEngineResult(insertAtRootEnd(this.outlinerFile, ctx));
  }
  toggleTaskStatusForBlock(id) {
    var _a2;
    const b = this.blockById.get(id);
    if (!b)
      return;
    const doc = String((_a2 = b.text) != null ? _a2 : "");
    const nl = doc.indexOf("\n");
    const firstLineEnd = nl >= 0 ? nl : doc.length;
    const firstLine = doc.slice(0, firstLineEnd);
    const nextFirstLine = toggleTaskStatusMarkerPrefix(firstLine);
    if (nextFirstLine === firstLine)
      return;
    b.text = `${nextFirstLine}${doc.slice(firstLineEnd)}`;
    this.markDirtyAndRequestSave({ dirtyIds: [id] });
    this.display.renderBlockDisplay(id);
  }
  toggleTaskMarkerForBlock(id) {
    var _a2;
    const b = this.blockById.get(id);
    if (!b)
      return;
    const doc = String((_a2 = b.text) != null ? _a2 : "");
    const nl = doc.indexOf("\n");
    const firstLineEnd = nl >= 0 ? nl : doc.length;
    const firstLine = doc.slice(0, firstLineEnd);
    const nextFirstLine = toggleTaskMarkerPrefix(firstLine);
    if (nextFirstLine === firstLine)
      return;
    const nextDoc = `${nextFirstLine}${doc.slice(firstLineEnd)}`;
    b.text = nextDoc;
    if (getTaskMarkerFromBlockText(nextDoc) && nextDoc.includes("\n")) {
      this.extractTaskRemainderToChildBlock(id, nextDoc);
      return;
    }
    this.markDirtyAndRequestSave({ dirtyIds: [id] });
    this.display.renderBlockDisplay(id);
  }
  extractTaskRemainderToChildBlock(id, doc) {
    var _a2, _b2;
    if (!this.outlinerFile)
      return;
    const b = this.blockById.get(id);
    if (!b)
      return;
    const nl = doc.indexOf("\n");
    if (nl < 0)
      return;
    const firstLine = doc.slice(0, nl);
    const rest = doc.slice(nl + 1);
    if (!getTaskMarkerFromBlockText(firstLine))
      return;
    b.text = firstLine;
    const dirtyIds = [id];
    if (rest.trim().length > 0) {
      const ctx = this.getEngineContext();
      const childId = this.generateUniqueId();
      const child = {
        id: childId,
        depth: Math.max(0, ((_a2 = b.depth) != null ? _a2 : 0) + 1),
        text: rest,
        children: [],
        system: { date: ctx.now, updated: ctx.now, extra: {} },
        _systemHasBlpMarker: true
      };
      b.children = [child, ...(_b2 = b.children) != null ? _b2 : []];
      dirtyIds.push(childId);
    }
    this.visibleNavCache = null;
    this.rebuildIndex();
    this.render();
    this.markDirtyAndRequestSave({ dirtyIds });
  }
  async copyBlockSubtree(id) {
    const b = this.blockById.get(id);
    if (!b)
      return;
    const text = serializeOutlinerBlocksForClipboard([b], { indentSize: this.indentSize });
    await navigator.clipboard.writeText(text);
  }
  openBulletMenu(id, evt) {
    var _a2, _b2, _c2;
    if (!this.outlinerFile)
      return;
    if (!this.file)
      return;
    const block = this.blockById.get(id);
    if (!block)
      return;
    const menu = new import_obsidian19.Menu();
    const labels = getFileOutlinerContextMenuLabels();
    const caretId = `^${id}`;
    menu.addItem((item) => {
      item.setTitle(labels.copyBlockReference).onClick(() => {
        copyToClipboard(this.app, this.plugin.settings, this.file, caretId, false, void 0, false);
      });
    });
    menu.addItem((item) => {
      item.setTitle(labels.copyBlockEmbed).onClick(() => {
        copyToClipboard(this.app, this.plugin.settings, this.file, caretId, true, void 0, false);
      });
    });
    menu.addItem((item) => {
      item.setTitle(labels.copyBlockUrl).onClick(() => {
        copyToClipboard(this.app, this.plugin.settings, this.file, caretId, false, void 0, true);
      });
    });
    menu.addSeparator();
    const isTask = Boolean(getTaskMarkerFromBlockText((_a2 = block.text) != null ? _a2 : ""));
    menu.addItem((item) => {
      item.setTitle(isTask ? labels.convertToNormalBlock : labels.convertToTask).onClick(() => {
        if (this.editingId === id) {
          this.onEditorToggleTaskMarker();
          return;
        }
        this.toggleTaskMarkerForBlock(id);
      });
    });
    menu.addSeparator();
    menu.addItem((item) => {
      item.setTitle(labels.copy).onClick(() => {
        void this.copyBlockSubtree(id);
      });
    });
    menu.addItem((item) => {
      item.setTitle(labels.cut).onClick(() => {
        void (async () => {
          await this.copyBlockSubtree(id);
          if (this.editingId)
            this.exitEditMode(this.editingId);
          const ctx = this.getEngineContext();
          this.applyEngineResult(deleteBlock(this.outlinerFile, id, ctx));
        })();
      });
    });
    menu.addItem((item) => {
      item.setTitle(labels.delete).onClick(() => {
        if (this.editingId)
          this.exitEditMode(this.editingId);
        const ctx = this.getEngineContext();
        this.applyEngineResult(deleteBlock(this.outlinerFile, id, ctx));
      });
    });
    menu.addSeparator();
    const hasChildren = ((_c2 = (_b2 = block.children) == null ? void 0 : _b2.length) != null ? _c2 : 0) > 0;
    const isCollapsed = this.collapsedIds.has(id);
    menu.addItem((item) => {
      item.setTitle(labels.collapse).setDisabled(!hasChildren || isCollapsed).onClick(() => this.setCollapsed(id, true));
    });
    menu.addItem((item) => {
      item.setTitle(labels.expand).setDisabled(!hasChildren || !isCollapsed).onClick(() => this.setCollapsed(id, false));
    });
    menu.showAtMouseEvent(evt);
  }
  isSelfOrDescendant(rootId, id) {
    var _a2;
    let cur = id;
    for (let i = 0; i < 200 && cur; i++) {
      if (cur === rootId)
        return true;
      cur = (_a2 = this.parentById.get(cur)) != null ? _a2 : null;
    }
    return false;
  }
  syncBlockList(container, blocks) {
    var _a2, _b2, _c2, _d2;
    for (const block of blocks) {
      const el = this.dom.ensureBlockElement(block.id);
      const hasChildren = ((_b2 = (_a2 = block.children) == null ? void 0 : _a2.length) != null ? _b2 : 0) > 0;
      el.setAttribute("haschild", hasChildren ? "true" : "false");
      el.setAttribute("level", String(((_c2 = block.depth) != null ? _c2 : 0) + 1));
      const collapsed = hasChildren && this.collapsedIds.has(block.id);
      if (!hasChildren)
        this.collapsedIds.delete(block.id);
      el.classList.toggle("is-blp-outliner-collapsed", collapsed);
      const childrenContainer = this.dom.getChildrenContainerEl(block.id);
      if (childrenContainer)
        childrenContainer.style.display = collapsed ? "none" : "";
      container.appendChild(el);
      this.display.ensurePlaceholderAndScheduleFirstRender(block.id);
      const children = this.dom.getChildrenEl(block.id);
      if (children)
        this.syncBlockList(children, (_d2 = block.children) != null ? _d2 : []);
    }
  }
  pruneDom() {
    for (const [id] of Array.from(this.dom.getBlockElEntries())) {
      if (this.blockById.has(id))
        continue;
      this.display.removeBlock(id);
      if (this.editingId === id) {
        this.editingId = null;
        this.updateActiveEditorBridge();
        this.tryOrLog("pruneDom/removeEditorHost", () => {
          var _a2;
          return (_a2 = this.editorHostEl) == null ? void 0 : _a2.remove();
        });
        if (this.editorHostEl && this.rootEl) {
          this.rootEl.appendChild(this.editorHostEl);
          this.editorHostEl.style.display = "none";
        }
      }
      this.dom.removeBlock(id);
      this.collapsedIds.delete(id);
    }
  }
  enterEditMode(id, opts) {
    var _a2, _b2;
    this.ensureRoot();
    if (!this.editorHostEl || !this.editorView)
      return;
    if (!this.outlinerFile)
      return;
    if (this.editingId !== id && !this.preserveArrowNavGoalOnce) {
      this.resetArrowNavGoalColumn();
    }
    const block = this.blockById.get(id);
    const host = this.dom.getBlockContentEl(id);
    const display = this.dom.getDisplayEl(id);
    if (!block || !host || !display) {
      if (!opts.reuseExisting)
        this.render({ forceRebuild: true });
      return;
    }
    if (this.editingId && this.editingId !== id) {
      this.exitEditMode(this.editingId);
    }
    this.editingId = id;
    if (this.pendingBlurTimer) {
      window.clearTimeout(this.pendingBlurTimer);
      this.pendingBlurTimer = null;
    }
    for (const [prevId, prevEl] of this.dom.getBlockElEntries()) {
      if (prevId !== id)
        prevEl.classList.remove("is-blp-outliner-active");
    }
    (_a2 = this.dom.getBlockEl(id)) == null ? void 0 : _a2.classList.add("is-blp-outliner-active");
    display.style.display = "none";
    host.appendChild(this.editorHostEl);
    this.editorHostEl.style.display = "";
    if (!opts.reuseExisting) {
      this.suppressEditorSync = true;
      try {
        this.editorView.setState(this.createEditorState((_b2 = block.text) != null ? _b2 : "", opts));
      } finally {
        this.suppressEditorSync = false;
      }
    }
    this.editorView.focus();
    this.updateActiveEditorBridge();
    if (opts.scroll) {
      this.editorHostEl.scrollIntoView({ block: "nearest" });
    }
  }
  exitEditMode(id) {
    var _a2;
    const editor = this.editorView;
    const editorHost = this.editorHostEl;
    const display = this.dom.getDisplayEl(id);
    const b = this.blockById.get(id);
    if (!editor || !editorHost || !display)
      return;
    if (this.pendingBlurTimer) {
      window.clearTimeout(this.pendingBlurTimer);
      this.pendingBlurTimer = null;
    }
    if (b) {
      const nextText = editor.state.doc.toString();
      if (b.text !== nextText) {
        b.text = nextText;
        this.dirtyBlockIds.add(id);
      }
    }
    this.editingId = null;
    this.updateActiveEditorBridge();
    this.closeEditorSuggests();
    (_a2 = this.dom.getBlockEl(id)) == null ? void 0 : _a2.classList.remove("is-blp-outliner-active");
    editorHost.style.display = "none";
    if (this.rootEl) {
      this.rootEl.appendChild(editorHost);
    }
    display.style.display = "";
    this.display.renderBlockDisplay(id);
    if (!this.preserveArrowNavGoalOnce) {
      this.resetArrowNavGoalColumn();
    }
    this.markDirtyAndRequestSave();
  }
  getActiveSelection() {
    if (!this.outlinerFile)
      return null;
    if (!this.editorView)
      return null;
    const id = this.editingId;
    if (!id)
      return null;
    const block = this.blockById.get(id);
    if (!block)
      return null;
    const value = this.editorView.state.doc.toString();
    block.text = value;
    const range = this.editorView.state.selection.main;
    const start = Math.min(range.from, range.to);
    const end = Math.max(range.from, range.to);
    return { id, start, end };
  }
  getEngineContext() {
    var _a2, _b2;
    const now2 = formatSystemDate2(DateTime.now());
    return {
      now: now2,
      generateId: () => this.generateUniqueId(),
      childrenOnSplit: (_a2 = this.plugin.settings.fileOutlinerChildrenOnSplit) != null ? _a2 : "keep",
      backspaceWithChildren: (_b2 = this.plugin.settings.fileOutlinerBackspaceWithChildren) != null ? _b2 : "merge"
    };
  }
  applyEngineResult(result, opts) {
    if (!result.didChange)
      return;
    this.ensureRoot();
    this.outlinerFile = result.file;
    this.visibleNavCache = null;
    this.rebuildIndex();
    for (const id of Array.from(result.dirtyIds)) {
      this.dirtyBlockIds.add(id);
    }
    const shouldFocus = (opts == null ? void 0 : opts.focus) !== false;
    if (shouldFocus) {
      this.pendingFocus = {
        id: result.selection.id,
        cursorStart: result.selection.start,
        cursorEnd: result.selection.end
      };
    } else {
      this.pendingFocus = null;
      this.pendingScrollToId = result.selection.id;
    }
    this.render();
    for (const id of Array.from(result.dirtyIds)) {
      if (id === this.editingId)
        continue;
      this.display.renderBlockPlaceholder(id);
      this.display.markNeedsRender(id);
    }
    this.display.scheduleDisplayRenderDrain();
    this.markDirtyAndRequestSave();
  }
  onEditorDocChanged(nextText) {
    if (this.suppressEditorSync)
      return;
    const id = this.editingId;
    if (!id)
      return;
    const b = this.blockById.get(id);
    if (!b)
      return;
    b.text = nextText;
    this.markDirtyAndRequestSave({ dirtyIds: [id] });
  }
  onEditorBlur() {
    const id = this.editingId;
    const editor = this.editorView;
    const editorHost = this.editorHostEl;
    if (!id || !editor || !editorHost)
      return;
    if (this.pendingBlurTimer)
      window.clearTimeout(this.pendingBlurTimer);
    this.pendingBlurTimer = window.setTimeout(() => {
      this.pendingBlurTimer = null;
      if (this.editingId !== id)
        return;
      const active = document.activeElement;
      if (active && editorHost.contains(active))
        return;
      if (active && this.contentEl.contains(active))
        return;
      this.exitEditMode(id);
    }, 32);
  }
  resetArrowNavGoalColumn() {
    this.arrowNavGoalCh = null;
  }
  getVisibleBlockNav() {
    if (this.visibleNavCache)
      return this.visibleNavCache;
    if (!this.outlinerFile)
      return { order: [], indexById: /* @__PURE__ */ new Map() };
    const nav = computeVisibleBlockNav(this.getRenderBlocks(this.outlinerFile), this.collapsedIds);
    this.visibleNavCache = nav;
    return nav;
  }
  onEditorArrowNavigate(dir, editor) {
    var _a2, _b2, _c2, _d2;
    if (!this.outlinerFile)
      return false;
    if (!this.editingId)
      return false;
    const mgr = (_a2 = this.app.workspace) == null ? void 0 : _a2.editorSuggest;
    if ((_b2 = mgr == null ? void 0 : mgr.currentSuggest) == null ? void 0 : _b2.isOpen)
      return false;
    const r = editor.state.selection.main;
    if (!r.empty)
      return false;
    const before = { anchor: r.anchor, head: r.head };
    const beforeLine = editor.state.doc.lineAt(before.head);
    const beforeCh = before.head - beforeLine.from;
    if (this.arrowNavGoalCh === null)
      this.arrowNavGoalCh = beforeCh;
    const goalCh = this.arrowNavGoalCh;
    const beforeCoords = editor.coordsAtPos(before.head);
    const moved = editor.moveVertically(r, dir === "down");
    if (beforeCoords) {
      const afterCoords = editor.coordsAtPos(moved.head);
      if (!afterCoords) {
        this.arrowNavDispatching = true;
        try {
          editor.dispatch({ selection: import_state7.EditorSelection.create([moved]) });
        } finally {
          this.arrowNavDispatching = false;
        }
        return true;
      }
      const dy = afterCoords.top - beforeCoords.top;
      const movedVert = Math.abs(dy) >= 1;
      if (movedVert) {
        this.arrowNavDispatching = true;
        try {
          editor.dispatch({ selection: import_state7.EditorSelection.create([moved]) });
        } finally {
          this.arrowNavDispatching = false;
        }
        return true;
      }
    } else {
      this.arrowNavDispatching = true;
      try {
        editor.dispatch({ selection: import_state7.EditorSelection.create([moved]) });
      } finally {
        this.arrowNavDispatching = false;
      }
      return true;
    }
    const currentId = this.editingId;
    const nav = this.getVisibleBlockNav();
    const nextId = findAdjacentVisibleBlockId(nav, currentId, dir);
    if (!nextId)
      return true;
    const nextBlock = this.blockById.get(nextId);
    if (!nextBlock)
      return true;
    const cursor = dir === "up" ? cursorPosAtLastLine((_c2 = nextBlock.text) != null ? _c2 : "", goalCh) : cursorPosAtFirstLine((_d2 = nextBlock.text) != null ? _d2 : "", goalCh);
    this.preserveArrowNavGoalOnce = true;
    try {
      this.enterEditMode(nextId, { cursorStart: cursor, cursorEnd: cursor, scroll: true });
    } finally {
      this.preserveArrowNavGoalOnce = false;
    }
    return true;
  }
  onEditorSoftEnter(editor) {
    if (!this.outlinerFile)
      return false;
    if (!this.editingId)
      return false;
    const doc = editor.state.doc.toString();
    const isTask = Boolean(getTaskMarkerFromBlockText(doc));
    if (isTask) {
      return this.onEditorEnter();
    }
    const r = editor.state.selection.main;
    const from = Math.min(r.from, r.to);
    const to = Math.max(r.from, r.to);
    editor.dispatch({
      changes: { from, to, insert: "\n" },
      selection: { anchor: from + 1 }
    });
    return true;
  }
  findBlockInFile(file, id) {
    var _a2;
    const walk = (list) => {
      var _a3;
      for (const b of list) {
        if (b.id === id)
          return b;
        const child = walk((_a3 = b.children) != null ? _a3 : []);
        if (child)
          return child;
      }
      return null;
    };
    return walk((_a2 = file.blocks) != null ? _a2 : []);
  }
  onEditorEnter() {
    var _a2, _b2;
    if (!this.outlinerFile)
      return false;
    const sel = this.getActiveSelection();
    if (!sel)
      return false;
    const ctx = this.getEngineContext();
    const activeId = sel.id;
    const active = this.blockById.get(activeId);
    const activeText = String((_a2 = active == null ? void 0 : active.text) != null ? _a2 : "");
    const isTask = Boolean(getTaskMarkerFromBlockText(activeText));
    if (!isTask) {
      this.applyEngineResult(splitAtSelection(this.outlinerFile, sel, ctx));
      return true;
    }
    const markerLen = "[ ] ".length;
    const clamped = {
      ...sel,
      start: Math.max(sel.start, markerLen),
      end: Math.max(sel.end, markerLen)
    };
    const result = splitAtSelection(this.outlinerFile, clamped, ctx);
    if (!result.didChange)
      return true;
    const createdId = result.selection.id;
    const created = this.findBlockInFile(result.file, createdId);
    if (created) {
      created.text = ensureTodoTaskMarkerPrefixInBlockText((_b2 = created.text) != null ? _b2 : "");
    }
    result.selection.start = markerLen;
    result.selection.end = markerLen;
    this.applyEngineResult(result);
    return true;
  }
  onEditorTab(shift) {
    if (!this.outlinerFile)
      return false;
    const sel = this.getActiveSelection();
    if (!sel)
      return false;
    this.applyEngineResult(shift ? outdentBlock(this.outlinerFile, sel) : indentBlock(this.outlinerFile, sel));
    return true;
  }
  onEditorBackspace() {
    if (!this.outlinerFile)
      return false;
    const sel = this.getActiveSelection();
    if (!sel)
      return false;
    if (sel.start !== 0 || sel.end !== 0)
      return false;
    const ctx = this.getEngineContext();
    this.applyEngineResult(backspaceAtStart(this.outlinerFile, sel, { backspaceWithChildren: ctx.backspaceWithChildren }));
    return true;
  }
  onEditorDelete() {
    if (!this.outlinerFile)
      return false;
    const sel = this.getActiveSelection();
    if (!sel)
      return false;
    if (!this.editorView)
      return false;
    const valueLen = this.editorView.state.doc.length;
    if (sel.start !== valueLen || sel.end !== valueLen)
      return false;
    this.applyEngineResult(mergeWithNext(this.outlinerFile, sel));
    return true;
  }
  consumePlainTextPasteBypass() {
    const t = this.lastPlainPasteShortcutAt;
    this.lastPlainPasteShortcutAt = 0;
    return t !== 0 && Date.now() - t < 750;
  }
  onEditorToggleTask() {
    const editor = this.editorView;
    if (!editor)
      return false;
    if (!this.editingId)
      return false;
    const doc = editor.state.doc.toString();
    const nl = doc.indexOf("\n");
    const firstLineEnd = nl >= 0 ? nl : doc.length;
    const firstLine = doc.slice(0, firstLineEnd);
    const nextFirstLine = toggleTaskStatusMarkerPrefix(firstLine);
    if (nextFirstLine === firstLine)
      return false;
    const delta = nextFirstLine.length - firstLine.length;
    const nextLen = doc.length + delta;
    const clamp3 = (n2) => Math.max(0, Math.min(nextLen, Math.floor(n2)));
    const r = editor.state.selection.main;
    editor.dispatch({
      changes: { from: 0, to: firstLineEnd, insert: nextFirstLine },
      selection: { anchor: clamp3(r.anchor + delta), head: clamp3(r.head + delta) }
    });
    return true;
  }
  onEditorToggleTaskMarker() {
    const editor = this.editorView;
    if (!editor)
      return false;
    if (!this.editingId)
      return false;
    const doc = editor.state.doc.toString();
    const nl = doc.indexOf("\n");
    const firstLineEnd = nl >= 0 ? nl : doc.length;
    const firstLine = doc.slice(0, firstLineEnd);
    const nextFirstLine = toggleTaskMarkerPrefix(firstLine);
    if (nextFirstLine === firstLine)
      return false;
    const delta = nextFirstLine.length - firstLine.length;
    const nextLen = doc.length + delta;
    const clamp3 = (n2) => Math.max(0, Math.min(nextLen, Math.floor(n2)));
    const r = editor.state.selection.main;
    editor.dispatch({
      changes: { from: 0, to: firstLineEnd, insert: nextFirstLine },
      selection: { anchor: clamp3(r.anchor + delta), head: clamp3(r.head + delta) }
    });
    const nextDoc = editor.state.doc.toString();
    if (getTaskMarkerFromBlockText(nextDoc) && nextDoc.includes("\n")) {
      const nl2 = nextDoc.indexOf("\n");
      this.extractTaskRemainderToChildBlock(this.editingId, nextDoc);
      const r2 = editor.state.selection.main;
      const clamp22 = (n2) => Math.max(0, Math.min(nl2, Math.floor(n2)));
      editor.dispatch({
        changes: { from: nl2, to: nextDoc.length, insert: "" },
        selection: { anchor: clamp22(r2.anchor), head: clamp22(r2.head) }
      });
    }
    return true;
  }
  onEditorPaste(evt) {
    var _a2, _b2, _c2;
    if (!this.outlinerFile)
      return false;
    const raw = (_b2 = (_a2 = evt.clipboardData) == null ? void 0 : _a2.getData("text/plain")) != null ? _b2 : "";
    if (!raw.includes("\n") && !raw.includes("\r"))
      return false;
    const editor = this.editorView;
    const isTask = Boolean(editor && getTaskMarkerFromBlockText(editor.state.doc.toString()));
    const bypass = this.consumePlainTextPasteBypass();
    if (!isTask) {
      if (bypass)
        return false;
      if (this.plugin.settings.fileOutlinerPasteMultiline !== "split")
        return false;
    }
    const sel = this.getActiveSelection();
    if (!sel)
      return false;
    evt.preventDefault();
    evt.stopPropagation();
    const ctx = this.getEngineContext();
    const markerLen = "[ ] ".length;
    const engineSel = isTask ? { ...sel, start: Math.max(sel.start, markerLen), end: Math.max(sel.end, markerLen) } : sel;
    const result = pasteSplitLines(this.outlinerFile, engineSel, raw, { now: ctx.now, generateId: ctx.generateId });
    if (!result.didChange)
      return true;
    if (isTask) {
      const focusId = result.selection.id;
      for (const id of Array.from(result.dirtyIds)) {
        if (id === engineSel.id)
          continue;
        const b = this.findBlockInFile(result.file, id);
        if (!b)
          continue;
        const prev = String((_c2 = b.text) != null ? _c2 : "");
        const next = ensureTaskMarkerPrefixInBlockText(prev);
        if (next === prev)
          continue;
        b.text = next;
        if (id === focusId) {
          const delta = next.length - prev.length;
          result.selection.start += delta;
          result.selection.end += delta;
        }
      }
    }
    this.applyEngineResult(result);
    return true;
  }
  scrollToBlockId(id) {
    var _a2;
    const sel = `[data-blp-outliner-id="${((_a2 = window.CSS) == null ? void 0 : _a2.escape) ? window.CSS.escape(id) : id}"]`;
    const row = this.contentEl.querySelector(sel);
    if (!row)
      return;
    row.scrollIntoView({ block: "center" });
    row.addClass("is-blp-outliner-target");
    window.setTimeout(() => row.removeClass("is-blp-outliner-target"), 1500);
    this.pendingScrollToId = null;
  }
};

// src/features/file-outliner-view/routing.ts
var import_obsidian20 = require("obsidian");
function registerFileOutlinerRouting(plugin) {
  plugin.register(
    around(import_obsidian20.WorkspaceLeaf.prototype, {
      openFile(old) {
        return async function(file, openState) {
          var _a2;
          const leafAny = this;
          if (isDetachedLeaf(this) || (leafAny == null ? void 0 : leafAny.parent) == null) {
            return old.call(this, file, openState);
          }
          try {
            if (file instanceof import_obsidian20.TFile && ((_a2 = file.extension) == null ? void 0 : _a2.toLowerCase()) === "md") {
              if (isFileOutlinerEnabledFile(plugin, file)) {
                if (plugin.settings.fileOutlinerViewEnabled === false) {
                  return old.call(this, file, openState);
                }
                const viewState = {
                  type: FILE_OUTLINER_VIEW_TYPE,
                  state: { file: file.path },
                  active: openState == null ? void 0 : openState.active
                };
                await this.setViewState(viewState, openState == null ? void 0 : openState.eState);
                if ((openState == null ? void 0 : openState.active) !== false) {
                  try {
                    plugin.app.workspace.setActiveLeaf(this, { focus: true });
                  } catch (e) {
                  }
                }
                return;
              }
            }
          } catch (e) {
          }
          return old.call(this, file, openState);
        };
      }
    })
  );
}

// src/features/file-outliner-view/markdown-pane-menu.ts
var import_obsidian21 = require("obsidian");
function addOpenAsOutlinerPaneMenuItems(menu, opts) {
  const labels = getFileOutlinerPaneMenuLabels();
  menu.addSeparator();
  menu.addItem((item) => {
    item.setTitle(labels.openAsOutliner).setIcon("list").onClick(opts.openSameLeaf);
  });
  menu.addItem((item) => {
    item.setTitle(labels.openAsOutlinerNewTab).setIcon("copy").onClick(opts.openNewTab);
  });
}
async function openOutlinerFromMarkdownView(plugin, view, file, opts) {
  var _a2;
  try {
    await ((_a2 = view.save) == null ? void 0 : _a2.call(view));
  } catch (e) {
  }
  const leaf = opts.newLeaf ? plugin.app.workspace.getLeaf(opts.newLeaf) : view.leaf;
  await leaf.setViewState({
    type: FILE_OUTLINER_VIEW_TYPE,
    state: { file: file.path },
    active: true
  });
  try {
    plugin.app.workspace.setActiveLeaf(leaf, { focus: true });
  } catch (e) {
  }
}
function registerFileOutlinerMarkdownPaneMenu(plugin) {
  plugin.register(
    around(import_obsidian21.MarkdownView.prototype, {
      onPaneMenu(old) {
        return function(menu, source) {
          var _a2;
          old.call(this, menu, source);
          try {
            if (source !== "more-options")
              return;
            const file = this.file;
            if (!(file instanceof import_obsidian21.TFile))
              return;
            if (((_a2 = file.extension) == null ? void 0 : _a2.toLowerCase()) !== "md")
              return;
            if (!isFileOutlinerEnabledFile(plugin, file))
              return;
            addOpenAsOutlinerPaneMenuItems(menu, {
              openSameLeaf: () => void openOutlinerFromMarkdownView(plugin, this, file, {
                newLeaf: false
              }),
              openNewTab: () => void openOutlinerFromMarkdownView(plugin, this, file, {
                newLeaf: "tab"
              })
            });
          } catch (e) {
          }
        };
      }
    })
  );
}

// src/features/file-outliner-view/commands.ts
var FILE_OUTLINER_COMMAND_IDS = {
  toggleTaskStatus: "file-outliner-toggle-task-status",
  toggleTaskMarker: "file-outliner-toggle-task-marker"
};
function getActiveOutlinerView(plugin) {
  try {
    const leaf = plugin.app.workspace.activeLeaf;
    const view = leaf == null ? void 0 : leaf.view;
    if (!view)
      return null;
    if (typeof view.getViewType === "function" && view.getViewType() === FILE_OUTLINER_VIEW_TYPE)
      return view;
    return null;
  } catch (e) {
    return null;
  }
}
function registerFileOutlinerCommands(plugin) {
  const labels = getFileOutlinerCommandLabels();
  plugin.addCommand({
    id: FILE_OUTLINER_COMMAND_IDS.toggleTaskStatus,
    name: labels.toggleTaskStatus,
    hotkeys: [{ modifiers: ["Mod"], key: "Enter" }],
    checkCallback: (checking) => {
      const view = getActiveOutlinerView(plugin);
      if (!view)
        return false;
      if (typeof view.toggleActiveTaskStatus !== "function")
        return false;
      if (checking)
        return true;
      return Boolean(view.toggleActiveTaskStatus());
    }
  });
  plugin.addCommand({
    id: FILE_OUTLINER_COMMAND_IDS.toggleTaskMarker,
    name: labels.toggleTaskMarker,
    hotkeys: [{ modifiers: ["Mod", "Shift"], key: "Enter" }],
    checkCallback: (checking) => {
      const view = getActiveOutlinerView(plugin);
      if (!view)
        return false;
      if (typeof view.toggleActiveTaskMarker !== "function")
        return false;
      if (checking)
        return true;
      return Boolean(view.toggleActiveTaskMarker());
    }
  });
}

// src/features/file-outliner-view/editor-command-bridge.ts
function normalizePluginId3(raw) {
  const s2 = String(raw != null ? raw : "").trim().toLowerCase();
  return s2 ? s2 : "core";
}
function getAllowlistedPluginIds(plugin) {
  var _a2, _b2;
  const raw = Array.isArray(plugin.settings.fileOutlinerEditorCommandAllowedPlugins) ? plugin.settings.fileOutlinerEditorCommandAllowedPlugins : [];
  const out = new Set(raw.map(normalizePluginId3).filter(Boolean));
  out.add(normalizePluginId3((_b2 = (_a2 = plugin.manifest) == null ? void 0 : _a2.id) != null ? _b2 : "block-link-plus"));
  return out;
}
function isFileOutlinerActiveEditorBridge(activeEditor) {
  return !!activeEditor && activeEditor.__blpFileOutlinerBridge === true;
}
function isEditorCommand(command) {
  if (!command)
    return false;
  if (typeof command.editorCallback === "function")
    return true;
  if (typeof command.editorCheckCallback === "function")
    return true;
  if (typeof command.id === "string" && command.id.startsWith("editor:"))
    return true;
  return false;
}
function getInstalledPluginIdSet(plugin) {
  var _a2, _b2;
  const manifests = (_b2 = (_a2 = plugin.app) == null ? void 0 : _a2.plugins) == null ? void 0 : _b2.manifests;
  const ids = manifests && typeof manifests === "object" ? Object.keys(manifests) : [];
  return new Set(ids.map(normalizePluginId3));
}
function getCommandOwnerPluginId(plugin, commandId) {
  const id = String(commandId != null ? commandId : "");
  const prefix = normalizePluginId3(id.includes(":") ? id.split(":")[0] : "");
  if (!prefix || prefix === "core")
    return "core";
  const installed = getInstalledPluginIdSet(plugin);
  return installed.has(prefix) ? prefix : "core";
}
function shouldAllowEditorCommandInOutliner(plugin, command) {
  var _a2;
  if (plugin.settings.fileOutlinerEditorCommandBridgeEnabled === false)
    return true;
  const activeEditor = (_a2 = plugin.app.workspace) == null ? void 0 : _a2.activeEditor;
  if (!isFileOutlinerActiveEditorBridge(activeEditor))
    return true;
  if (!isEditorCommand(command))
    return true;
  const allowed = getAllowlistedPluginIds(plugin);
  const owner = getCommandOwnerPluginId(plugin, command == null ? void 0 : command.id);
  return allowed.has(owner);
}
function registerFileOutlinerEditorCommandBridge(plugin) {
  try {
    const uninstall = around(plugin.app.commands, {
      executeCommand: (old) => {
        return function(command, ...args) {
          var _a2;
          try {
            if (!shouldAllowEditorCommandInOutliner(plugin, command)) {
              if (plugin.settings.fileOutlinerDebugLogging === true) {
                console.debug("[BLP Outliner] blocked editor command", String((_a2 = command == null ? void 0 : command.id) != null ? _a2 : ""));
              }
              return false;
            }
          } catch (err) {
            if (plugin.settings.fileOutlinerDebugLogging === true) {
              console.error("[BLP Outliner] editor command gate failed", err);
            }
          }
          return old.call(this, command, ...args);
        };
      }
    });
    plugin.register(uninstall);
  } catch (err) {
    console.error("FileOutliner: failed to patch commands.executeCommand for editor command bridge", err);
  }
}

// src/features/file-outliner-view/blp-view.ts
var import_obsidian22 = require("obsidian");

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart2(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match2;
  var foundLineNo = -1;
  while (match2 = re.exec(mark.buffer)) {
    lineEnds.push(match2.index);
    lineStarts.push(match2.index + match2[0].length);
    if (mark.position <= match2.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart2((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart2((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart2((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger2(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int2 = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger2,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int2,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match2, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match2 = YAML_DATE_REGEXP.exec(data);
  if (match2 === null)
    match2 = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match2 === null)
    throw new Error("Date resolve error");
  year = +match2[1];
  month = +match2[2] - 1;
  day = +match2[3];
  if (!match2[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match2[4];
  minute = +match2[5];
  second = +match2[6];
  if (match2[7]) {
    fraction = match2[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match2[9]) {
    tz_hour = +match2[10];
    tz_minute = +(match2[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match2[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
function setProperty(object, key, value) {
  if (key === "__proto__") {
    Object.defineProperty(object, key, {
      configurable: true,
      enumerable: true,
      writable: true,
      value
    });
  } else {
    object[key] = value;
  }
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
var i;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match2, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match2 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match2 === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match2[1], 10);
    minor = parseInt(match2[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      setProperty(destination, key, source[key]);
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    setProperty(_result, keyNode, valueNode);
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null)
    return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match2;
  while (match2 = lineRe.exec(string)) {
    var prefix = match2[1], line = match2[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match2;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match2 = breakRe.exec(line)) {
    next = match2.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536)
        result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");

// src/features/file-outliner-view/blp-view.ts
var import_crypto = __toESM(require("crypto"));

// src/features/file-outliner-view/region-parser.ts
var REGION_START_MARKER_PREFIX = "%% blp-view-start";
var REGION_END_MARKER = "%% blp-view-end %%";
function findManagedRegion(fileContent, codeBlockEndLine) {
  const lines = fileContent.split("\n");
  let regionStartLine = -1;
  let regionEndLine = -1;
  let existingHash = null;
  for (let i = codeBlockEndLine + 1; i < lines.length; i++) {
    const trimmed = lines[i].trim();
    if (trimmed.startsWith(REGION_START_MARKER_PREFIX)) {
      regionStartLine = i;
      const hashMatch = trimmed.match(/data-hash=\"([^\"]+)\"/);
      if (hashMatch == null ? void 0 : hashMatch[1]) {
        existingHash = hashMatch[1];
      }
      break;
    }
  }
  if (regionStartLine === -1)
    return null;
  for (let i = regionStartLine + 1; i < lines.length; i++) {
    if (lines[i].trim() === REGION_END_MARKER) {
      regionEndLine = i;
      break;
    }
  }
  if (regionEndLine === -1)
    return null;
  return { regionStartLine, regionEndLine, existingHash };
}

// src/features/file-outliner-view/blp-view.ts
function normalizeTag(tag) {
  const trimmed = tag.trim();
  if (!trimmed)
    return "";
  return trimmed.startsWith("#") ? trimmed : `#${trimmed}`;
}
function normalizeTagList(tags) {
  if (!tags)
    return [];
  return tags.map(normalizeTag).filter(Boolean);
}
function parseConfig(source) {
  const raw = load(source);
  if (!raw || typeof raw !== "object")
    return {};
  return raw;
}
function resolveConfigDefaults(config) {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g, _h, _i, _j, _k, _l;
  const renderTypeRaw = (_a2 = config.render) == null ? void 0 : _a2.type;
  const renderType = renderTypeRaw === "table" || renderTypeRaw === "embed-list" ? renderTypeRaw : "embed-list";
  const renderModeRaw = (_b2 = config.render) == null ? void 0 : _b2.mode;
  if (renderModeRaw && renderModeRaw !== "materialize") {
    throw new Error(`blp-view: unsupported render.mode: ${renderModeRaw}`);
  }
  const columns = renderType === "table" ? (_d2 = (_c2 = config.render) == null ? void 0 : _c2.columns) != null ? _d2 : [
    { name: "File", expr: "file.link" },
    { name: "Date", field: "date" }
  ] : [];
  return {
    source: config.source,
    filters: config.filters,
    group: {
      by: (_f2 = (_e2 = config.group) == null ? void 0 : _e2.by) != null ? _f2 : "none",
      field: (_h = (_g = config.group) == null ? void 0 : _g.field) != null ? _h : ""
    },
    sort: {
      by: (_j = (_i = config.sort) == null ? void 0 : _i.by) != null ? _j : "date",
      order: (_l = (_k = config.sort) == null ? void 0 : _k.order) != null ? _l : "desc"
    },
    render: {
      type: renderType,
      mode: renderModeRaw,
      columns
    }
  };
}
function resolveSourceFilesOrError(plugin, dv, currentFile, source) {
  var _a2, _b2, _c2, _d2, _e2, _f2;
  const allMarkdownFiles = plugin.app.vault.getFiles().filter((f2) => {
    var _a3;
    return f2 instanceof import_obsidian22.TFile && ((_a3 = f2.extension) == null ? void 0 : _a3.toLowerCase()) === "md";
  });
  const enabledFiles = allMarkdownFiles.filter((f2) => isFileOutlinerEnabledFile(plugin, f2));
  const enabledPathSet = new Set(enabledFiles.map((f2) => f2.path));
  if (!source) {
    return { files: enabledFiles, nonEnabledPaths: [], missingPaths: [], ambiguousFiles: [] };
  }
  const folders = (_a2 = source.folders) != null ? _a2 : [];
  const files = (_b2 = source.files) != null ? _b2 : [];
  const dvSource = (_c2 = source.dv) == null ? void 0 : _c2.trim();
  if (dvSource && (folders.length > 0 || files.length > 0)) {
    throw new Error("blp-view: `source.dv` cannot be combined with `source.folders`/`source.files`.");
  }
  let candidatePaths = [];
  const missingPaths = [];
  const ambiguousFiles = [];
  if (dvSource) {
    const pages = dv.pages(dvSource, currentFile.path);
    for (const p of pages) {
      const path = (_d2 = p == null ? void 0 : p.file) == null ? void 0 : _d2.path;
      if (typeof path === "string" && path.endsWith(".md")) {
        candidatePaths.push(path);
      }
    }
  } else {
    const folderMatches = folders.length ? allMarkdownFiles.filter((f2) => folders.some((folder) => isPathInFolder(f2.path, folder))).map((f2) => f2.path) : [];
    const markdownPaths = new Set(allMarkdownFiles.map((f2) => f2.path));
    const basenameToPaths = /* @__PURE__ */ new Map();
    for (const f2 of allMarkdownFiles) {
      const base = f2.basename || ((_e2 = f2.path.split("/").pop()) == null ? void 0 : _e2.replace(/\.md$/i, "")) || "";
      if (!base)
        continue;
      const list = (_f2 = basenameToPaths.get(base)) != null ? _f2 : [];
      list.push(f2.path);
      basenameToPaths.set(base, list);
    }
    const normalizeInput = (raw) => {
      let s2 = raw.trim();
      if (s2.startsWith("[[") && s2.endsWith("]]")) {
        s2 = s2.slice(2, -2);
      }
      s2 = s2.split("|")[0].trim();
      return s2.replace(/\\/g, "/").replace(/^\/+/, "");
    };
    const resolveFileInput = (raw) => {
      var _a3, _b3, _c3, _d3;
      if (typeof raw !== "string") {
        throw new Error("blp-view: source.files entries must be strings.");
      }
      const cleaned = normalizeInput(raw);
      if (!cleaned)
        return null;
      const resolved = (_c3 = (_b3 = (_a3 = plugin.app.metadataCache) == null ? void 0 : _a3.getFirstLinkpathDest) == null ? void 0 : _b3.call(_a3, cleaned, currentFile.path)) == null ? void 0 : _c3.path;
      if (typeof resolved === "string" && resolved) {
        return resolved;
      }
      const isPathLike = cleaned.includes("/") || cleaned.toLowerCase().endsWith(".md");
      if (isPathLike) {
        const path = cleaned.toLowerCase().endsWith(".md") ? cleaned : `${cleaned}.md`;
        if (markdownPaths.has(path)) {
          return path;
        }
        missingPaths.push(cleaned);
        return null;
      }
      const matches = (_d3 = basenameToPaths.get(cleaned)) != null ? _d3 : [];
      if (matches.length === 1) {
        return matches[0];
      }
      if (matches.length > 1) {
        ambiguousFiles.push({ input: cleaned, matches: [...matches].sort() });
        return null;
      }
      missingPaths.push(cleaned);
      return null;
    };
    const fileMatches = files.map(resolveFileInput).filter((p) => typeof p === "string" && p.length > 0);
    candidatePaths = [...folderMatches, ...fileMatches].filter(Boolean);
  }
  const uniqueCandidatePaths = [...new Set(candidatePaths)];
  const resolvedFiles = [];
  const resolvedPaths = [];
  for (const path of uniqueCandidatePaths) {
    const af = plugin.app.vault.getAbstractFileByPath(path);
    if (af instanceof import_obsidian22.TFile) {
      resolvedFiles.push(af);
      resolvedPaths.push(path);
    } else {
      missingPaths.push(path);
    }
  }
  const nonEnabledPaths = resolvedPaths.filter((p) => !enabledPathSet.has(p));
  return {
    files: resolvedFiles,
    nonEnabledPaths,
    missingPaths: [...new Set(missingPaths)].sort(),
    ambiguousFiles
  };
}
function flattenListItems(items, ancestorTags, ancestorLines, out) {
  for (const item of items) {
    const tags = Array.isArray(item == null ? void 0 : item.tags) ? item.tags : [];
    const nextAncestors = [...ancestorTags, ...tags];
    out.push({ item, ancestorTags, ancestorLines });
    const children = Array.isArray(item == null ? void 0 : item.children) ? item.children : [];
    if (children.length > 0) {
      const line = typeof (item == null ? void 0 : item.line) === "number" ? item.line : void 0;
      const nextAncestorLines = typeof line === "number" ? [...ancestorLines, line] : ancestorLines;
      flattenListItems(children, nextAncestors, nextAncestorLines, out);
    }
  }
}
function parseDateFilterOrThrow(dv, raw) {
  if (typeof raw !== "string") {
    throw new Error("blp-view: date filter value must be a string.");
  }
  const parsed = dv.date(raw);
  if (!parsed) {
    throw new Error(`blp-view: invalid date value: ${raw}`);
  }
  return parsed;
}
function resolveOutlinkTargets(plugin, currentFile, outlinks) {
  var _a2, _b2, _c2;
  const any = /* @__PURE__ */ new Set();
  const all = /* @__PURE__ */ new Set();
  const none = /* @__PURE__ */ new Set();
  const requireCurrentFile = Boolean(outlinks == null ? void 0 : outlinks.link_to_current_file);
  if (!outlinks)
    return { any, all, none, requireCurrentFile };
  const addPathLike = (raw, target) => {
    var _a3;
    const cleaned = raw.replace(/^\[\[|\]\]$/g, "").split("|")[0].trim();
    if (!cleaned)
      return;
    const resolved = (_a3 = plugin.app.metadataCache.getFirstLinkpathDest(cleaned, currentFile.path)) == null ? void 0 : _a3.path;
    target.add(resolved != null ? resolved : cleaned);
  };
  for (const raw of (_a2 = outlinks.any) != null ? _a2 : [])
    addPathLike(raw, any);
  for (const raw of (_b2 = outlinks.all) != null ? _b2 : [])
    addPathLike(raw, all);
  for (const raw of (_c2 = outlinks.none) != null ? _c2 : [])
    addPathLike(raw, none);
  return { any, all, none, requireCurrentFile };
}
function matchesFieldFilter(dv, item, filter) {
  if (!filter.field)
    return true;
  const value = item == null ? void 0 : item[filter.field];
  if (value === void 0 || value === null)
    return false;
  if (filter.op === "has") {
    return dv.value.isTruthy(dv.literal(value));
  }
  const expected = dv.literal(filter.value);
  const actual = dv.literal(value);
  switch (filter.op) {
    case "=":
      return dv.equal(actual, expected);
    case "!=":
      return !dv.equal(actual, expected);
    case ">":
      return dv.compare(actual, expected) > 0;
    case ">=":
      return dv.compare(actual, expected) >= 0;
    case "<":
      return dv.compare(actual, expected) < 0;
    case "<=":
      return dv.compare(actual, expected) <= 0;
    case "in": {
      if (!Array.isArray(filter.value))
        return false;
      return filter.value.some((v) => dv.equal(actual, dv.literal(v)));
    }
    case "contains": {
      if (typeof value === "string" && typeof filter.value === "string") {
        return value.includes(filter.value);
      }
      if (Array.isArray(value)) {
        return value.some((v) => dv.equal(dv.literal(v), expected));
      }
      return false;
    }
    default:
      return false;
  }
}
function matchesTagFilter(item, tagsFilter, ancestorTags) {
  if (!tagsFilter)
    return true;
  const itemTags = new Set(normalizeTagList(item == null ? void 0 : item.tags));
  const ancestors = new Set(normalizeTagList(ancestorTags));
  const any = normalizeTagList(tagsFilter.any);
  const all = normalizeTagList(tagsFilter.all);
  const none = normalizeTagList(tagsFilter.none);
  const noneInAncestors = normalizeTagList(tagsFilter.none_in_ancestors);
  if (any.length > 0 && !any.some((t) => itemTags.has(t)))
    return false;
  if (all.length > 0 && !all.every((t) => itemTags.has(t)))
    return false;
  if (none.length > 0 && none.some((t) => itemTags.has(t)))
    return false;
  if (noneInAncestors.length > 0 && noneInAncestors.some((t) => ancestors.has(t)))
    return false;
  return true;
}
function matchesOutlinksFilter(plugin, item, outlinksFilter, targets, currentFilePath) {
  var _a2, _b2, _c2;
  if (!outlinksFilter)
    return true;
  const outlinks = Array.isArray(item == null ? void 0 : item.outlinks) ? item.outlinks : [];
  const normalizePathForCompare = (p) => p.replace(/\\/g, "/").replace(/^\/+/, "").replace(/\.md$/i, "");
  const getBasenameForCompare = (p) => {
    var _a3;
    const normalized = normalizePathForCompare(p);
    const parts = normalized.split("/");
    return (_a3 = parts[parts.length - 1]) != null ? _a3 : normalized;
  };
  const originFilePath = typeof (item == null ? void 0 : item.path) === "string" && item.path ? item.path : currentFilePath;
  const outlinkPaths = /* @__PURE__ */ new Set();
  const outlinkBasenames = /* @__PURE__ */ new Set();
  const addOutlinkCandidate = (p) => {
    if (typeof p !== "string" || !p)
      return;
    outlinkPaths.add(normalizePathForCompare(p));
    outlinkBasenames.add(getBasenameForCompare(p));
  };
  for (const l2 of outlinks) {
    addOutlinkCandidate(l2.path);
    const resolved = (_c2 = (_b2 = (_a2 = plugin.app.metadataCache) == null ? void 0 : _a2.getFirstLinkpathDest) == null ? void 0 : _b2.call(_a2, l2.path, originFilePath)) == null ? void 0 : _c2.path;
    addOutlinkCandidate(resolved);
  }
  const hasPath = (path) => {
    const normalized = normalizePathForCompare(path);
    if (outlinkPaths.has(normalized))
      return true;
    const basename = getBasenameForCompare(path);
    return basename ? outlinkBasenames.has(basename) : false;
  };
  if (targets.requireCurrentFile && !hasPath(currentFilePath))
    return false;
  if (targets.any.size > 0 && ![...targets.any].some(hasPath))
    return false;
  if (targets.all.size > 0 && ![...targets.all].every(hasPath))
    return false;
  if (targets.none.size > 0 && [...targets.none].some(hasPath))
    return false;
  return true;
}
function applyHierarchyFilter(candidates, mode) {
  const resolved = mode != null ? mode : "all";
  if (resolved === "all")
    return candidates;
  if (resolved === "root-only") {
    return candidates.filter((c) => {
      var _a2, _b2;
      return ((_b2 = (_a2 = c.ancestorLines) == null ? void 0 : _a2.length) != null ? _b2 : 0) === 0;
    });
  }
  const matched = /* @__PURE__ */ new Set();
  for (const c of candidates) {
    if (typeof c.path === "string" && typeof c.line === "number" && c.line > 0) {
      matched.add(`${c.path}:${c.line}`);
    }
  }
  return candidates.filter((c) => {
    const ancestors = Array.isArray(c.ancestorLines) ? c.ancestorLines : [];
    if (ancestors.length === 0)
      return true;
    if (typeof c.path !== "string" || typeof c.line !== "number" || c.line <= 0)
      return true;
    return !ancestors.some((line) => typeof line === "number" && matched.has(`${c.path}:${line}`));
  });
}
function matchesSectionFilter(item, sectionFilter) {
  var _a2, _b2, _c2;
  if (!sectionFilter)
    return true;
  const section = item == null ? void 0 : item.section;
  const sectionName = section && section.type === "header" && typeof section.subpath === "string" ? section.subpath : void 0;
  const any = (_b2 = (_a2 = sectionFilter.any) != null ? _a2 : sectionFilter.all) != null ? _b2 : [];
  const none = (_c2 = sectionFilter.none) != null ? _c2 : [];
  if (any.length > 0) {
    if (!sectionName)
      return false;
    return any.includes(sectionName);
  }
  if (none.length > 0) {
    if (!sectionName)
      return true;
    return !none.includes(sectionName);
  }
  return true;
}
function matchesDateFilter(dv, date, dateFilter) {
  if (!dateFilter)
    return true;
  if (typeof dateFilter.within_days === "number") {
    const threshold = dv.luxon.DateTime.now().minus({ days: dateFilter.within_days });
    if (date < threshold)
      return false;
  }
  if (dateFilter.after) {
    const after = parseDateFilterOrThrow(dv, dateFilter.after);
    if (!(date > after))
      return false;
  }
  if (dateFilter.before) {
    const before = parseDateFilterOrThrow(dv, dateFilter.before);
    if (!(date < before))
      return false;
  }
  if (dateFilter.between) {
    const between = dateFilter.between;
    const afterRaw = Array.isArray(between) ? between[0] : between.after;
    const beforeRaw = Array.isArray(between) ? between[1] : between.before;
    const after = parseDateFilterOrThrow(dv, afterRaw);
    const before = parseDateFilterOrThrow(dv, beforeRaw);
    if (!(after < date && date < before))
      return false;
  }
  return true;
}
function buildGroups(dv, items, config) {
  var _a2;
  const by = config.group.by;
  if (by === "none") {
    return [{ key: "__all__", title: "", items }];
  }
  const groups = /* @__PURE__ */ new Map();
  const ensureGroup = (key, title) => {
    const existing = groups.get(key);
    if (existing)
      return existing;
    const created = { key, title, items: [] };
    groups.set(key, created);
    return created;
  };
  for (const candidate of items) {
    if (by === "day(date)") {
      const day = candidate.date.toFormat("yyyy-MM-dd");
      ensureGroup(day, day).items.push(candidate);
      continue;
    }
    if (by === "file") {
      const path = candidate.path;
      ensureGroup(path, `[[${path}]]`).items.push(candidate);
      continue;
    }
    if (by === "field") {
      const field = config.group.field;
      if (!field)
        continue;
      const rawValue = (_a2 = candidate.item) == null ? void 0 : _a2[field];
      if (rawValue === void 0 || rawValue === null)
        continue;
      const values = Array.isArray(rawValue) ? rawValue : [rawValue];
      for (const v of values) {
        const key = dv.value.toString(dv.literal(v));
        ensureGroup(key, key).items.push(candidate);
      }
      continue;
    }
  }
  const grouped = [...groups.values()];
  const sortDirection = config.sort.order === "desc" ? -1 : 1;
  if (by === "day(date)" && config.sort.by === "date") {
    return grouped.sort((a, b) => a.key.localeCompare(b.key) * sortDirection);
  }
  if (by === "file" && config.sort.by === "file.path") {
    return grouped.sort((a, b) => a.key.localeCompare(b.key) * sortDirection);
  }
  return grouped.sort((a, b) => a.key.localeCompare(b.key));
}
function stableSortItems(dv, items, sort) {
  const order = sort.order;
  const comparePrimary = (a, b) => {
    switch (sort.by) {
      case "file.path":
        return a.path.localeCompare(b.path);
      case "line":
        return a.line - b.line;
      case "date":
      default:
        return dv.compare(a.date, b.date);
    }
  };
  const dir = order === "asc" ? 1 : -1;
  return [...items].sort((a, b) => {
    const primary = comparePrimary(a, b) * dir;
    if (primary !== 0)
      return primary;
    const pathCmp = a.path.localeCompare(b.path);
    if (pathCmp !== 0)
      return pathCmp;
    const lineCmp = a.line - b.line;
    if (lineCmp !== 0)
      return lineCmp;
    return a.blockId.localeCompare(b.blockId);
  });
}
function stripMarkdownExtension(path) {
  return path.replace(/\.md$/i, "");
}
function maybeLinkGroupTitleToSourceFile(group) {
  var _a2, _b2;
  const title = (_a2 = group.title) != null ? _a2 : "";
  if (!title)
    return title;
  if (title.includes("[["))
    return title;
  const uniquePaths = /* @__PURE__ */ new Set();
  for (const item of (_b2 = group.items) != null ? _b2 : []) {
    if (item == null ? void 0 : item.path)
      uniquePaths.add(String(item.path));
  }
  const paths = [...uniquePaths];
  if (paths.length === 1) {
    return `[[${stripMarkdownExtension(paths[0])}|${title}]]`;
  }
  const dateMatch = title.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (!dateMatch)
    return title;
  const yyyy = dateMatch[1];
  const mm = dateMatch[2];
  const dd = dateMatch[3];
  const mNoPad = String(parseInt(mm, 10));
  const dNoPad = String(parseInt(dd, 10));
  const candidates = /* @__PURE__ */ new Set([`${yyyy}-${mm}-${dd}`, `${yyyy}-${mNoPad}-${dNoPad}`]);
  const matching = paths.filter((p) => {
    var _a3, _b3;
    const base = (_b3 = (_a3 = p.split("/").pop()) == null ? void 0 : _a3.replace(/\.md$/i, "")) != null ? _b3 : "";
    return candidates.has(base);
  });
  if (matching.length === 1) {
    return `[[${stripMarkdownExtension(matching[0])}|${title}]]`;
  }
  return title;
}
function renderEmbedList(groups) {
  const lines = [];
  for (const group of groups) {
    if (group.title) {
      lines.push(`### ${maybeLinkGroupTitleToSourceFile(group)}`);
    }
    for (const item of group.items) {
      lines.push(`![[${item.path}#^${item.blockId}]]`);
    }
    if (group.title) {
      lines.push("");
    }
  }
  return lines.join("\n").trim();
}
function renderTable(dv, groups, config, pageFileByPath, originFilePath) {
  var _a2, _b2, _c2;
  const columns = (_a2 = config.render.columns) != null ? _a2 : [];
  if (columns.length === 0) {
    return "";
  }
  const headers = columns.map((c) => c.name);
  const parts = [];
  for (const group of groups) {
    if (group.title) {
      parts.push(`### ${group.title}`);
      parts.push("");
    }
    const rows = [];
    for (const candidate of group.items) {
      const pageFile = (_b2 = pageFileByPath.get(candidate.path)) != null ? _b2 : { path: candidate.path, link: dv.fileLink(candidate.path) };
      pageFileByPath.set(candidate.path, pageFile);
      const context = { ...candidate.item, file: pageFile };
      const row = [];
      for (const col of columns) {
        if (col.field) {
          row.push((_c2 = candidate.item) == null ? void 0 : _c2[col.field]);
          continue;
        }
        if (col.expr) {
          const result = dv.evaluate(col.expr, context, originFilePath);
          if (!result.successful) {
            throw new Error(`blp-view: expr failed (${col.name}): ${result.error}`);
          }
          row.push(result.value);
          continue;
        }
        throw new Error(`blp-view: invalid column '${col.name}' (must specify field or expr).`);
      }
      rows.push(row);
    }
    parts.push(dv.markdownTable(headers, rows));
    parts.push("");
  }
  return parts.join("\n").trim();
}
async function materializeOutput(plugin, file, el, ctx, markdown) {
  const sectionInfo = ctx.getSectionInfo(el);
  if (!sectionInfo) {
    throw new Error("blp-view: could not resolve code block position.");
  }
  const codeBlockEndLine = sectionInfo.lineEnd;
  const fileContent = await plugin.app.vault.read(file);
  const originalLines = fileContent.split("\n");
  const region = findManagedRegion(fileContent, codeBlockEndLine);
  const contentBlock = markdown.trimEnd();
  const newHash = import_crypto.default.createHash("sha256").update(contentBlock).digest("hex");
  if (region) {
    const existingContentBlock = originalLines.slice(region.regionStartLine + 1, region.regionEndLine).join("\n").trimEnd();
    const existingContentHash = import_crypto.default.createHash("sha256").update(existingContentBlock).digest("hex");
    if (region.existingHash === newHash && existingContentHash === newHash) {
      return;
    }
  }
  const newStartMarker = `${REGION_START_MARKER_PREFIX} data-hash="${newHash}" %%`;
  let newFileContent;
  if (region) {
    const beforeRegion = originalLines.slice(0, region.regionStartLine).join("\n");
    const afterRegion = originalLines.slice(region.regionEndLine + 1).join("\n");
    newFileContent = `${beforeRegion}
${newStartMarker}
${contentBlock}
${REGION_END_MARKER}${afterRegion ? `
${afterRegion}` : ""}`;
  } else {
    const beforeRegion = originalLines.slice(0, codeBlockEndLine + 1).join("\n");
    const afterRegion = originalLines.slice(codeBlockEndLine + 1).join("\n");
    newFileContent = `${beforeRegion}
${newStartMarker}
${contentBlock}
${REGION_END_MARKER}${afterRegion ? `
${afterRegion}` : ""}`;
  }
  if (newFileContent.trim() !== fileContent.trim()) {
    await plugin.app.vault.modify(file, newFileContent);
  }
}
async function handleBlpView(plugin, source, el, ctx) {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g, _h, _i, _j, _k, _l;
  el.empty();
  try {
    const startMs = Date.now();
    const dv = getDataviewApi();
    if (!dv) {
      el.createEl("pre", { text: "Error: Dataview plugin is not installed or enabled." });
      return;
    }
    const file = plugin.app.vault.getAbstractFileByPath(ctx.sourcePath);
    if (!(file instanceof import_obsidian22.TFile)) {
      return;
    }
    const config = resolveConfigDefaults(parseConfig(source));
    const allowMaterialize = plugin.settings.blpViewAllowMaterialize;
    const maxSourceFiles = (_a2 = plugin.settings.blpViewMaxSourceFiles) != null ? _a2 : 0;
    const maxResults = (_b2 = plugin.settings.blpViewMaxResults) != null ? _b2 : 0;
    const showDiagnostics = plugin.settings.blpViewShowDiagnostics;
    const { files: sourceFiles, nonEnabledPaths, missingPaths, ambiguousFiles } = resolveSourceFilesOrError(
      plugin,
      dv,
      file,
      config.source
    );
    if (missingPaths.length > 0) {
      el.createEl("pre", {
        text: `Error: blp-view source includes missing/unresolved files:
` + missingPaths.map((p) => `- ${p}`).join("\n") + `

Tip: use vault-relative paths (right click file \u2192 Copy path) or ensure the files exist.`
      });
      return;
    }
    if (ambiguousFiles.length > 0) {
      const lines = ["Error: blp-view source includes ambiguous file names:"];
      for (const a of ambiguousFiles) {
        lines.push(`- ${a.input}`);
        for (const p of a.matches) {
          lines.push(`  - ${p}`);
        }
      }
      lines.push("");
      lines.push("Tip: use a full vault-relative path in `source.files` to disambiguate.");
      el.createEl("pre", { text: lines.join("\n") });
      return;
    }
    if (nonEnabledPaths.length > 0) {
      el.createEl("pre", {
        text: `Error: blp-view source includes non-enabled files:
` + nonEnabledPaths.map((p) => `- ${p}`).join("\n") + `

Enable them via settings folders/files (vault-relative) or frontmatter \`${"blp_outliner: true"}\`.`
      });
      return;
    }
    if (maxSourceFiles > 0 && sourceFiles.length > maxSourceFiles) {
      el.createEl("pre", {
        text: `Error: blp-view would scan ${sourceFiles.length} files (limit: ${maxSourceFiles}).
Narrow \`source\` in the code block or increase the limit in settings.`
      });
      return;
    }
    const flattened = [];
    const pageFileByPath = /* @__PURE__ */ new Map();
    let filesScanned = 0;
    for (const f2 of sourceFiles) {
      if (!isFileOutlinerEnabledFile(plugin, f2)) {
        continue;
      }
      filesScanned++;
      const page = dv.page(f2.path, file.path);
      const pageFile = page == null ? void 0 : page.file;
      if (pageFile) {
        if (!pageFile.link) {
          pageFile.link = dv.fileLink(f2.path);
        }
        pageFileByPath.set(f2.path, pageFile);
      }
      const lists = (_c2 = page == null ? void 0 : page.file) == null ? void 0 : _c2.lists;
      if (!Array.isArray(lists) || lists.length === 0)
        continue;
      const rootsByParent = lists.filter((li) => (li == null ? void 0 : li.parent) == null);
      let roots = rootsByParent.length > 0 ? rootsByParent : lists;
      if (roots.length === lists.length) {
        const childSet = /* @__PURE__ */ new Set();
        for (const li of lists) {
          const children = Array.isArray(li == null ? void 0 : li.children) ? li.children : [];
          for (const c of children)
            childSet.add(c);
        }
        const rootsByChildren = lists.filter((li) => !childSet.has(li));
        if (rootsByChildren.length > 0 && rootsByChildren.length < roots.length) {
          roots = rootsByChildren;
        }
      }
      flattenListItems(roots, [], [], flattened);
    }
    const targets = resolveOutlinkTargets(plugin, file, (_d2 = config.filters) == null ? void 0 : _d2.outlinks);
    const candidatesByKey = /* @__PURE__ */ new Map();
    for (const { item, ancestorTags, ancestorLines } of flattened) {
      const blockId = item == null ? void 0 : item.blockId;
      if (typeof blockId !== "string" || !blockId)
        continue;
      const rawDate = item == null ? void 0 : item.date;
      if (!dv.value.isDate(rawDate))
        continue;
      const date = rawDate;
      const path = typeof (item == null ? void 0 : item.path) === "string" ? item.path : file.path;
      const line = typeof (item == null ? void 0 : item.line) === "number" ? item.line : 0;
      if (!matchesDateFilter(dv, date, (_e2 = config.filters) == null ? void 0 : _e2.date))
        continue;
      if ((_g = (_f2 = config.filters) == null ? void 0 : _f2.fields) == null ? void 0 : _g.length) {
        const ok = config.filters.fields.every((f2) => matchesFieldFilter(dv, item, f2));
        if (!ok)
          continue;
      }
      if (!matchesTagFilter(item, (_h = config.filters) == null ? void 0 : _h.tags, ancestorTags))
        continue;
      if (!matchesOutlinksFilter(plugin, item, (_i = config.filters) == null ? void 0 : _i.outlinks, targets, file.path))
        continue;
      if (!matchesSectionFilter(item, (_j = config.filters) == null ? void 0 : _j.section))
        continue;
      const candidate = {
        path,
        line,
        blockId,
        date,
        item,
        ancestorTags,
        ancestorLines: Array.isArray(ancestorLines) ? ancestorLines : []
      };
      const key = `${path}:${line}:${blockId}`;
      const existing = candidatesByKey.get(key);
      if (!existing || candidate.ancestorLines.length > existing.ancestorLines.length) {
        candidatesByKey.set(key, candidate);
      }
    }
    const candidates = [...candidatesByKey.values()];
    const hierarchyMode = (_k = config.filters) == null ? void 0 : _k.hierarchy;
    if (hierarchyMode && hierarchyMode !== "all" && hierarchyMode !== "outermost-match" && hierarchyMode !== "root-only") {
      throw new Error(`blp-view: unsupported filters.hierarchy: ${hierarchyMode}`);
    }
    const filtered = applyHierarchyFilter(candidates, hierarchyMode);
    const sorted = stableSortItems(dv, filtered, config.sort);
    const totalMatches = sorted.length;
    const limited = maxResults > 0 && totalMatches > maxResults ? sorted.slice(0, maxResults) : sorted;
    const truncated = limited.length !== totalMatches;
    const groups = buildGroups(dv, limited, config);
    let markdown = config.render.type === "table" ? renderTable(dv, groups, config, pageFileByPath, file.path) : renderEmbedList(groups);
    if (truncated) {
      markdown = `> [!warning] blp-view output truncated
> Showing ${limited.length} of ${totalMatches} items (settings max results = ${maxResults}).

` + markdown;
    }
    const endMs = Date.now();
    const diagnosticsText = `blp-view diagnostics:
- scannedFiles: ${filesScanned}
- listItems: ${flattened.length}
- matched: ${totalMatches}
- rendered: ${limited.length}
- durationMs: ${Math.max(0, endMs - startMs)}`;
    if (config.render.mode === "materialize") {
      if (!allowMaterialize) {
        el.createEl("pre", { text: "Error: render.mode=materialize is disabled in settings." });
        return;
      }
      if (!isFileOutlinerEnabledFile(plugin, file)) {
        el.createEl("pre", { text: "Error: render.mode=materialize requires the current file to be enabled." });
        return;
      }
      await materializeOutput(plugin, file, el, ctx, markdown);
      el.empty();
      el.createEl("pre", { text: "blp-view output is materialized below." });
      if (showDiagnostics) {
        el.createEl("pre", { text: diagnosticsText });
      }
      return;
    }
    if (!markdown.trim()) {
      el.createEl("pre", { text: "No items found." });
      if (showDiagnostics) {
        el.createEl("pre", { text: diagnosticsText });
      }
      return;
    }
    await import_obsidian22.MarkdownRenderer.renderMarkdown(markdown, el, ctx.sourcePath, plugin);
    if (showDiagnostics) {
      el.createEl("pre", { text: diagnosticsText });
    }
  } catch (error) {
    console.error("Block Link Plus blp-view Error:", error);
    el.empty();
    el.createEl("pre", { text: `blp-view Error: ${(_l = error == null ? void 0 : error.message) != null ? _l : String(error)}` });
  }
}

// src/features/file-outliner-view/index.ts
function notifyFileOutlinerViewsSettingsChanged(plugin) {
  var _a2;
  try {
    const leaves = (_a2 = plugin.app.workspace.getLeavesOfType(FILE_OUTLINER_VIEW_TYPE)) != null ? _a2 : [];
    for (const leaf of leaves) {
      const viewAny = leaf == null ? void 0 : leaf.view;
      if (viewAny && typeof viewAny.onFileOutlinerSettingsChanged === "function") {
        viewAny.onFileOutlinerSettingsChanged();
      }
    }
  } catch (e) {
  }
}
function registerFileOutlinerView(plugin) {
  plugin.registerView(FILE_OUTLINER_VIEW_TYPE, (leaf) => new FileOutlinerView(leaf, plugin));
  registerFileOutlinerRouting(plugin);
  registerFileOutlinerMarkdownPaneMenu(plugin);
  registerFileOutlinerCommands(plugin);
  registerFileOutlinerEditorCommandBridge(plugin);
}

// src/utils/debug.ts
var DebugUtils = class {
  /**
   * 
   * @param plugin 
   */
  static init(plugin) {
    this.plugin = plugin;
    if (false) {
      window.debug = this;
      window.$plugin = plugin;
      console.log("\u{1F527} Debug mode enabled. Access via window.debug");
    }
  }
  /**
   * 
   * @param condition  true 
   * @param message 
   */
  static break(condition = true, message) {
    if (condition) {
      if (message) {
        console.log(`\u{1F50D} Debug break: ${message}`);
      }
      debugger;
    }
  }
  /**
   * 
   * @param label 
   * @param data 
   * @returns 
   */
  static log(label, data) {
    console.group(`\u{1F50D} ${label}`);
    console.log(data);
    console.trace();
    console.groupEnd();
    return data;
  }
  /**
   * 
   * @param fn 
   * @param label 
   * @returns 
   */
  static monitor(fn, label) {
    return (...args) => {
      console.log(`\u{1F680} ${label} - \u5F00\u59CB\u6267\u884C`, args);
      const start = performance.now();
      try {
        const result = fn(...args);
        const end = performance.now();
        console.log(`\u2705 ${label} - \u6267\u884C\u5B8C\u6210 (${(end - start).toFixed(2)}ms)`, result);
        return result;
      } catch (error) {
        const end = performance.now();
        console.error(`\u274C ${label} - \u6267\u884C\u5931\u8D25 (${(end - start).toFixed(2)}ms)`, error);
        throw error;
      }
    };
  }
  /**
   * 
   */
  static getCurrentFile() {
    var _a2;
    if (!((_a2 = this.plugin) == null ? void 0 : _a2.app))
      return null;
    return this.plugin.app.workspace.getActiveFile();
  }
  /**
   *  embed 
   */
  static getMultilineEmbeds() {
    return Array.from(document.querySelectorAll(".internal-embed")).filter((el) => {
      var _a2;
      return (_a2 = el.getAttribute("src")) == null ? void 0 : _a2.includes("-");
    });
  }
  /**
   * 
   */
  static getPlugin() {
    return this.plugin;
  }
  /**
   *  Obsidian App 
   */
  static getApp() {
    var _a2;
    return ((_a2 = this.plugin) == null ? void 0 : _a2.app) || null;
  }
  /**
   * 
   */
  static forceRerender() {
    var _a2, _b2, _c2;
    const app = this.getApp();
    if ((_b2 = (_a2 = app == null ? void 0 : app.workspace) == null ? void 0 : _a2.activeLeaf) == null ? void 0 : _b2.view) {
      const view = app.workspace.activeLeaf.view;
      if ("editor" in view && view.editor) {
        (_c2 = view.editor.cm) == null ? void 0 : _c2.dispatch();
      }
    }
  }
  /**
   * 
   */
  static getAllPlugins() {
    const app = this.getApp();
    if (!app)
      return null;
    return {
      enabled: app.plugins.enabledPlugins,
      plugins: app.plugins.plugins
    };
  }
  /**
   * 
   */
  static isPluginEnabled(pluginId) {
    var _a2, _b2;
    const app = this.getApp();
    return ((_b2 = (_a2 = app == null ? void 0 : app.plugins) == null ? void 0 : _a2.enabledPlugins) == null ? void 0 : _b2.has(pluginId)) || false;
  }
  /**
   *  embed 
   */
  static getCurrentEmbedLinks() {
    const embeds = document.querySelectorAll(".internal-embed");
    return Array.from(embeds).map((embed) => {
      var _a2;
      return {
        element: embed,
        src: embed.getAttribute("src"),
        isMultiline: ((_a2 = embed.getAttribute("src")) == null ? void 0 : _a2.includes("-")) || false
      };
    });
  }
  /**
   * 
   */
  static clickElement(selector) {
    const element = document.querySelector(selector);
    if (element) {
      element.click();
      return true;
    }
    return false;
  }
  /**
   * 
   */
  static exportDebugInfo() {
    return {
      currentFile: this.getCurrentFile(),
      multilineEmbeds: this.getMultilineEmbeds(),
      allPlugins: this.getAllPlugins(),
      embedLinks: this.getCurrentEmbedLinks(),
      timestamp: new Date().toISOString()
    };
  }
};

// src/main.ts
var BlockLinkPlus = class extends import_obsidian23.Plugin {
  constructor() {
    super(...arguments);
    this.appName = "Block Link Plus";
    this.editorExtensions = [];
    this.hasExistingSettingsData = false;
    this.viewPluginRegistered = false;
    // Public API for external plugin integration
    this.api = {
      // Flow editor controls
      openFlowEditor: () => this.flowEditorManager.openFlow(),
      closeFlowEditor: () => this.flowEditorManager.closeFlow(),
      // Settings access
      getSettings: () => this.settings,
      updateSettings: async (newSettings) => {
        this.settings = { ...this.settings, ...newSettings };
        await this.saveSettings();
      },
      // Editor utilities
      getActiveEditor: () => getActiveCM(this),
      // Check if flow editing is enabled
      isFlowEnabled: () => this.settings.inlineEditEnabled,
      // Access to enactor for path operations
      getEnactor: () => this.flowEditorManager.enactor
    };
  }
  get enactor() {
    return this.flowEditorManager.enactor;
  }
  /**
   * Update the view plugin
   */
  updateViewPlugin() {
    if (!this.viewPlugin) {
      this.viewPlugin = createViewPlugin(BLP_BLOCK_MARKER_RULE);
    }
    if (!this.viewPluginRegistered) {
      this.registerEditorExtension([this.viewPlugin]);
      this.viewPluginRegistered = true;
    }
  }
  async onload() {
    console.log(`loading ${this.appName}, version: ${this.manifest.version}`);
    DebugUtils.init(this);
    await this.loadSettings();
    this.addSettingTab(new BlockLinkPlusSettingsTab(this.app, this));
    registerFileOutlinerView(this);
    await this.maybeShowWhatsNew();
    this.registerEvent(
      this.app.workspace.on(
        "editor-menu",
        (menu, editor, view) => handleEditorMenu(this, menu, editor, view)
      )
    );
    this.registerMarkdownCodeBlockProcessor("blp-view", (source, el, ctx) => {
      if (isDataviewAvailable()) {
        void handleBlpView(this, source, el, ctx);
      } else {
        el.empty();
        el.createEl("pre", { text: "blp-view requires Dataview plugin." });
      }
    });
    this.addCommand({
      id: "copy-link-to-block",
      name: "Copy Block Link",
      editorCheckCallback: (isChecking, editor, view) => {
        return handleCommand(this, isChecking, editor, view, false);
      }
    });
    this.addCommand({
      id: "copy-embed-to-block",
      name: "Copy Block as Embed",
      editorCheckCallback: (isChecking, editor, view) => {
        return handleCommand(this, isChecking, editor, view, true);
      }
    });
    this.addCommand({
      id: "copy-url-to-block",
      name: "Copy Block as Obsidian URI",
      editorCheckCallback: (isChecking, editor, view) => {
        return handleCommand(this, isChecking, editor, view, false, true);
      }
    });
    this.registerMarkdownPostProcessor((el, ctx) => fileOutlinerMarkdownPostProcessor(el, ctx, this));
    this.updateViewPlugin();
    this.flowEditorManager = new FlowEditorManager(this);
    this.flowEditorManager.initialize();
    this.inlineEditEngine = new InlineEditEngine(this);
    this.inlineEditEngine.load();
    this.register(() => this.inlineEditEngine.unload());
    window.BlockLinkPlus = this;
  }
  async loadSettings() {
    var _a2;
    const raw = (_a2 = await this.loadData()) != null ? _a2 : {};
    this.hasExistingSettingsData = typeof raw === "object" && raw !== null && Object.keys(raw).length > 0;
    let shouldSave = false;
    if (typeof raw === "object" && raw !== null) {
      if ("editorFlow" in raw && !("inlineEditEnabled" in raw)) {
        raw.inlineEditEnabled = raw.editorFlow;
        shouldSave = true;
      }
      if ("fileOutlinerActiveHighlightEnabled" in raw && !("fileOutlinerEmphasisLineEnabled" in raw)) {
        raw.fileOutlinerEmphasisLineEnabled = raw.fileOutlinerActiveHighlightEnabled;
        delete raw.fileOutlinerActiveHighlightEnabled;
        shouldSave = true;
      }
      const legacyKeys = [
        "editorFlow",
        "editorFlowStyle",
        "timelineDefaultEmbedFormat",
        "enableTimeline",
        "timelineDefaultHeadingLevel",
        "timelineDefaultSortOrder",
        "enable_time_section",
        "time_section_format",
        "time_section_title_pattern",
        "daily_note_pattern",
        "insert_heading_level",
        "daily_note_heading_level",
        "enable_time_section_in_menu",
        "time_section_plain_style",
        "enable_right_click_editable_embed",
        "enable_editable_embed_notification"
      ];
      for (const key of legacyKeys) {
        if (key in raw) {
          delete raw[key];
          shouldSave = true;
        }
      }
    }
    this.settings = Object.assign({}, DEFAULT_SETTINGS, raw);
    if (shouldSave) {
      await this.saveData(this.settings);
    }
  }
  async saveSettings() {
    var _a2;
    await this.saveData(this.settings);
    (_a2 = this.inlineEditEngine) == null ? void 0 : _a2.onSettingsChanged();
    getFileOutlinerScopeManager(this).onSettingsChanged();
    notifyFileOutlinerViewsSettingsChanged(this);
  }
  async onunload() {
  }
  async maybeShowWhatsNew() {
    var _a2;
    const currentVersion = this.manifest.version;
    const lastSeenVersion = (_a2 = this.settings.lastSeenVersion) != null ? _a2 : "";
    const decision = decideWhatsNewOnStartup({
      currentVersion,
      lastSeenVersion,
      hasExistingData: this.hasExistingSettingsData
    });
    if (decision.kind === "none")
      return;
    this.settings.lastSeenVersion = decision.lastSeenVersion;
    await this.saveData(this.settings);
    if (decision.kind === "record")
      return;
    this.app.workspace.onLayoutReady(() => {
      new WhatsNewModal(this.app, {
        currentVersion,
        previousVersion: decision.previousVersion
      }).open();
    });
  }
};
/*! Bundled license information:

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.29.4 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.1 https://github.com/nodeca/js-yaml @license MIT *)
*/

/* nosourcemap */