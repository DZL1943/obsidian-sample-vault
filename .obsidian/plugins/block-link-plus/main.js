/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  BlockLinkAliasType: () => BlockLinkAliasType,
  MultLineHandle: () => MultLineHandle,
  default: () => BlockLinkPlus
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_view = require("@codemirror/view");
var MAX_ALIAS_LENGTH = 100;
var MultLineHandle = /* @__PURE__ */ ((MultLineHandle2) => {
  MultLineHandle2[MultLineHandle2["oneline"] = 0] = "oneline";
  MultLineHandle2[MultLineHandle2["heading"] = 1] = "heading";
  MultLineHandle2[MultLineHandle2["multblock"] = 2] = "multblock";
  return MultLineHandle2;
})(MultLineHandle || {});
var BlockLinkAliasType = /* @__PURE__ */ ((BlockLinkAliasType2) => {
  BlockLinkAliasType2[BlockLinkAliasType2["Default"] = 0] = "Default";
  BlockLinkAliasType2[BlockLinkAliasType2["FirstChars"] = 1] = "FirstChars";
  BlockLinkAliasType2[BlockLinkAliasType2["Heading"] = 2] = "Heading";
  BlockLinkAliasType2[BlockLinkAliasType2["SelectedText"] = 3] = "SelectedText";
  return BlockLinkAliasType2;
})(BlockLinkAliasType || {});
var DEFAULT_SETTINGS = {
  mult_line_handle: 0 /* oneline */,
  // as one line handle
  alias_type: 0 /* Default */,
  // no alias
  enable_right_click_block: true,
  enable_right_click_embed: true,
  enable_right_click_url: false,
  alias_length: 20,
  enble_prefix: false,
  // no prefix
  id_prefix: "",
  // prefix
  id_length: 4,
  // id length
  heading_id_newline: false,
  enable_block_notification: true,
  enable_embed_notification: true,
  enable_url_notification: true,
  // Time Section
  enable_time_section: true,
  time_section_format: "HH:mm",
  daily_note_pattern: "\\d{4}-\\d{1,2}-\\d{1,2}",
  insert_heading_level: true,
  daily_note_heading_level: 2,
  enable_time_section_in_menu: false,
  time_section_plain_style: false
  // Default to standard heading style
};
function generateRandomId(prefix, length) {
  if (length < 3 || length > 7) {
    throw new Error("Length must be between 3 and 7.");
  }
  const separator = prefix ? "-" : "";
  return `${prefix}${separator}${Math.random().toString(36).substring(2, 2 + length)}`;
}
function shouldInsertAfter(block) {
  if (block.type) {
    return [
      "blockquote",
      "code",
      "table",
      "comment",
      "footnoteDefinition"
    ].includes(block.type);
  }
}
function formatCurrentTime(format) {
  const now = new Date();
  const hours = now.getHours().toString().padStart(2, "0");
  const minutes = now.getMinutes().toString().padStart(2, "0");
  return format.replace("HH", hours).replace("mm", minutes);
}
function isTimeSection(text, format = "HH:mm") {
  const regex = new RegExp(`^(#{1,6})\\s+(\\d{1,2}:\\d{1,2})$`);
  return regex.test(text);
}
function isDailyNote(fileName, pattern) {
  console.log(`isDailyNote checking: fileName="${fileName}", pattern="${pattern}"`);
  try {
    const regex = new RegExp(pattern);
    const isMatch = regex.test(fileName);
    return isMatch;
  } catch (e) {
    console.error("Invalid regex pattern for daily note:", e);
    return false;
  }
}
function processLineContent(line) {
  if (!line.trim())
    return "";
  line = line.replace(/<[^>]+>/g, "");
  line = line.replace(/^[\s]*[-*+]\s+/, "");
  line = line.replace(/^[\s]*\d+\.\s+/, "");
  line = line.replace(/^[\s]*>+\s*/, "");
  line = line.replace(/\s*\^[a-zA-Z0-9-]+$/, "");
  line = line.replace(/\n/g, " ");
  return line.trim();
}
function processMultiLineContent(editor, start_line, end_line, alias_length) {
  let currentLine = start_line;
  while (currentLine <= end_line) {
    const line = editor.getLine(currentLine);
    const lineWithoutBlockId = line.replace(/\s*\^[a-zA-Z0-9-]+$/, "");
    if (!lineWithoutBlockId.trim()) {
      currentLine++;
      continue;
    }
    if (lineWithoutBlockId.startsWith("|-") || lineWithoutBlockId.startsWith("```")) {
      currentLine++;
      if (currentLine <= end_line) {
        const nextLine = editor.getLine(currentLine);
        if (nextLine.match(/^```\w+$/)) {
          currentLine++;
        }
      }
      continue;
    }
    const processedContent = processLineContent(lineWithoutBlockId);
    if (processedContent) {
      return processedContent.slice(0, alias_length);
    }
    currentLine++;
  }
  return "";
}
function analyzeHeadings(fileCache, editor, start_line, end_line) {
  var _a, _b, _c;
  if (start_line === 0 && end_line === 0) {
    console.log("block-link-plus: analyzeHeadings: start_line === 0 && end_line === 0");
    return {
      isValid: false,
      start_line,
      end_line,
      isMultiline: false,
      block: null,
      nearestBeforeStartLevel: 0,
      minLevelInRange: Infinity,
      hasHeadingAtStart: false,
      hasHeadingAtEnd: false,
      headingAtStart: null,
      headingAtEnd: null,
      isStartHeadingMinLevel: false,
      isEndLineJustBeforeHeading: false,
      blockContent: null,
      nearestHeadingTitle: null,
      selectedText: null,
      blockText: null
    };
  }
  if (!fileCache || end_line < start_line) {
    return {
      isValid: false,
      start_line,
      end_line,
      isMultiline: false,
      block: null,
      nearestBeforeStartLevel: 0,
      minLevelInRange: Infinity,
      hasHeadingAtStart: false,
      hasHeadingAtEnd: false,
      headingAtStart: null,
      headingAtEnd: null,
      isStartHeadingMinLevel: false,
      isEndLineJustBeforeHeading: false,
      blockContent: null,
      nearestHeadingTitle: null,
      selectedText: null,
      blockText: null
    };
  }
  let closestBeforeStartDistance = Infinity;
  let nearestHeadingTitle = null;
  let selectedText = editor.getSelection();
  let blockText = editor.getRange({ line: start_line, ch: 0 }, { line: end_line, ch: editor.getLine(end_line).length });
  if (start_line == end_line) {
    let head_block = (_a = fileCache.headings) == null ? void 0 : _a.find(
      (heading) => {
        const { start, end } = heading.position;
        return start.line == start_line;
      }
    );
    let block2 = (fileCache.sections || []).find((section) => {
      return section.position.start.line <= end_line && section.position.end.line >= end_line;
    });
    const blockContent2 = block2 ? processLineContent(editor.getLine(start_line)) : null;
    let nearestBeforeStartLevel2 = 0;
    let closestBeforeStartDistance2 = Infinity;
    (_b = fileCache.headings) == null ? void 0 : _b.forEach((heading) => {
      const { start, end } = heading.position;
      if (start.line < start_line) {
        if (heading.heading.startsWith("^") || heading.heading.startsWith("\u02C5")) {
          return;
        }
        const distance = start_line - start.line;
        if (distance < closestBeforeStartDistance2) {
          closestBeforeStartDistance2 = distance;
          nearestBeforeStartLevel2 = heading.level;
          nearestHeadingTitle = heading.heading;
        }
      }
    });
    return {
      isValid: true,
      start_line,
      end_line,
      isMultiline: false,
      block: block2,
      nearestBeforeStartLevel: nearestBeforeStartLevel2,
      minLevelInRange: head_block ? head_block.level : Infinity,
      hasHeadingAtStart: !!block2,
      hasHeadingAtEnd: false,
      headingAtStart: head_block || null,
      headingAtEnd: null,
      isStartHeadingMinLevel: block2 ? true : false,
      isEndLineJustBeforeHeading: false,
      blockContent: blockContent2,
      nearestHeadingTitle,
      selectedText,
      blockText
    };
  }
  let nearestBeforeStartLevel = 0;
  let minLevelInRange = Infinity;
  let hasHeadingAtStart = false;
  let hasHeadingAtEnd = false;
  let headingAtStart = null;
  let headingAtEnd = null;
  let isStartHeadingMinLevel = false;
  let isEndLineJustBeforeHeading = false;
  let inner_levels = new Array();
  (_c = fileCache.headings) == null ? void 0 : _c.forEach((heading) => {
    const { start, end } = heading.position;
    if (start.line < start_line) {
      const distance = start_line - start.line;
      if (start_line - start.line < closestBeforeStartDistance) {
        closestBeforeStartDistance = distance;
        nearestBeforeStartLevel = heading.level;
        if (heading.heading.startsWith("^") || heading.heading.startsWith("\u02C5")) {
          return;
        }
        nearestHeadingTitle = heading.heading;
      }
    }
    if (start.line >= start_line && end.line <= end_line) {
      minLevelInRange = Math.min(minLevelInRange, heading.level);
      inner_levels.push(heading.level);
    }
    if (start.line === start_line) {
      hasHeadingAtStart = true;
      headingAtStart = heading;
    }
    if (start.line === end_line) {
      hasHeadingAtEnd = true;
      headingAtEnd = heading;
    }
    if (start.line === end_line + 1 || start.line === end_line + 2) {
      isEndLineJustBeforeHeading = true;
    }
  });
  if (hasHeadingAtStart && headingAtStart != null) {
    if (headingAtStart.level === minLevelInRange) {
      const minLevel = Math.min(...inner_levels);
      const countOfMinLevel = inner_levels.filter(
        (level) => level === minLevel
      ).length;
      if (headingAtStart && // @ts-ignore
      headingAtStart.level === minLevel && countOfMinLevel === 1) {
        isStartHeadingMinLevel = true;
      }
    }
  }
  let block = (fileCache.sections || []).find((section) => {
    return section.position.start.line <= end_line && section.position.end.line >= end_line;
  });
  const blockContent = block ? processMultiLineContent(editor, start_line, end_line, MAX_ALIAS_LENGTH) : null;
  return {
    isValid: true,
    start_line,
    end_line,
    isMultiline: true,
    block,
    nearestBeforeStartLevel,
    minLevelInRange,
    hasHeadingAtStart,
    hasHeadingAtEnd,
    headingAtStart,
    headingAtEnd,
    isStartHeadingMinLevel,
    isEndLineJustBeforeHeading,
    blockContent,
    nearestHeadingTitle,
    selectedText,
    blockText
  };
}
function get_is_heading(head_analysis) {
  if (!head_analysis.isValid) {
    return false;
  }
  if (!head_analysis.isMultiline) {
    if (head_analysis.hasHeadingAtStart && head_analysis.headingAtStart != null)
      return true;
  } else {
    if (head_analysis.hasHeadingAtStart && // start_line is a heading
    head_analysis.isStartHeadingMinLevel)
      return true;
  }
  return false;
}
function gen_insert_blocklink_singleline(block, editor, settings) {
  if (block.id) {
    return `^${block.id}`;
  }
  if (block.type === "list") {
    const line = editor.getLine(block.position.start.line);
    const blockIdMatch = line.match(/\s*\^([a-zA-Z0-9-]+)\s*$/);
    if (blockIdMatch) {
      return `^${blockIdMatch[1]}`;
    }
  }
  const end = {
    line: block.type === "list" ? editor.getCursor("to").line : block.position.end.line,
    ch: block.type === "list" ? editor.getLine(editor.getCursor("to").line).length : block.position.end.col
  };
  if (block.type === "heading" && settings.heading_id_newline) {
    const id2 = generateRandomId(
      settings.enble_prefix ? settings.id_prefix : "",
      settings.id_length
    );
    editor.replaceRange(
      `

^${id2}`,
      { line: block.position.end.line, ch: block.position.end.col }
    );
    return `^${id2}`;
  }
  const id = generateRandomId(
    settings.enble_prefix ? settings.id_prefix : "",
    settings.id_length
  );
  const spacer = shouldInsertAfter(block) ? "\n\n" : " ";
  editor.replaceRange(`${spacer}^${id}`, end);
  return `^${id}`;
}
function gen_insert_blocklink_multline_heading(block, editor, settings, heading_level) {
  const id = generateRandomId(
    settings.enble_prefix ? settings.id_prefix : "",
    settings.id_length
  );
  const sectionEnd = block.position.end;
  const end = {
    ch: sectionEnd.col,
    line: sectionEnd.line
  };
  const heading = "#".repeat(heading_level);
  editor.replaceRange(`

 ${heading} ^${id}`, end);
  const cursor = editor.getCursor("from");
  editor.setCursor(cursor.line, cursor.ch);
  editor.replaceRange(`${heading} \u02C5${id}

`, {
    line: cursor.line,
    ch: 0
  });
  return `\u02C5${id}`;
}
function _gen_insert_block_singleline(line_num, editor, settings) {
  const line = editor.getLine(line_num);
  const blockIdMatch = line.match(/\s*\^([a-zA-Z0-9-]+)\s*$/);
  if (blockIdMatch) {
    return `^${blockIdMatch[1]}`;
  }
  const end = {
    line: line_num,
    ch: editor.getLine(line_num).length
  };
  const id = generateRandomId(
    settings.enble_prefix ? settings.id_prefix : "",
    settings.id_length
  );
  const spacer = " ";
  editor.replaceRange(`${spacer}^${id}`, end);
  return `^${id}`;
}
function gen_insert_blocklink_multline_block(fileCache, editor, settings) {
  if (fileCache.sections == null)
    return "";
  const start_line = editor.getCursor("from").line;
  const end_line = editor.getCursor("to").line;
  const sortedSections = [...fileCache.sections].sort(
    (a, b) => a.position.start.line - b.position.start.line
  );
  let links = new Array();
  for (const section of sortedSections) {
    if (section.position.start.line > end_line || section.position.end.line < start_line)
      continue;
    if (section.type === "list") {
      let _start_line = Math.max(section.position.start.line, start_line);
      let _end_line = Math.min(section.position.end.line, end_line);
      for (let i = _start_line; i <= _end_line; i++) {
        const id = _gen_insert_block_singleline(i, editor, settings);
        links.push(id);
      }
    } else {
      if (section.position.start.line >= start_line && section.position.end.line <= end_line) {
        const id = gen_insert_blocklink_singleline(
          section,
          editor,
          settings
        );
        links.push(id);
      }
    }
  }
  return links;
}
function createViewPlugin(rule = "(^| )\u02C5[a-zA-Z0-9_]+$") {
  let decorator = new import_view.MatchDecorator({
    regexp: new RegExp(rule, "g"),
    decoration: (match) => {
      if (match[0].match(/^#{1,6}\s+\d{1,2}:\d{1,2}$/)) {
        return import_view.Decoration.mark({ class: "time-section-plain" });
      }
      return import_view.Decoration.mark({ class: "small-font" });
    }
  });
  return import_view.ViewPlugin.define(
    (view) => ({
      decorations: decorator.createDeco(view),
      update(u) {
        this.decorations = decorator.updateDeco(u, this.decorations);
      }
    }),
    {
      decorations: (v) => v.decorations
    }
  );
}
var BlockLinkPlus = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.appName = this.manifest.name;
    this.editorExtensions = [];
  }
  async onload() {
    console.log(`loading ${this.appName}`);
    await this.loadSettings();
    this.addSettingTab(new BlockLinkPlusSettingsTab(this.app, this));
    this.addCustomStyles();
    this.registerEvent(
      this.app.workspace.on(
        "editor-menu",
        this.handleEditorMenu.bind(this)
      )
    );
    this.addCommand({
      id: "copy-link-to-block",
      name: "Copy Block Link",
      editorCheckCallback: (isChecking, editor, view) => {
        return this.handleCommand(isChecking, editor, view, false);
      }
    });
    this.addCommand({
      id: "copy-embed-to-block",
      name: "Copy Block as Embed",
      editorCheckCallback: (isChecking, editor, view) => {
        return this.handleCommand(isChecking, editor, view, true);
      }
    });
    this.addCommand({
      id: "copy-url-to-block",
      name: "Copy Block as Obsidian URI",
      editorCheckCallback: (isChecking, editor, view) => {
        return this.handleCommand(isChecking, editor, view, false, true);
      }
    });
    this.addCommand({
      id: "insert-time-section",
      name: "Insert Time Section",
      editorCheckCallback: this.handleTimeCommand.bind(this)
    });
    this.registerMarkdownPostProcessor(this.markdownPostProcessor.bind(this));
    this.updateViewPlugin();
  }
  /**
   * Updates the view plugin with the current settings.
   * This should be called whenever settings that affect the display are changed.
   */
  updateViewPlugin() {
    let rule = "(^| )\u02C5[a-zA-Z0-9_]+$";
    if (this.settings.time_section_plain_style) {
      rule = `(${rule})|(^#{1,6}\\s+\\d{1,2}:\\d{1,2}$)`;
    }
    this.viewPlugin = createViewPlugin(rule);
    this.registerEditorExtension([this.viewPlugin]);
  }
  /**
   * Processes markdown elements for rendering.
   * Handles special markers and applies custom styling.
   * @param el The HTML element to process
   */
  markdownPostProcessor(el) {
    if (!el.firstChild)
      return;
    if (el.firstChild instanceof Node) {
      let walker = document.createTreeWalker(
        el.firstChild,
        NodeFilter.SHOW_TEXT,
        null
      );
      let nodes = [];
      let node;
      while (node = walker.nextNode()) {
        nodes.push(node);
      }
      for (node of nodes) {
        node.textContent = node.textContent.replace(
          /\s*˅[a-zA-Z0-9-]*/g,
          ""
        );
      }
    }
    if (this.settings.time_section_plain_style) {
      const headings = el.querySelectorAll("h1, h2, h3, h4, h5, h6");
      headings.forEach((heading) => {
        if (heading.textContent && isTimeSection(heading.textContent.trim())) {
          heading.classList.add("time-section-plain");
        }
      });
    }
  }
  // Creates new LinkifyViewPlugins and registers them.
  // refreshExtensions() {
  // 	this.viewPlugin = createViewPlugin();
  // 	this.app.workspace.updateOptions();
  // }
  handleEditorMenu(menu, editor, view) {
    const file = view.file;
    if (!file)
      return;
    const start_line = editor.getCursor("from").line;
    const end_line = editor.getCursor("to").line;
    const fileCache = this.app.metadataCache.getFileCache(file);
    if (!fileCache)
      return;
    let head_analysis = analyzeHeadings(fileCache, editor, start_line, end_line);
    if (!head_analysis.isValid)
      return;
    let isHeading = get_is_heading(head_analysis);
    const addItemToMenu = (title, isEmbed, isUrl = false) => {
      menu.addItem((item) => {
        item.setTitle(title).setIcon("links-coming-in").onClick(
          () => this.handleMenuItemClick(
            view,
            isHeading,
            isEmbed,
            head_analysis,
            isUrl
          )
        );
      });
    };
    if (this.settings.enable_right_click_block) {
      addItemToMenu(
        isHeading ? "Copy Heading as Link" : "Copy Block as Link",
        false
      );
    }
    if (this.settings.enable_right_click_embed) {
      addItemToMenu(
        isHeading ? "Copy Heading as Embed" : "Copy Block as Embed",
        true
      );
    }
    if (this.settings.enable_right_click_url) {
      addItemToMenu(
        isHeading ? "Copy Heading as Obsidian URI" : "Copy Block as Obsidian URI",
        false,
        true
      );
    }
    if (this.settings.enable_time_section && this.settings.enable_time_section_in_menu) {
      menu.addItem((item) => {
        item.setTitle("Insert Time Section").setIcon("clock").onClick(() => {
          this.handleInsertTimeSection(editor, view, head_analysis);
        });
      });
    }
  }
  handleMenuItemClick(view, isHeading, isEmbed, head_analysis, isUrl = false) {
    if (!view.file || !head_analysis.isValid)
      return;
    const { file, editor } = view;
    const fileCache = this.app.metadataCache.getFileCache(file);
    if (!fileCache)
      return;
    if (!head_analysis.isMultiline) {
      this.handleSingleLine(file, isHeading, isEmbed, head_analysis, editor, isUrl);
    } else {
      this.handleMultiLine(file, isHeading, isEmbed, head_analysis, editor, fileCache, isUrl);
    }
  }
  handleSingleLine(file, isHeading, isEmbed, head_analysis, editor, isUrl = false) {
    let link;
    if (this.settings.heading_id_newline && head_analysis.block) {
      link = gen_insert_blocklink_singleline(head_analysis.block, editor, this.settings);
    } else if (isHeading && head_analysis.headingAtStart) {
      link = head_analysis.headingAtStart.heading;
    } else if (!isHeading && head_analysis.block) {
      link = gen_insert_blocklink_singleline(head_analysis.block, editor, this.settings);
    }
    if (link) {
      const alias = this.calculateAlias(link, isHeading, isEmbed, isUrl, this.settings.alias_length, head_analysis);
      this.copyToClipboard(file, link, isEmbed, alias, isUrl);
    }
  }
  handleMultiLine(file, isHeading, isEmbed, head_analysis, editor, fileCache, isUrl = false) {
    if (isHeading && head_analysis.headingAtStart) {
      this.copyToClipboard(
        file,
        head_analysis.headingAtStart.heading,
        isEmbed,
        void 0,
        isUrl
      );
    } else {
      this.handleMultiLineBlock(file, isEmbed, head_analysis, editor, fileCache, isUrl);
    }
  }
  _gen_insert_blocklink_multline_heading(fileCache, editor, head_analysis) {
    if (!head_analysis.block)
      return "";
    return gen_insert_blocklink_multline_heading(
      head_analysis.block,
      editor,
      this.settings,
      head_analysis.nearestBeforeStartLevel + 1
    );
  }
  _gen_insert_blocklink_multline_block(fileCache, editor, head_analysis) {
    return gen_insert_blocklink_multline_block(
      fileCache,
      editor,
      this.settings
    );
  }
  _gene_obsidian_url(file, blockId) {
    const vault = this.app.vault.getName();
    const filePath = encodeURIComponent(file.path);
    const encodedBlockId = encodeURIComponent(`#${blockId}`);
    return `obsidian://open?vault=${vault}&file=${filePath}${encodedBlockId}`;
  }
  handleMultiLineBlock(file, isEmbed, head_analysis, editor, fileCache, isUrl = false) {
    if (this.settings.mult_line_handle == 0 /* oneline */) {
      if (head_analysis.block) {
        const link = gen_insert_blocklink_singleline(
          head_analysis.block,
          editor,
          this.settings
        );
        const alias = this.calculateAlias(link, false, isEmbed, isUrl, this.settings.alias_length, head_analysis);
        this.copyToClipboard(file, link, isEmbed, alias, isUrl);
      }
      return;
    } else {
      if (head_analysis.minLevelInRange != Infinity) {
        new import_obsidian.Notice(
          `Selection cannot contain headings`,
          1500
        );
        return;
      }
      const linkMethod = this.settings.mult_line_handle == 1 /* heading */ ? this._gen_insert_blocklink_multline_heading : this._gen_insert_blocklink_multline_block;
      const link = linkMethod.call(
        this,
        fileCache,
        editor,
        head_analysis
      );
      const alias = this.calculateAlias(link, false, isEmbed, isUrl, this.settings.alias_length, head_analysis);
      this.copyToClipboard(file, link, isEmbed, alias, isUrl);
      return;
    }
  }
  onunload() {
    console.log(`unloading ${this.appName}`);
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.updateViewPlugin();
  }
  handleCommand(isChecking, editor, view, isEmbed, isUrl = false) {
    if (isChecking) {
      return true;
    }
    const file = view.file;
    if (!file)
      return;
    const start_line = editor.getCursor("from").line;
    const end_line = editor.getCursor("to").line;
    const fileCache = this.app.metadataCache.getFileCache(file);
    if (!fileCache)
      return;
    let head_analysis = analyzeHeadings(fileCache, editor, start_line, end_line);
    if (!head_analysis.isValid) {
      return;
    }
    let isHeading = get_is_heading(head_analysis);
    if (!head_analysis.isMultiline) {
      this.handleSingleLine(
        file,
        isHeading,
        isEmbed,
        head_analysis,
        editor,
        isUrl
      );
    } else {
      this.handleMultiLine(
        file,
        isHeading,
        isEmbed,
        head_analysis,
        editor,
        fileCache,
        isUrl
      );
    }
    return true;
  }
  /**
   * Copies links to one or more blocks to the clipboard.
   *
   * @param file - The file containing the blocks.
   * @param links - An array of block links (^id) or heading links (heading without `#`).
   * @param isEmbed - Specifies whether the links should be embedded.
   * @param alias - An optional alias for the links.
   * @param isUrl - Specifies whether the links should be URL links.
   */
  copyToClipboard(file, links, isEmbed, alias, isUrl = false) {
    const linksArray = typeof links === "string" ? [links] : links;
    const aliasArray = typeof alias === "string" ? [alias] : alias;
    const content = linksArray.map((link, index) => {
      var _a;
      const addNewLine = index < linksArray.length - 1 ? "\n" : "";
      if (isUrl) {
        return `${this._gene_obsidian_url(file, link)}${addNewLine}`;
      }
      return `${isEmbed ? "!" : ""}${this.app.fileManager.generateMarkdownLink(
        file,
        "",
        "#" + link,
        (_a = aliasArray == null ? void 0 : aliasArray[index]) != null ? _a : ""
      )}${addNewLine}`;
    }).join("");
    navigator.clipboard.writeText(content);
    if (isUrl && this.settings.enable_url_notification) {
      new import_obsidian.Notice("Obsidian URI copied to clipboard");
    } else if (isEmbed && this.settings.enable_embed_notification) {
      new import_obsidian.Notice("Block embed link copied to clipboard");
    } else if (!isEmbed && !isUrl && this.settings.enable_block_notification) {
      new import_obsidian.Notice("Block link copied to clipboard");
    }
  }
  /**
   * Calculate alias based on settings and analysis result
   */
  calculateAlias(links, isHeading, isEmbed, isUrl, alias_length, head_analysis) {
    var _a, _b, _c;
    if (isEmbed || isUrl || Number(this.settings.alias_type) === 0 /* Default */) {
      return void 0;
    }
    if (isHeading && head_analysis.headingAtStart) {
      return head_analysis.headingAtStart.heading;
    }
    switch (Number(this.settings.alias_type)) {
      case 1 /* FirstChars */:
        return links instanceof Array ? (_a = head_analysis.blockText) == null ? void 0 : _a.split("\n").filter((line) => line.length > 0).map((line) => processLineContent(line).slice(0, alias_length)) : (_b = head_analysis.blockContent) == null ? void 0 : _b.slice(0, alias_length);
      case 2 /* Heading */:
        return head_analysis.nearestHeadingTitle != null ? head_analysis.nearestHeadingTitle.slice(0, alias_length) : void 0;
      case 3 /* SelectedText */:
        const selectedText = (_c = head_analysis.selectedText) == null ? void 0 : _c.trim();
        if (!selectedText) {
          return void 0;
        }
        return links instanceof Array ? selectedText.split("\n").filter((line) => line.length > 0).map((line) => processLineContent(line)) : processLineContent(selectedText) || void 0;
      default:
        return void 0;
    }
  }
  /**
   * Handle inserting time section
   * @param editor Editor instance
   * @param view Current view
   * @param headAnalysis Optional existing heading analysis result
   */
  handleInsertTimeSection(editor, view, headAnalysis) {
    if (!this.settings.enable_time_section)
      return;
    const file = view.file;
    if (!file)
      return;
    const timeStr = formatCurrentTime(this.settings.time_section_format);
    const cursorLine = editor.getCursor().line;
    let headingLevel = 1;
    let insertText = "";
    const isDaily = isDailyNote(file.basename, this.settings.daily_note_pattern);
    if (isDaily) {
      headingLevel = this.settings.daily_note_heading_level;
    } else {
      if (headAnalysis && headAnalysis.isValid) {
        headingLevel = Math.min(headAnalysis.nearestBeforeStartLevel + 1, 6);
        if (headingLevel === 0)
          headingLevel = 1;
      } else {
        const fileCache = this.app.metadataCache.getFileCache(file);
        if (fileCache) {
          const newHeadAnalysis = analyzeHeadings(fileCache, editor, cursorLine, cursorLine);
          if (newHeadAnalysis.isValid) {
            headingLevel = Math.min(newHeadAnalysis.nearestBeforeStartLevel + 1, 6);
            if (headingLevel === 0)
              headingLevel = 1;
          }
        }
      }
    }
    if (this.settings.insert_heading_level) {
      insertText = "#".repeat(headingLevel) + " " + timeStr + "\n";
    } else {
      insertText = timeStr + "\n";
    }
    editor.replaceRange(insertText, editor.getCursor());
    const newPosition = {
      line: cursorLine + 1,
      ch: 0
    };
    editor.setCursor(newPosition);
  }
  /**
   * Handle the insert time section command
   * @param isChecking Whether this is a checking call
   * @param editor Editor instance
   * @param view Current view
   * @returns Whether the command can be executed
   */
  handleTimeCommand(isChecking, editor, view) {
    if (isChecking) {
      return this.settings.enable_time_section;
    }
    const file = view.file;
    if (!file)
      return false;
    const start_line = editor.getCursor("from").line;
    const end_line = editor.getCursor("to").line;
    const fileCache = this.app.metadataCache.getFileCache(file);
    if (!fileCache)
      return false;
    let head_analysis = analyzeHeadings(fileCache, editor, start_line, end_line);
    if (!head_analysis.isValid) {
      this.handleInsertTimeSection(editor, view);
    } else {
      this.handleInsertTimeSection(editor, view, head_analysis);
    }
    return true;
  }
  /**
   * Adds custom CSS styles to the document for plugin-specific styling
   */
  addCustomStyles() {
    const css = `
			.time-section-plain {
				font-size: var(--font-text-size) !important;
				font-weight: normal !important;
				color: var(--text-normal) !important;
				margin-top: 0 !important;
				margin-bottom: 0 !important;
				line-height: var(--line-height-normal) !important;
				/* Remove any special heading styling */
				border: none !important;
				padding: 0 !important;
			}
		`;
    const styleEl = document.createElement("style");
    styleEl.textContent = css;
    document.head.appendChild(styleEl);
    this.register(() => styleEl.remove());
  }
};
var BlockLinkPlusSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  addToggleSetting(settingName, extraOnChange) {
    return new import_obsidian.Setting(this.containerEl).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings[settingName]).onChange(async (value) => {
        this.plugin.settings[settingName] = value;
        await this.plugin.saveSettings();
        extraOnChange == null ? void 0 : extraOnChange(value);
      });
    });
  }
  // 文本输入框
  addTextInputSetting(settingName, placeholder) {
    return new import_obsidian.Setting(this.containerEl).addText(
      (text) => text.setPlaceholder(placeholder).setValue(this.plugin.settings[settingName]).onChange(async (value) => {
        if (value.length > 0) {
          this.plugin.settings[settingName] = value;
          await this.plugin.saveSettings();
        }
      })
    );
  }
  addDropdownSetting(settingName, options, display) {
    return new import_obsidian.Setting(this.containerEl).addDropdown((dropdown) => {
      var _a;
      const displayNames = /* @__PURE__ */ new Set();
      for (const option of options) {
        const displayName = (_a = display == null ? void 0 : display(option)) != null ? _a : option;
        if (!displayNames.has(displayName)) {
          dropdown.addOption(option, displayName);
          displayNames.add(displayName);
        }
      }
      dropdown.setValue(this.plugin.settings[settingName]).onChange(async (value) => {
        this.plugin.settings[settingName] = value;
        await this.plugin.saveSettings();
      });
    });
  }
  addSliderSetting(settingName, min, max, step) {
    return new import_obsidian.Setting(this.containerEl).addSlider((slider) => {
      slider.setLimits(min, max, step).setValue(this.plugin.settings[settingName]).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings[settingName] = value;
        await this.plugin.saveSettings();
      });
    });
  }
  addHeading(heading) {
    return new import_obsidian.Setting(this.containerEl).setName(heading).setHeading();
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Block link Plus" });
    this.addDropdownSetting(
      //@ts-ignore
      "mult_line_handle",
      ["0", "1", "2"],
      (option) => {
        const optionsSet = /* @__PURE__ */ new Map([
          ["0", "Default"],
          ["1", "Add new heading"],
          ["2", "Add multi block"]
        ]);
        return optionsSet.get(option) || "Unknown";
      }
    ).setName("Multi-line block behavior").setDesc(
      "Define how multi-line selections generate block ids. 'Default' treats them as a single line."
    );
    this.addHeading("Block link").setDesc("Link: [[file#block_id]]");
    this.addToggleSetting("enable_right_click_block").setName("Enable block link in right click menu");
    this.addToggleSetting("enable_block_notification").setName("Show notification when block link is copied");
    this.addDropdownSetting(
      //@ts-ignore
      "alias_type",
      ["0", "1", "2", "3"],
      (option) => {
        const optionsSet = /* @__PURE__ */ new Map([
          ["0", "No alias"],
          ["1", "First X chars"],
          ["2", "Parent heading"],
          ["3", "Selected text"]
        ]);
        return optionsSet.get(option) || "Unknown";
      }
    ).setName("Alias style").setDesc(
      "Choose how to generate aliases for block links.For heading blocks, alias will always be the heading text unless 'No alias' is selected."
    );
    this.addSliderSetting("alias_length", 1, 100, 1).setName("Alias length").setDesc("Set the length of the alias (1-100). Only used when alias style is 'First X chars'.");
    this.addToggleSetting("heading_id_newline").setName("Experimental: Heading block ID style").setDesc("Place block ID in new line when selecting a single heading line only");
    this.addHeading("Embed link").setDesc("Link: ![[file#block_id]]");
    this.addToggleSetting("enable_right_click_embed").setName("Enable embed link in right click menu");
    this.addToggleSetting("enable_embed_notification").setName("Show notification when embed link is copied");
    this.addHeading("Obsidian URI link").setDesc("Link: obsidian://open?vault=${vault}&file=${filePath}${encodedBlockId} ");
    this.addToggleSetting("enable_right_click_url").setName("Enable Obsidian URI link in right click menu");
    this.addToggleSetting("enable_url_notification").setName("Show notification when URI link is copied");
    this.addHeading("Block Id").setDesc("Custom block_id");
    this.addSliderSetting("id_length", 3, 7, 1).setName("Max block id Length").setDesc("Set the maximum number of characters for a block id.");
    this.addToggleSetting("enble_prefix").setName("Custom id prefix");
    this.addTextInputSetting("id_prefix", "").setName("Block id prefix").setDesc("Block id will be: prefix-random_str");
    this.addHeading("Time Section").setDesc("Insert time-based headings");
    this.addToggleSetting("enable_time_section").setName("Enable time section feature");
    this.addToggleSetting("enable_time_section_in_menu").setName("Show in context menu").setDesc("If enabled, adds time section option to the right-click menu");
    this.addTextInputSetting("time_section_format", "HH:mm").setName("Time format").setDesc("Format for the time section (HH:mm = 24-hour format)");
    this.addToggleSetting("insert_heading_level").setName("Insert as heading").setDesc("If enabled, inserts time with heading marks (#), otherwise inserts just the time");
    this.addToggleSetting("time_section_plain_style", (value) => {
      this.plugin.updateViewPlugin();
    }).setName("Plain text style in preview").setDesc("If enabled, time sections will appear as plain text in preview mode, even when inserted as headings");
    this.addTextInputSetting("daily_note_pattern", "\\d{4}-\\d{1,2}-\\d{1,2}").setName("Daily note pattern").setDesc("Regular expression to identify daily note filenames (default: YYYY-MM-DD)");
    this.addSliderSetting("daily_note_heading_level", 1, 6, 1).setName("Daily note heading level").setDesc("Heading level to use in daily notes (1-6, corresponds to #-######)");
  }
};


/* nosourcemap */